<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sqlMap
	PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN"
	"http://ibatis.apache.org/dtd/sql-map-2.dtd">
		
<sqlMap namespace="waterinfoDAO">

	<typeAlias alias="taksuVO" type="daewooInfo.waterpolmnt.waterinfo.bean.TaksuVO"/>
	<typeAlias alias="searchTaksuVO" type="daewooInfo.waterpolmnt.waterinfo.bean.SearchTaksuVO"/>
	<typeAlias alias="algaCastDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.AlgaCastDataVO"/>
	<typeAlias alias="airMntDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.AirMntDataVO"/>
	<typeAlias alias="riverWater3HourWarningVO" type="daewooInfo.waterpolmnt.waterinfo.bean.RiverWater3HourWarningVO"/>
	<typeAlias alias="riverWater3HourWarningSearchVO" type="daewooInfo.waterpolmnt.waterinfo.bean.RiverWater3HourWarningSearchVO"/>
	<typeAlias alias="riverWater3HourWarningPopDetailVO" type="daewooInfo.waterpolmnt.waterinfo.bean.RiverWater3HourWarningPopDetailVO"/>
	<typeAlias alias="riverWater3HourWarningPopDetailSearchVO" type="daewooInfo.waterpolmnt.waterinfo.bean.RiverWater3HourWarningPopDetailSearchVO"/>
	<typeAlias alias="detailViewVO" type="daewooInfo.waterpolmnt.waterinfo.bean.DetailViewVO"/>	
	<typeAlias alias="flowDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.FlowDataVO"/>	
	<typeAlias alias="damDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.DamDataVO"/>	
	<typeAlias alias="locationVO" type="daewooInfo.waterpolmnt.waterinfo.bean.LocationVO"/>
	<typeAlias alias="boSearchVO" type="daewooInfo.waterpolmnt.waterinfo.bean.BoSearchVO"/>
	<typeAlias alias="cmnSearchVO" type="daewooInfo.waterpolmnt.waterinfo.bean.CmnSearchVO"/>
	<typeAlias alias="damViewVO" type="daewooInfo.waterpolmnt.waterinfo.bean.DamViewVO"/>
	<typeAlias alias="waterDcViewVO" type="daewooInfo.waterpolmnt.waterinfo.bean.WaterDcViewVO"/>
	<typeAlias alias="factoryIndustViewVO" type="daewooInfo.waterpolmnt.waterinfo.bean.FactoryIndustViewVO"/>
	<typeAlias alias="boViewVO" type="daewooInfo.waterpolmnt.waterinfo.bean.BoViewVO"/>
	<typeAlias alias="basinViewVO" type="daewooInfo.waterpolmnt.waterinfo.bean.BasinViewVO"/>
	<typeAlias alias="relateOfficeDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.RelateOfficeDataVO"/>
	<typeAlias alias="ecompanyDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.EcompanyDataVO"/>
	<typeAlias alias="ecompayOwnItemDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.EcompayOwnItemDataVO"/>
	<typeAlias alias="areaDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.AreaDataVO"/>
	<typeAlias alias="limitDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.LimitDataVO"/>
	<typeAlias alias="limitViewVO" type="daewooInfo.waterpolmnt.waterinfo.bean.LimitViewVO"/>		
	<typeAlias alias="selectDataVO" type="daewooInfo.waterpolmnt.waterinfo.bean.SelectDataVO"/>
	<typeAlias alias="sumViewVO" type="daewooInfo.waterpolmnt.waterinfo.bean.SumViewVO"/>
	<typeAlias alias="excelModelVO" type="daewooInfo.waterpolmnt.waterinfo.bean.ExcelModelingVO"/>			
	
	<statement id="getSugyeList" parameterClass="HashMap" resultClass="HashMap">
		<isEqual property="system" compareValue="W">
		    SELECT DO_CODE VALUE, 
			       DO_NAME CAPTION
			  FROM WTMSC_AREA@TMS A 
		<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
			   INNER JOIN 
			       (SELECT CTY_CODE 
			         FROM T_MEMBER_AUTHORINFO B 
			        WHERE B.MEMBER_ID = #userId# 
			        GROUP BY CTY_CODE 
			       ) B 
			       ON A.CTY_CODE = B.CTY_CODE 
		</isNotEqual>
			 GROUP BY DO_CODE, 
			       DO_NAME 
			ORDER BY DO_CODE 
		</isEqual>
		<isNotEqual property="system" compareValue="W">
		SELECT DISTINCT RIVER_DIV VALUE, B.COMMON_CODE_NAME CAPTION
          FROM T_MEMBER_AUTHORINFO A, T_COMMON_CODE B
         WHERE MEMBER_ID = #userId#
              AND SYS_KIND = #system#
             AND B.USE_FLAG = 'Y'
             AND A.RIVER_DIV = B.COMMON_CODE(+)
         ORDER BY RIVER_DIV
         </isNotEqual>
	</statement>
	
	<statement id="getSystemList" parameterClass="HashMap" resultClass="HashMap">
		SELECT COMMON_CODE VALUE, 
		       COMMON_CODE_NAME CAPTION 
		  FROM T_COMMON_CODE A 
		<isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
		   INNER JOIN 
		       (SELECT SYS_KIND 
		         FROM T_MEMBER_AUTHORINFO B 
		        WHERE B.MEMBER_ID = #id#
		        GROUP BY SYS_KIND
		       ) B
		       ON A.COMMON_CODE = B.SYS_KIND
		</isNotEqual>
		 WHERE COMMON_CODE_CATEGORY = '00' 
		ORDER BY CODE_SORT
	</statement>
	
	<statement id="getSugyeListMain" parameterClass="HashMap" resultClass="HashMap">
		<isNotEqual property="system" compareValue="W">
		    SELECT COMMON_CODE VALUE, 
			       COMMON_CODE_NAME CAPTION 
			  FROM T_COMMON_CODE A
		<isNotEqual property="roleCode" compareValue="ROLE_ADMIN"> 
			   INNER JOIN 
			       (SELECT B.RIVER_DIV 
			         FROM T_MEMBER_AUTHORINFO B 
			        WHERE B.MEMBER_ID = #id# 
			          AND B.SYS_KIND = #system#
			        GROUP BY B.RIVER_DIV
			       ) B 
			       ON A.COMMON_CODE = B.RIVER_DIV 
		</isNotEqual>
			 WHERE COMMON_CODE_CATEGORY = '01' 
			ORDER BY CODE_SORT
		</isNotEqual>
		<isEqual property="system" compareValue="W">
		    SELECT DO_CODE VALUE, 
			       DO_NAME CAPTION
			  FROM WTMSC_AREA@TMS A 
		<isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
			   INNER JOIN 
			       (SELECT CTY_CODE 
			         FROM T_MEMBER_AUTHORINFO B 
			        WHERE B.MEMBER_ID = #id# 
			        GROUP BY CTY_CODE 
			       ) B 
			       ON A.CTY_CODE = B.CTY_CODE 
		</isNotEqual>
			 GROUP BY DO_CODE, 
			       DO_NAME 
			ORDER BY DO_CODE 
		</isEqual>
	</statement>
	

	<statement id="getGongkuListNew" parameterClass="HashMap" resultClass="HashMap">
		SELECT DECODE(A.SYS_KIND,'A',A.FACT_NAME,'U',B.BRANCH_NAME || '-' || B.BRANCH_NO) AS CAPTION, 
		       A.FACT_CODE AS VALUE, 
		       B.BRANCH_NO 
		  FROM T_FACT_INFO A 
		   INNER JOIN T_FACT_BRANCH_INFO B 
		       ON A.FACT_CODE = B.FACT_CODE 
		       AND B.BRANCH_USE_FLAG = 'Y' 
		<isNotEmpty property="roleCode">
			<isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
		   INNER JOIN 
		       (SELECT B.FACT_CODE, B.BRANCH_NO 
			 FROM T_MEMBER_AUTHORINFO B 
			WHERE B.MEMBER_ID = #id# 
			GROUP BY B.FACT_CODE, B.BRANCH_NO 
		       ) C 
		       ON A.FACT_CODE = C.FACT_CODE
		       AND B.BRANCH_NO =  C.BRANCH_NO
			</isNotEqual>
		 </isNotEmpty>
		 WHERE A.FACT_USE_FLAG = 'Y' 
		    <isNotEqual prepend="AND" property="system" compareValue="all">
				A.SYS_KIND = #system#
			</isNotEqual>
			<isNotEqual prepend="AND" property="sugye" compareValue="all">
				A.RIVER_DIV = #sugye#
			</isNotEqual>
		ORDER BY A.FACT_CODE,B.BRANCH_NO
	</statement>
	
	<statement id="getTMSList" parameterClass="HashMap" resultClass="HashMap">
		SELECT FACT.FACT_NAME AS CAPTION, FACT.FACT_CODE AS VALUE
		FROM
				WTMSC_FACT@TMS FACT
				INNER JOIN WTMSC_AREA@TMS AREA
				ON AREA.CTY_CODE = FACT.CTY_CODE
				<isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
				   INNER JOIN 
				       (SELECT B.FACT_CODE 
					 FROM T_MEMBER_AUTHORINFO B 
					WHERE B.MEMBER_ID = #id# 
					GROUP BY B.FACT_CODE 
				       ) C 
       				ON FACT.FACT_CODE = C.FACT_CODE  
				</isNotEqual>
		WHERE FACT_USED = 'Y'
			<isNotEqual prepend="AND" property="sugye" compareValue="all">
					AREA.DO_CODE = #sugye#
			</isNotEqual>
		ORDER BY FACT_NAME ASC
	</statement>
	
	
	<statement id="getGongkuList" parameterClass="HashMap" resultClass="HashMap">
		SELECT F01.FACT_NAME AS CAPTION, F01.FACT_CODE AS VALUE
		  FROM T_FACT_INFO F01
		  <isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
		  , T_MEMBER_AUTHORINFO F02
		  </isNotEqual>
		 WHERE F01.FACT_USE_FLAG = 'Y'
		<isNotEqual prepend="AND" property="system" compareValue="all">
			F01.SYS_KIND = #system#
		</isNotEqual>
		<isNotEqual prepend="AND" property="sugye" compareValue="all">
			F01.RIVER_DIV = #sugye#
		</isNotEqual>
		<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
			AND F02.MEMBER_ID = #userId#
			AND F01.SYS_KIND = F02.SYS_KIND
     		AND F01.RIVER_DIV = F02.RIVER_DIV
      		AND F01.FACT_CODE = F02.FACT_CODE
		</isNotEqual>
		ORDER BY F01.FACT_NAME ASC
	</statement>
	
	<statement id="getFlowFact" parameterClass="HashMap" resultClass="HashMap">
		SELECT OBSNM AS CAPTION, FWOBSCD AS VALUE
			FROM T_FWOBSIF
		 WHERE EVTFG = 'Y'
		<isNotEqual prepend="AND" property="sugye" compareValue="all">
			RIVER_DIV = #sugye#
		</isNotEqual>
		ORDER BY OBSNM ASC
	</statement>
	
	
	<statement id="getWLFact" parameterClass="HashMap" resultClass="HashMap">
		SELECT OBSNM AS CAPTION, WLOBSCD AS VALUE
			FROM T_WLOBSIF
		<isNotEqual property="sugye" compareValue="all">
		WHERE
			RIVER_DIV = #sugye#
		</isNotEqual>
		ORDER BY OBSNM ASC
	</statement>
	
	
	<statement id="getBranchList" parameterClass="HashMap" resultClass="HashMap">
		SELECT 
			BRANCH_NAME,
			BRANCH_NAME||'-'||BRANCH_NO AS CAPTION, 
			BRANCH_NO VALUE
		FROM T_FACT_BRANCH_INFO
		WHERE BRANCH_USE_FLAG = 'Y'
		<isNotEqual prepend="AND" property="factCode" compareValue="all">
			FACT_CODE = #factCode#
		</isNotEqual>
		ORDER BY BRANCH_NO ASC
	</statement>
	
	<statement id="getBranchListNew" parameterClass="HashMap" resultClass="HashMap">
		SELECT 
				  B.BRANCH_NAME,
				  B.BRANCH_NAME||'-'||B.BRANCH_NO AS CAPTION,
				  B.BRANCH_NO VALUE
		  FROM T_MEMBER_AUTHORINFO A, T_FACT_BRANCH_INFO B
		WHERE A.MEMBER_ID = #userId#
		   AND  B.BRANCH_USE_FLAG = 'Y'
		    <isNotEqual prepend="AND" property="factCode" compareValue="all">
				A.FACT_CODE = #factCode#
			</isNotEqual>
		    AND A.FACT_CODE = B.FACT_CODE
		    AND A.BRANCH_NO = B.BRANCH_NO
		 ORDER BY B.BRANCH_NO ASC
	</statement>
	
	<statement id="getFactBranchCnt" parameterClass="HashMap" resultClass="String">
		SELECT BRANCH_CNT
			FROM T_FACT_INFO
			WHERE
		<isNotEqual property="factCode" compareValue="all">
			FACT_CODE = #factCode#
		</isNotEqual>
	</statement> 
	
	<statement id="getItemList" remapResults="true" parameterClass="HashMap" resultClass="HashMap">
		<isNotNull property="sugye">
			SELECT B.ITEM_NAME AS CAPTION, A.ITEM_CODE VALUE, B.ITEM_SEQ
			  FROM T_FACT_MEASU_ITEM A, T_ITEM_INFO B
			 WHERE A.ITEM_USE_FLAG = 'Y' AND B.ITEM_USE_FLAG = 'Y' AND A.ITEM_CODE = B.ITEM_CODE
					AND A.FACT_CODE IN
							(SELECT F01.FACT_CODE
								FROM T_FACT_INFO F01
							  WHERE	 F01.FACT_USE_FLAG = 'Y'
									AND F01.SYS_KIND = #system#
									AND F01.RIVER_DIV = #sugye#)
			GROUP BY A.ITEM_CODE, B.ITEM_NAME, B.ITEM_SEQ
			ORDER BY ITEM_SEQ
		</isNotNull>
		<isNull property="sugye">
			SELECT B.ITEM_NAME AS CAPTION, A.ITEM_CODE VALUE
			FROM T_FACT_MEASU_ITEM A,
					T_ITEM_INFO B
			WHERE A.ITEM_USE_FLAG = 'Y'
				AND B.ITEM_USE_FLAG = 'Y'
				AND A.ITEM_CODE = B.ITEM_CODE
			<isNotEqual prepend="AND" property="factCode" compareValue="all">
				FACT_CODE = #factCode#
			</isNotEqual>
			<isNotEqual prepend="AND" property="branchNo" compareValue="all">
				BRANCH_NO = #branchNo#
			</isNotEqual>
			ORDER BY B.ITEM_SEQ
		</isNull>
	</statement>
	
	<statement id="getItemList2" parameterClass="HashMap" resultClass="HashMap">
		SELECT DISTINCT
			W.ITEM_CODE VALUE,
			(SELECT ITEM_FNAME FROM T_ITEM_INFO WHERE ITEM_CODE = W.ITEM_CODE) CAPTION
			,C.CODE_SORT
		FROM
			T_WQA_ITEM W,
			T_COMMON_CODE C
		WHERE
			W.ITEM_KIND = #itemKind#
			AND C.COMMON_CODE(+) = W.ITEM_CODE
		ORDER BY 
			C.CODE_SORT
	</statement>
	
	<statement id="getTMSListNew" parameterClass="HashMap" resultClass="HashMap">
	    <isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
		SELECT FACT.FACT_NAME AS CAPTION,
			  FACT.FACT_CODE      AS VALUE
			FROM WTMSC_FACT@TMS FACT
			INNER JOIN WTMSC_AREA@TMS AREA
			ON AREA.CTY_CODE = FACT.CTY_CODE
			INNER JOIN
			  (SELECT B.FACT_CODE
			  FROM T_MEMBER_AUTHORINFO B
			  WHERE B.MEMBER_ID = #userId#
			  GROUP BY B.FACT_CODE
			  ) C
			ON FACT.FACT_CODE = C.FACT_CODE
			WHERE FACT_USED   = 'Y'
			AND AREA.DO_CODE  = #sugye#
			ORDER BY FACT_NAME ASC 
		</isNotEqual>
		<isEqual property="userGubun" compareValue="ROLE_ADMIN">
		SELECT FACT.FACT_NAME AS CAPTION, FACT.FACT_CODE AS VALUE
		FROM
				WTMSC_FACT@TMS FACT,
				WTMSC_AREA@TMS AREA
		WHERE
				FACT_USED = 'Y'
				AND AREA.CTY_CODE = FACT.CTY_CODE
			<isNotEqual prepend="AND" property="sugye" compareValue="all">
					AREA.DO_CODE = #sugye#
			</isNotEqual>
		ORDER BY FACT_NAME ASC
		</isEqual>
	</statement>
	
	<statement id="getTMSList2" parameterClass="HashMap" resultClass="HashMap">
		SELECT FACT.FACT_NAME AS CAPTION, FACT.FACT_CODE AS VALUE
		FROM
				WTMSC_FACT@TMS FACT,
				WTMSC_AREA@TMS AREA
		WHERE
				FACT_USED = 'Y'
				AND AREA.CTY_CODE = FACT.CTY_CODE
			<isNotEqual prepend="AND" property="sugye" compareValue="all">
					AREA.DO_CODE = #sugye#
			</isNotEqual>
			<isNotEqual prepend="AND" property="tmsCtyCode" compareValue="all">
					AREA.CTY_CODE = #tmsCtyCode#
			</isNotEqual>
		ORDER BY FACT_NAME ASC
	</statement>
	
	<statement id="getTMSRiverD1List" parameterClass="HashMap" resultClass="HashMap">
		SELECT CD_NAME AS CAPTION, CD AS VALUE
			FROM WTMSC_CODE@tms
			WHERE CD_GBN = '18'
			ORDER BY CD_ORDER ASC, CD ASC
	</statement>
	
	<statement id="getTMSRiverD2List" parameterClass="HashMap" resultClass="HashMap">
		SELECT NAME||'('||S_SIDO||' '||replace(S_GUGUN,chr(10),' ')||')'  AS CAPTION, CODE AS VALUE
			FROM WTMSC_RIVER@tms
			WHERE CAT_CD = #sugye#
		 ORDER BY NAME ASC
	 </statement>
	
	
	<statement id="getWastList" parameterClass="HashMap" resultClass="HashMap">
		SELECT WAST_NO AS CAPTION, WAST_NO VALUE
		FROM WTMSC_FACT_WAST@TMS
		WHERE WAST_USED = 'Y'
		<isNotEqual prepend="AND" property="factCode" compareValue="all">
			FACT_CODE = #factCode#
		</isNotEqual>
	</statement>
	
	<select id="getTotCntRiver_MIN" parameterClass="searchTaksuVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT
					COUNT(*)
					FROM
					(
							<isEqual property="sys" compareValue="U">
								SELECT
									QQ.FACT_CODE FACTCODE,
									QQ.FACT_NAME FACTNAME,
									QQ.BRANCH_NO BRANCHNO,
									QQ.BRANCH_NAME BRANCH_NAME,
									QQ.MIN_TIME MINTIME,
									TUR, CON, DOW, TMP, PHY, CON_OR, DOW_OR, TMP_OR, PHY_OR, TUR_OR,
									IMP, LIM, RIM, LIM_OR, RIM_OR, LTX, RTX, LTX_OR, RTX_OR, TOX, TOX_OR, EVN, EVN_OR, TOF, TOF_OR,
									VOC1, VOC2, VOC3, VOC4, VOC5, VOC6, VOC7, VOC8, VOC9, VOC10, VOC11, VOC12, VOC13, VOC14, VOC15,
									VOC1_OR, VOC2_OR, VOC3_OR, VOC4_OR, VOC5_OR, VOC6_OR, VOC7_OR, VOC8_OR, VOC9_OR, VOC10_OR, VOC11_OR, VOC12_OR, VOC13_OR, VOC14_OR, VOC15_OR,
									COP, PLU, ZIN, CAD, PHE, PHL, TOC, TON, TOP, NH4, NO3, PO4, RIN
									COP_OR, PLU_OR, ZIN_OR, CAD_OR, PHE_OR, PHL_OR, TOC_OR, TON_OR, TOP_OR, NH4_OR, NO3_OR, PO4_OR, RIN_OR,
									AA.MINDUMP, QQ.RIVER_NAME, QQ.SYS_KIND_NAME, QQ.SYS_KIND
								FROM
								(
							</isEqual>
									SELECT
														FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
														MINTIME, STRDATE, STRTIME,  MINDUMP,
														/* 일반 항목 (내부) */
														TO_CHAR(SUM(TUR), 'FM999,990.00') TUR,
														TO_CHAR(SUM(DECODE(CON2, NULL, CON, CON2)), 'FM999,990.00') CON,
														TO_CHAR(SUM(DECODE(DOW2, NULL, DOW, DOW2)), 'FM999,990.00') DOW,
														TO_CHAR(SUM(DECODE(TMP2, NULL, TMP, TMP2)), 'FM999,990.00') TMP,
														TO_CHAR(SUM(DECODE(PHY2, NULL, PHY, PHY2)), 'FM999,990.00') PHY,
														SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) CON_OR,
														SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) DOW_OR,
														SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) TMP_OR,
														SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) PHY_OR, 
														SUM(TUR_OR) TUR_OR,
														/* 생물독성(물고기) */
														TO_CHAR(SUM(IMP), 'FM999,990.00') IMP,
														SUM(IMP_OR) IMP_OR,
														/* 생물독성(물벼룩1) */
														TO_CHAR(SUM(LIM), 'FM999,990.00') LIM,
														TO_CHAR(SUM(RIM), 'FM999,990.00') RIM,
														SUM(LIM_OR) LIM_OR,
														SUM(RIM_OR) RIM_OR,
														/* 생물독성(물벼룩2) */
														TO_CHAR(SUM(LTX), 'FM999,990.00') LTX,
														TO_CHAR(SUM(RTX), 'FM999,990.00') RTX,
														SUM(LTX_OR) LTX_OR,
														SUM(RTX_OR) RTX_OR,
														/* 생물독성(미생물) */
														TO_CHAR(SUM(TOX), 'FM999,990.00') TOX,
														SUM(TOX_OR) TOX_OR,
														/* 생물독성(조류) */
														TO_CHAR(SUM(EVN), 'FM999,990.00') EVN,
														SUM(EVN_OR) EVN_OR,
														/* 클로로필-a */
														TO_CHAR(SUM(TOF), 'FM999,990.00') TOF,
														SUM(TOF_OR) TOF_OR,
														/* 휘발성 유기화합물 */
														TO_CHAR(SUM(VOC1), 'FM999,990.00') VOC1,
														TO_CHAR(SUM(VOC2), 'FM999,990.00') VOC2,
														TO_CHAR(SUM(VOC3), 'FM999,990.00') VOC3,
														TO_CHAR(SUM(VOC4), 'FM999,990.00') VOC4,
														TO_CHAR(SUM(VOC5), 'FM999,990.00') VOC5,
														TO_CHAR(SUM(VOC6), 'FM999,990.00') VOC6,
														TO_CHAR(SUM(VOC7), 'FM999,990.00') VOC7,
														TO_CHAR(SUM(VOC8), 'FM999,990.00') VOC8,
														TO_CHAR(SUM(VOC9), 'FM999,990.00') VOC9,
														TO_CHAR(SUM(VOC10), 'FM999,990.00') VOC10,
														TO_CHAR(SUM(VOC11), 'FM999,990.00') VOC11,
														TO_CHAR(SUM(VOC12), 'FM999,990.00') VOC12,
														TO_CHAR(SUM(VOC13), 'FM999,990.00') VOC13,
														TO_CHAR(SUM(VOC14), 'FM999,990.00') VOC14,
														TO_CHAR(SUM(VOC15), 'FM999,990.00') VOC15,
														SUM(VOC1_OR) VOC1_OR,
														SUM(VOC2_OR) VOC2_OR,
														SUM(VOC3_OR) VOC3_OR,
														SUM(VOC4_OR) VOC4_OR,
														SUM(VOC5_OR) VOC5_OR,
														SUM(VOC6_OR) VOC6_OR,
														SUM(VOC7_OR) VOC7_OR,
														SUM(VOC8_OR) VOC8_OR,
														SUM(VOC9_OR) VOC9_OR,
														SUM(VOC10_OR) VOC10_OR,
														SUM(VOC11_OR) VOC11_OR,
														SUM(VOC12_OR) VOC12_OR,
														SUM(VOC13_OR) VOC13_OR,
														SUM(VOC14_OR) VOC14_OR,
														SUM(VOC15_OR) VOC15_OR,
														/* 중금속 */
														TO_CHAR(SUM(COP), 'FM999,990.00') COP,
														TO_CHAR(SUM(PLU), 'FM999,990.00') PLU,
														TO_CHAR(SUM(ZIN), 'FM999,990.00') ZIN,
														TO_CHAR(SUM(CAD), 'FM999,990.00') CAD,
														SUM(COP_OR) COP_OR,
														SUM(PLU_OR) PLU_OR,
														SUM(ZIN_OR) ZIN_OR,
														SUM(CAD_OR) CAD_OR,
														/* 페놀 */
														TO_CHAR(SUM(PHE), 'FM999,990.00') PHE,
														TO_CHAR(SUM(PHL), 'FM999,990.00') PHL,
														SUM(PHE_OR) PHE_OR,
														SUM(PHL_OR) PHL_OR,
														/* 유기물질 */
														TO_CHAR(SUM(TOC), 'FM999,990.00') TOC,
														SUM(TOC_OR) TOC_OR,
														/* 영양염류 */
														TO_CHAR(SUM(TON), 'FM999,990.00') TON,
														TO_CHAR(SUM(TOP), 'FM999,990.00') TOP,
														TO_CHAR(SUM(NH4), 'FM999,990.00') NH4,
														TO_CHAR(SUM(NO3), 'FM999,990.00') NO3,
														TO_CHAR(SUM(PO4), 'FM999,990.00') PO4,
														SUM(TON_OR) TON_OR,
														SUM(TOP_OR) TOP_OR,
														SUM(NH4_OR) NH4_OR,
														SUM(NO3_OR) NO3_OR,
														SUM(PO4_OR) PO4_OR,
														/* 강수량계 */
														TO_CHAR(SUM(RIN), 'FM999,990.00') RIN,
														SUM(RIN_OR) RIN_OR,
														MAX(MINST) MINST, '' MINAB, RIVER_DIV,
														RIVER_NAME, SYS_KIND, SYS_KIND_NAME
											  FROM (
													SELECT DISTINCT
															A.ITEM_CODE AS ITEMCODE,
															B.ITEM_NAME AS ITEMNAME,
															A.FACT_CODE AS FACTCODE,
															<isEqual property="sys" compareValue="T">
															AREA.REG_NAME || '(' || NVL(C.FACT_NO,'-') || ')' AS FACTNAME,
															</isEqual>
															<isNotEqual property="sys" compareValue="T">
															AREA.REG_NAME AS FACTNAME,
															</isNotEqual>
															A.BRANCH_NO	AS BRANCHNO,
															<isEqual property="sys" compareValue="A">
															D.BRANCH_NAME BRANCH_NAME,
															</isEqual>
															<isNotEqual property="sys" compareValue="A">
															D.BRANCH_NAME||'-'||A.BRANCH_NO BRANCH_NAME,
															</isNotEqual>
															A.MIN_TIME  AS MINTIME ,
															TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
															TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
															A.MIN_DUMP  AS MINDUMP ,
															/*  일반항목 내부 */
															DECODE(A.ITEM_CODE, 'CON00', MIN_VL) CON,
															DECODE(A.ITEM_CODE, 'DOW00', MIN_VL) DOW,
															DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) TMP,
															DECODE(A.ITEM_CODE, 'PHY00', MIN_VL) PHY,
															DECODE(A.ITEM_CODE, 'CON00', MIN_OR) CON_OR,
															DECODE(A.ITEM_CODE, 'DOW00', MIN_OR) DOW_OR,
															DECODE(A.ITEM_CODE, 'TMP00', MIN_OR)TMP_OR,
															DECODE(A.ITEM_CODE, 'PHY00', MIN_OR) PHY_OR,
															/* 일반 항목 외부 */
															DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) TMP2,
															DECODE(A.ITEM_CODE, 'PHY01', MIN_VL) PHY2,
															DECODE(A.ITEM_CODE, 'DOW01', MIN_VL) DOW2,
															DECODE(A.ITEM_CODE, 'CON01', MIN_VL) CON2,
															DECODE(A.ITEM_CODE, 'TMP01', MIN_OR) TMP2_OR,
															DECODE(A.ITEM_CODE, 'PHY01', MIN_OR) PHY2_OR,
															DECODE(A.ITEM_CODE, 'DOW01', MIN_OR) DOW2_OR,
															DECODE(A.ITEM_CODE, 'CON01', MIN_OR) CON2_OR,
															DECODE(A.ITEM_CODE, 'TUR00', MIN_OR) TUR_OR,
															DECODE(A.ITEM_CODE, 'TUR00', MIN_VL) TUR,
															/* 생물 독성 (물고기)*/
															DECODE(A.ITEM_CODE, 'IMP00', MIN_VL) IMP,
															DECODE(A.ITEM_CODE, 'IMP00', MIN_OR) IMP_OR,
															/* 생물 독성 (물벼룩1) */
															DECODE(A.ITEM_CODE, 'LIM00', MIN_VL) LIM,
															DECODE(A.ITEM_CODE, 'RIM00', MIN_VL) RIM,
															DECODE(A.ITEM_CODE, 'LIM00', MIN_OR) LIM_OR,
															DECODE(A.ITEM_CODE, 'RIM00', MIN_OR) RIM_OR,
															/* 생물 독성 (물벼룩2) */
															DECODE(A.ITEM_CODE, 'LTX00', MIN_VL) LTX,
															DECODE(A.ITEM_CODE, 'RTX00', MIN_VL) RTX,
															DECODE(A.ITEM_CODE, 'LTX00', MIN_OR) LTX_OR,
															DECODE(A.ITEM_CODE, 'RTX00', MIN_OR) RTX_OR,
															/* 생물 독성 (미생물) */
															DECODE(A.ITEM_CODE, 'TOX00', MIN_VL) TOX,
															DECODE(A.ITEM_CODE, 'TOX00', MIN_OR) TOX_OR,
															/* 생물 독성 (조류) */
															DECODE(A.ITEM_CODE, 'EVN00', MIN_VL) EVN,
															DECODE(A.ITEM_CODE, 'EVN00', MIN_OR) EVN_OR,
															/* 클로로필-a */
															DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) TOF,
															DECODE(A.ITEM_CODE, 'TOF00', MIN_OR) TOF_OR,
															/* 휘발성 유기화합물 */
															DECODE(A.ITEM_CODE, 'VOC01', MIN_VL) VOC1,
															DECODE(A.ITEM_CODE, 'VOC02', MIN_VL) VOC2,
															DECODE(A.ITEM_CODE, 'VOC03', MIN_VL) VOC3,
															DECODE(A.ITEM_CODE, 'VOC04', MIN_VL) VOC4,
															DECODE(A.ITEM_CODE, 'VOC05', MIN_VL) VOC5,
															DECODE(A.ITEM_CODE, 'VOC06', MIN_VL) VOC6,
															DECODE(A.ITEM_CODE, 'VOC07', MIN_VL) VOC7,
															DECODE(A.ITEM_CODE, 'VOC08', MIN_VL) VOC8,
															DECODE(A.ITEM_CODE, 'VOC09', MIN_VL) VOC9,
															DECODE(A.ITEM_CODE, 'VOC10', MIN_VL) VOC10,
															DECODE(A.ITEM_CODE, 'VOC11', MIN_VL) VOC11,
															DECODE(A.ITEM_CODE, 'VOC12', MIN_VL) VOC12,
															DECODE(A.ITEM_CODE, 'VOC13', MIN_VL) VOC13,
															DECODE(A.ITEM_CODE, 'VOC14', MIN_VL) VOC14,
															DECODE(A.ITEM_CODE, 'VOC15', MIN_VL) VOC15,
															DECODE(A.ITEM_CODE, 'VOC01', MIN_OR) VOC1_OR,
															DECODE(A.ITEM_CODE, 'VOC02', MIN_OR) VOC2_OR,
															DECODE(A.ITEM_CODE, 'VOC03', MIN_OR) VOC3_OR,
															DECODE(A.ITEM_CODE, 'VOC04', MIN_OR) VOC4_OR,
															DECODE(A.ITEM_CODE, 'VOC05', MIN_OR) VOC5_OR,
															DECODE(A.ITEM_CODE, 'VOC06', MIN_OR) VOC6_OR,
															DECODE(A.ITEM_CODE, 'VOC07', MIN_OR) VOC7_OR,
															DECODE(A.ITEM_CODE, 'VOC08', MIN_OR) VOC8_OR,
															DECODE(A.ITEM_CODE, 'VOC09', MIN_OR) VOC9_OR,
															DECODE(A.ITEM_CODE, 'VOC10', MIN_OR) VOC10_OR,
															DECODE(A.ITEM_CODE, 'VOC11', MIN_OR) VOC11_OR,
															DECODE(A.ITEM_CODE, 'VOC12', MIN_OR) VOC12_OR,
															DECODE(A.ITEM_CODE, 'VOC13', MIN_OR) VOC13_OR,
															DECODE(A.ITEM_CODE, 'VOC14', MIN_OR) VOC14_OR,
															DECODE(A.ITEM_CODE, 'VOC15', MIN_OR) VOC15_OR,
															/* 중금속 */
															DECODE(A.ITEM_CODE, 'COP00', MIN_VL) COP,
															DECODE(A.ITEM_CODE, 'PLU00', MIN_VL) PLU,
															DECODE(A.ITEM_CODE, 'ZIN00', MIN_VL) ZIN,
															DECODE(A.ITEM_CODE, 'CAD00', MIN_VL) CAD,
															DECODE(A.ITEM_CODE, 'COP00', MIN_OR) COP_OR,
															DECODE(A.ITEM_CODE, 'PLU00', MIN_OR) PLU_OR,
															DECODE(A.ITEM_CODE, 'ZIN00', MIN_OR) ZIN_OR,
															DECODE(A.ITEM_CODE, 'CAD00', MIN_OR) CAD_OR,
															/* 페놀 */
															DECODE(A.ITEM_CODE, 'PHE00', MIN_VL) PHE,
															DECODE(A.ITEM_CODE, 'PHL00', MIN_VL) PHL,
															DECODE(A.ITEM_CODE, 'PHE00', MIN_OR) PHE_OR,
															DECODE(A.ITEM_CODE, 'PHL00', MIN_OR) PHL_OR,
															/* 유기물질 */
															DECODE(A.ITEM_CODE, 'TOC00', MIN_VL) TOC,
															DECODE(A.ITEM_CODE, 'TOC00', MIN_OR) TOC_OR,
															/* 영양염류 */
															DECODE(A.ITEM_CODE, 'TON00', MIN_VL) TON,
															DECODE(A.ITEM_CODE, 'TOP00', MIN_VL) TOP,
															DECODE(A.ITEM_CODE, 'NH400', MIN_VL) NH4,
															DECODE(A.ITEM_CODE, 'NO300', MIN_VL) NO3,
															DECODE(A.ITEM_CODE, 'PO400', MIN_VL) PO4,
															DECODE(A.ITEM_CODE, 'TON00', MIN_OR) TON_OR,
															DECODE(A.ITEM_CODE, 'TOP00', MIN_OR) TOP_OR,
															DECODE(A.ITEM_CODE, 'NH400', MIN_OR) NH4_OR,
															DECODE(A.ITEM_CODE, 'NO300', MIN_OR) NO3_OR,
															DECODE(A.ITEM_CODE, 'PO400', MIN_OR) PO4_OR,
															/* 강수량계 */
															DECODE(A.ITEM_CODE, 'RIN00', MIN_VL) RIN,
															DECODE(A.ITEM_CODE, 'RIN00', MIN_OR) RIN_OR,
															A.MIN_ST	AS MINST	,
															''	AS MINAB	,
															C.RIVER_DIV,
															DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
															C.SYS_KIND,
															(
															SELECT SYS_KIND_NAME 
																FROM T_SYS_KIND 
															 WHERE SYS_KIND =  C.SYS_KIND
															) SYS_KIND_NAME
													  FROM T_MIN_DATA A, 
															T_WEATHER_AREA AREA,
															T_ITEM_INFO B, 
															T_FACT_INFO C,
															T_FACT_BRANCH_INFO D,
														<isNotEqual property="sys" compareValue="A">
															T_FACT_MEASU_ITEM I,
														</isNotEqual>
															T_WQA_ITEM M
														<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
														  , T_MEMBER_AUTHORINFO F
													  	</isNotEqual>
													 WHERE A.FACT_CODE = AREA.FACT_CODE(+)
														 <isEqual property="sys" compareValue="U">
															AND A.BRANCH_NO = AREA.BRANCH_NO(+)
														 </isEqual>
															AND A.ITEM_CODE  = B.ITEM_CODE
														  <isNotEqual property="sys" compareValue="A">
															AND I.ITEM_CODE = A.ITEM_CODE
															AND I.FACT_CODE = A.FACT_CODE
															AND I.BRANCH_NO = A.BRANCH_NO
															AND I.ITEM_USE_FLAG = 'Y'
														 </isNotEqual>
															AND A.FACT_CODE  = C.FACT_CODE
															AND C.FACT_CODE = D.FACT_CODE
															AND A.BRANCH_NO = D.BRANCH_NO
															<isNotEqual property="useflag" compareValue="all">
															AND D.BRANCH_USE_FLAG = 'Y'
															AND C.FACT_USE_FLAG  = 'Y'
															</isNotEqual>
															<isNotEqual prepend="AND" property="sugye" compareValue="all">
																C.RIVER_DIV = #sugye#
															</isNotEqual>
															<isNotEqual prepend="AND" property="gongku" compareValue="all">
																A.FACT_CODE = #gongku#
															</isNotEqual>
															<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
																A.BRANCH_NO = #chukjeongso#
															</isNotEqual>
															<isNotEqual prepend="AND" property="sys" compareValue="all">
																C.SYS_KIND  = #sys#
															</isNotEqual>
															<isNotEqual prepend="AND" property="minor" compareValue="all">
																<isEqual property="minor" compareValue="0">
																A.MIN_OR = '0'		 /* 정상인 데이터만 */
																</isEqual>
																<isEqual property="minor" compareValue="1">
																A.MIN_OR != '0'	/* 기준초과인 데이터만 */
																</isEqual>
															</isNotEqual>
															AND M.ITEM_CODE = A.ITEM_CODE
															AND A.ITEM_CODE IN ('TUR00','CON00','DOW00','TMP00','PHY00','TMP01','PHY01','DOW01','CON01','IMP00','LIM00','RIM00','LTX00','RTX00','TOX00','EVN00','TOF00','VOC01','VOC02','VOC03','VOC04',
																								  'VOC05','VOC06','VOC07','VOC08','VOC09','VOC10','VOC11','VOC12','VOC13','VOC14','VOC15','COP00','PLU00','ZIN00','CAD00','PHE00','PHL00','TOC00','TON00','TOP00',
																								  'NH400','NO300','PO400','RIN00')
														<isEqual property="sys" compareValue="A">
															<isNotEqual property="item" compareValue="all">
															<isNotEmpty property="item">
															AND M.ITEM_KIND IN (#item#, DECODE(#item#, 'COM1', 'COM2', 'XXX'))
															</isNotEmpty>
															</isNotEqual>
															<isNotEqual property="valid" compareValue="all">
															AND A.MIN_ST = '00'
															</isNotEqual>
														</isEqual>
															AND A.MIN_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
															<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
																 AND F.MEMBER_ID = #userId#
														         AND A.FACT_CODE = F.FACT_CODE
														         AND A.BRANCH_NO = F.BRANCH_NO
															</isNotEqual>
													  )
											 GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
															MINTIME, STRDATE, STRTIME,  MINDUMP,
															RIVER_DIV,
															RIVER_NAME, SYS_KIND, SYS_KIND_NAME
											 ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
					  <isEqual property="sys" compareValue="U">
								) AA,
								(
										SELECT 
											Q.MIN_TIME, 
											A.FACT_CODE, 
											A.BRANCH_NO, 
											A.FACT_NAME,
											A.BRANCH_NAME,
											A.SYS_KIND,
											A.RIVER_NAME,
											A.SYS_KIND_NAME,
											A.RIVER_DIV
										FROM
										(
										<isEqual property="sys" compareValue="U">
										<![CDATA[
											SELECT
													TO_CHAR(TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI')+(LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
											FROM
											(
												SELECT 
														TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
												FROM DUAL
											  )
											CONNECT BY (LEVEL*10/24/60+(10/24/60)) < DAYCNT
										]]>
										</isEqual>
										<isEqual property="sys" compareValue="T">
										<![CDATA[
											SELECT
													TO_CHAR(TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI')+(LEVEL*30/24/60)-(30/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
											FROM
											(
												SELECT 
														TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI') + (60/24/60) AS DAYCNT
												FROM DUAL
											  )
											CONNECT BY (LEVEL*30/24/60+(30/24/60)) < DAYCNT
										]]>
										</isEqual>
										<isEqual property="sys" compareValue="A">
										<![CDATA[
											SELECT
													TO_CHAR(TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI')+(LEVEL*5/24/60)-(5/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
											FROM
											(
												SELECT 
														TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI') + (10/24/60) AS DAYCNT
												FROM DUAL
											  )
											CONNECT BY (LEVEL*5/24/60+(5/24/60)) < DAYCNT
										]]>
										</isEqual>
										) Q,
										(
											SELECT 
												B.FACT_CODE,
												B.BRANCH_NO,
											  <isEqual property="sys" compareValue="T">
													AREA.REG_NAME || '(' || NVL(F.FACT_NO,'-') || ')' AS FACT_NAME,
												</isEqual>
												<isNotEqual property="sys" compareValue="T">
													AREA.REG_NAME AS FACT_NAME,
												</isNotEqual>
												<isEqual property="sys" compareValue="A">
													B.BRANCH_NAME BRANCH_NAME,
												</isEqual>
												<isNotEqual property="sys" compareValue="A">
													B.BRANCH_NAME||'-'||B.BRANCH_NO BRANCH_NAME,
												</isNotEqual>
												F.RIVER_DIV,
												DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
												F.SYS_KIND,
												(
												SELECT SYS_KIND_NAME 
													FROM T_SYS_KIND 
												 WHERE SYS_KIND =  F.SYS_KIND
												) SYS_KIND_NAME
											FROM
												T_FACT_INFO F,
												T_FACT_BRANCH_INFO B,
												T_WEATHER_AREA AREA
											WHERE
												F.FACT_CODE = B.FACT_CODE
												<isNotEqual property="useflag" compareValue="all">
												AND B.BRANCH_USE_FLAG = 'Y'
												</isNotEqual>
												AND AREA.FACT_CODE(+) = B.FACT_CODE
												
												<isNotEqual prepend="AND" property="sugye" compareValue="all">
													F.RIVER_DIV = #sugye#
												</isNotEqual>
												<isEqual property="sys" compareValue="U">
												AND AREA.BRANCH_NO(+) = B.BRANCH_NO
												</isEqual>
												<isNotEqual prepend="AND" property="gongku" compareValue="all">
													F.FACT_CODE = #gongku#
												</isNotEqual>
												<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
													B.BRANCH_NO = #chukjeongso#
												</isNotEqual>
												<isNotEqual prepend="AND" property="sys" compareValue="all">
													F.SYS_KIND  = #sys#
												</isNotEqual>
										) A
										WHERE
											<![CDATA[TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE ]]>
								) QQ
						WHERE
								AA.MINTIME(+) = QQ.MIN_TIME 
								AND AA.FACTCODE(+) = QQ.FACT_CODE
								AND AA.BRANCHNO(+) = QQ.BRANCH_NO 
				</isEqual>
				)
	</select>
	
	<select id="getTotCntRiver_HOUR"  parameterClass="searchTaksuVO" resultClass="java.lang.Integer" remapResults="true">
			SELECT 
					COUNT(*)
					FROM
					(
					 <isEqual property="sys" compareValue="U">
						 SELECT
							QQ.FACT_CODE FACTCODE, 
							QQ.FACT_NAME FACTNAME, 
							QQ.BRANCH_NO BRANCHNO, 
							QQ.BRANCH_NAME BRANCH_NAME, 
							QQ.MIN_TIME MINTIME,
							QQ.STRDATE,
							QQ.STRTIME,
							TUR, CON, DOW, TMP, PHY, TOF, CON_OR, DOW_OR, TMP_OR, PHY_OR, TUR_OR, TOF_OR,
							AA.MINDUMP, QQ.RIVER_NAME, QQ.SYS_KIND_NAME, QQ.SYS_KIND 
						FROM
						(
					</isEqual>
									SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
												MINTIME, STRDATE, STRTIME,  MINDUMP,
												TO_CHAR(SUM(CON), 'FM999,990.00') CON,
												TO_CHAR(SUM(TUR), 'FM999,990.00') TUR,
												TO_CHAR(SUM(DOW), 'FM999,990.00') DOW,
												TO_CHAR(SUM(TMP), 'FM999,990.00') TMP,
												TO_CHAR(SUM(PHY), 'FM999,990.00') PHY,
												TO_CHAR(SUM(TOF), 'FM999,990.00') TOF,
												SUM(CON_OR) CON_OR,
												SUM(TUR_OR) TUR_OR,
												SUM(DOW_OR) DOW_OR,
												SUM(TMP_OR) TMP_OR,
												SUM(PHY_OR) PHY_OR,
												SUM(TOF_OR) TOF_OR,
												MAX(MINST) MINST, RIVER_DIV,
												RIVER_NAME, SYS_KIND, SYS_KIND_NAME
									  FROM (
											SELECT A.FACT_CODE AS FACTCODE,
													C.FACT_NAME AS FACTNAME,
													A.BRANCH_NO	AS BRANCHNO  ,
													D.BRANCH_NAME||'-'||A.BRANCH_NO BRANCH_NAME,
													A.HOUR_TIME  AS MINTIME ,
													TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
													TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
													A.HOUR_DUMP  AS MINDUMP ,
													DECODE(A.ITEM_CODE, 'CON00', HOUR_VL) CON,
													DECODE(A.ITEM_CODE, 'TUR00', HOUR_VL) TUR,
													DECODE(A.ITEM_CODE, 'DOW00', HOUR_VL) DOW,
													DECODE(A.ITEM_CODE, 'TMP00', HOUR_VL) TMP,
													DECODE(A.ITEM_CODE, 'PHY00', HOUR_VL) PHY,
													DECODE(A.ITEM_CODE, 'TOF00', HOUR_VL) TOF,
													DECODE(A.ITEM_CODE, 'CON00', HOUR_OR) CON_OR,
													DECODE(A.ITEM_CODE, 'TUR00', HOUR_OR) TUR_OR,
													DECODE(A.ITEM_CODE, 'DOW00', HOUR_OR) DOW_OR,
													DECODE(A.ITEM_CODE, 'TMP00', HOUR_OR)TMP_OR,
													DECODE(A.ITEM_CODE, 'PHY00', HOUR_OR) PHY_OR,
													DECODE(A.ITEM_CODE, 'TOF00', HOUR_OR) TOF_OR,
													A.HOUR_ST	AS MINST	,
													C.RIVER_DIV,
													DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
													C.SYS_KIND,
													(
													SELECT SYS_KIND_NAME 
														FROM T_SYS_KIND 
													 WHERE SYS_KIND = C.SYS_KIND
													) SYS_KIND_NAME
											  FROM T_HOUR_DATA A, 
													  T_ITEM_INFO B, 
													  T_FACT_INFO C,
													  T_FACT_BRANCH_INFO D,
													  T_FACT_MEASU_ITEM I
													  <isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
														 , T_MEMBER_AUTHORINFO F
													  </isNotEqual>
											 WHERE A.ITEM_CODE  = B.ITEM_CODE
													 AND I.ITEM_CODE = A.ITEM_CODE
													 AND I.FACT_CODE = A.FACT_CODE
													 AND I.BRANCH_NO = A.BRANCH_NO
													 AND I.ITEM_USE_FLAG = 'Y'
													 AND A.FACT_CODE  = C.FACT_CODE
													 AND C.FACT_CODE = D.FACT_CODE
													 AND A.BRANCH_NO = D.BRANCH_NO
													<isNotEqual property="useflag" compareValue="all">
													 AND D.BRANCH_USE_FLAG = 'Y'
													 AND C.FACT_USE_FLAG  = 'Y'
													 </isNotEqual>
													 AND C.RIVER_DIV = #sugye#
													<isNotEqual prepend="AND" property="gongku" compareValue="all">
														 A.FACT_CODE = #gongku#
													</isNotEqual>
													<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
														 A.BRANCH_NO = #chukjeongso#
													</isNotEqual>
													<isNotEqual prepend="AND" property="sys" compareValue="all">
														 C.SYS_KIND  = #sys#
													</isNotEqual>
													<isNotEqual prepend="AND" property="minor" compareValue="all">
														<isEqual property="minor" compareValue="0">
														 A.HOUR_OR = '0'		 /* 정상인 데이터만 */
														</isEqual>
														<isEqual property="minor" compareValue="1">
														 A.HOUR_OR != '0'	/* 기준초과인 데이터만 */
														</isEqual>
													</isNotEqual>
													AND A.HOUR_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
													<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
														 AND F.MEMBER_ID = #userId#
												         AND A.FACT_CODE = F.FACT_CODE
												         AND A.BRANCH_NO = F.BRANCH_NO
													</isNotEqual>
												)
									 GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
													MINTIME, STRDATE, STRTIME,  MINDUMP,
													RIVER_DIV,
													RIVER_NAME, SYS_KIND, SYS_KIND_NAME	
									 ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
				<isEqual property="sys" compareValue="U">
				) AA,
				 (
									SELECT 
										SUBSTR(Q.MIN_TIME, 0, 10) MIN_TIME,
										TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
										TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
										A.FACT_CODE, 
										A.BRANCH_NO, 
										A.FACT_NAME,
										A.BRANCH_NAME,
										A.SYS_KIND,
										A.RIVER_NAME,
										A.SYS_KIND_NAME,
										A.RIVER_DIV
									FROM
									(
									<![CDATA[
										SELECT
												TO_CHAR(TO_DATE(#frDate#||#frTime#, 'YYYYMMDDHH24MI')+(LEVEL*60/24/60)-(60/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
										FROM
										(
											SELECT 
													TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime#, 'YYYYMMDDHH24MI') + (120/24/60) AS DAYCNT
											FROM DUAL
										  )
										CONNECT BY (LEVEL*60/24/60+(60/24/60)) < DAYCNT
									]]>
									) Q,
									(
										SELECT 
											B.FACT_CODE,
											B.BRANCH_NO,
										  <isEqual property="sys" compareValue="T">
											AREA.REG_NAME || '(' || NVL(F.FACT_NO,'-') || ')' AS FACT_NAME,
											</isEqual>
											<isNotEqual property="sys" compareValue="T">
											AREA.REG_NAME AS FACT_NAME,
											</isNotEqual>
											<isEqual property="sys" compareValue="A">
											B.BRANCH_NAME BRANCH_NAME,
											</isEqual>
											<isNotEqual property="sys" compareValue="A">
											B.BRANCH_NAME||'-'||B.BRANCH_NO BRANCH_NAME,
											</isNotEqual>
											F.RIVER_DIV,
											DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
											F.SYS_KIND,
											(
											SELECT SYS_KIND_NAME 
												FROM T_SYS_KIND 
											 WHERE SYS_KIND =  F.SYS_KIND
											) SYS_KIND_NAME	
										FROM
											T_FACT_INFO F,
											T_FACT_BRANCH_INFO B,
											T_WEATHER_AREA AREA
										WHERE
											F.RIVER_DIV = #sugye#
											AND F.FACT_CODE = B.FACT_CODE
											<isNotEqual property="useflag" compareValue="all">
											AND B.BRANCH_USE_FLAG = 'Y'
											</isNotEqual>
											AND AREA.FACT_CODE(+) = B.FACT_CODE
											<isEqual property="sys" compareValue="U">
											AND AREA.BRANCH_NO(+) = B.BRANCH_NO
											</isEqual>
											<isNotEqual prepend="AND" property="gongku" compareValue="all">
												F.FACT_CODE = #gongku#
											</isNotEqual>
											<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
												B.BRANCH_NO = #chukjeongso#
											</isNotEqual>
											<isNotEqual prepend="AND" property="sys" compareValue="all">
												F.SYS_KIND  = #sys#
											</isNotEqual>
									) A
									WHERE
									<![CDATA[TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE ]]>
							) QQ
					WHERE
								AA.MINTIME(+) = QQ.MIN_TIME 
								AND AA.FACTCODE(+) = QQ.FACT_CODE
								AND AA.BRANCHNO(+) = QQ.BRANCH_NO 	 
					 ORDER BY QQ.MIN_TIME DESC, QQ.FACT_CODE ASC, QQ.BRANCH_NO ASC
			  </isEqual>
			 )
	</select>
	
	
	
	<statement id="getDetailViewRIVER_HOUR_OLD" parameterClass="searchTaksuVO" resultClass="detailViewVO" remapResults="true">
	SELECT 
			* 
			FROM ( 
				SELECT 
					ROWNUM RNUM, T.*
					FROM
					(
					 <isEqual property="sys" compareValue="U">
						 SELECT
								QQ.FACT_CODE FACTCODE, 
								QQ.FACT_NAME FACTNAME, 
								QQ.BRANCH_NO BRANCHNO, 
								QQ.BRANCH_NAME BRANCH_NAME, 
								QQ.MIN_TIME MINTIME,
								QQ.STRDATE,
								QQ.STRTIME,
								TUR, CON, DOW, TMP, PHY, TOF, CON_OR, DOW_OR, TMP_OR, PHY_OR, TUR_OR, TOF_OR,
								AA.MINDUMP, QQ.RIVER_NAME, QQ.SYS_KIND_NAME, QQ.SYS_KIND, QQ.RIVER_DIV 
							FROM
							(
					 </isEqual>
										SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
													MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
													TO_CHAR(SUM(CON), 'FM999,990.00') CON,
													TO_CHAR(SUM(TUR), 'FM999,990.00') TUR,
													TO_CHAR(SUM(DOW), 'FM999,990.00') DOW,
													TO_CHAR(SUM(TMP), 'FM999,990.00') TMP,
													TO_CHAR(SUM(PHY), 'FM999,990.00') PHY,
													TO_CHAR(SUM(TOF), 'FM999,990.00') TOF,
													SUM(CON_OR) CON_OR,
													SUM(TUR_OR) TUR_OR,
													SUM(DOW_OR) DOW_OR,
													SUM(TMP_OR) TMP_OR,
													SUM(PHY_OR) PHY_OR,
													SUM(TOF_OR) TOF_OR,
													MAX(MINST) MINST, RIVER_DIV,
													RIVER_NAME, SYS_KIND, SYS_KIND_NAME
										  FROM (
												SELECT A.FACT_CODE AS FACTCODE,
														C.FACT_NAME AS FACTNAME,
														A.BRANCH_NO	AS BRANCHNO  ,
														D.BRANCH_NAME||'-'||A.BRANCH_NO BRANCH_NAME,
														A.HOUR_TIME  AS MINTIME ,
														TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
														TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
														A.HOUR_RTIME AS MINRTIME,
														A.HOUR_DUMP  AS MINDUMP ,
														DECODE(A.ITEM_CODE, 'CON00', HOUR_VL) CON,
														DECODE(A.ITEM_CODE, 'TUR00', HOUR_VL) TUR,
														DECODE(A.ITEM_CODE, 'DOW00', HOUR_VL) DOW,
														DECODE(A.ITEM_CODE, 'TMP00', HOUR_VL) TMP,
														DECODE(A.ITEM_CODE, 'PHY00', HOUR_VL) PHY,
														DECODE(A.ITEM_CODE, 'TOF00', HOUR_VL) TOF,
														DECODE(A.ITEM_CODE, 'CON00', HOUR_OR) CON_OR,
														DECODE(A.ITEM_CODE, 'TUR00', HOUR_OR) TUR_OR,
														DECODE(A.ITEM_CODE, 'DOW00', HOUR_OR) DOW_OR,
														DECODE(A.ITEM_CODE, 'TMP00', HOUR_OR)TMP_OR,
														DECODE(A.ITEM_CODE, 'PHY00', HOUR_OR) PHY_OR,
														DECODE(A.ITEM_CODE, 'TOF00', HOUR_OR) TOF_OR,
														A.HOUR_ST	AS MINST	,
														C.RIVER_DIV,
														DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
														C.SYS_KIND,
														(
														SELECT SYS_KIND_NAME 
															FROM T_SYS_KIND 
														 WHERE SYS_KIND =  C.SYS_KIND
														) SYS_KIND_NAME
												  FROM T_HOUR_DATA A, 
														  T_ITEM_INFO B, 
														  T_FACT_INFO C,
														  T_FACT_BRANCH_INFO D,
														  T_FACT_MEASU_ITEM I
												 WHERE A.ITEM_CODE  = B.ITEM_CODE
														 AND I.ITEM_CODE = A.ITEM_CODE
														 AND I.FACT_CODE = A.FACT_CODE
														 AND I.BRANCH_NO = A.BRANCH_NO
														 AND I.ITEM_USE_FLAG = 'Y'
														 AND A.FACT_CODE  = C.FACT_CODE
														 AND C.FACT_CODE = D.FACT_CODE
														 AND A.BRANCH_NO = D.BRANCH_NO
														<isNotEqual property="useflag" compareValue="all">
														 AND D.BRANCH_USE_FLAG = 'Y'
														 AND C.FACT_USE_FLAG  = 'Y'
														</isNotEqual>
														 AND C.RIVER_DIV = #sugye#
														<isNotEqual prepend="AND" property="gongku" compareValue="all">
															 A.FACT_CODE = #gongku#
														</isNotEqual>
														<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
															 A.BRANCH_NO = #chukjeongso#
														</isNotEqual>
														<isNotEqual prepend="AND" property="sys" compareValue="all">
															 C.SYS_KIND  = #sys#
														</isNotEqual>
														<isNotEqual prepend="AND" property="minor" compareValue="all">
														<isEqual property="minor" compareValue="0">
															 A.HOUR_OR = '0'		 /* 정상인 데이터만 */
														</isEqual>
														<isEqual property="minor" compareValue="1">
															 A.HOUR_OR != '0'	/* 기준초과인 데이터만 */
														</isEqual>
														</isNotEqual>
														 AND A.HOUR_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
													)
										 GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
														MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
														RIVER_DIV,
														RIVER_NAME, SYS_KIND, SYS_KIND_NAME	
										 ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
					<isEqual property="sys" compareValue="U">
					) AA,
					 (
										SELECT 
											SUBSTR(Q.MIN_TIME, 0, 10) MIN_TIME,
											TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
											TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
											A.FACT_CODE, 
											A.BRANCH_NO, 
											A.FACT_NAME,
											A.BRANCH_NAME,
											A.SYS_KIND,
											A.RIVER_NAME,
											A.SYS_KIND_NAME,
											A.RIVER_DIV
										FROM
										(
										<![CDATA[
											SELECT
													TO_CHAR(TO_DATE(#frDate#||#frTime#, 'YYYYMMDDHH24MI')+(LEVEL*60/24/60)-(60/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
											FROM
											(
												SELECT 
														TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime#, 'YYYYMMDDHH24MI') + (120/24/60) AS DAYCNT
												FROM DUAL
											  )
											CONNECT BY (LEVEL*60/24/60+(60/24/60)) < DAYCNT
										]]>
										) Q,
										(
											SELECT 
												B.FACT_CODE,
												B.BRANCH_NO,
											<isEqual property="sys" compareValue="T">
												AREA.REG_NAME || '(' || NVL(F.FACT_NO,'-') || ')' AS FACT_NAME,
											</isEqual>
											<isNotEqual property="sys" compareValue="T">
												AREA.REG_NAME AS FACT_NAME,
											</isNotEqual>
											<isEqual property="sys" compareValue="A">
												B.BRANCH_NAME BRANCH_NAME,
											</isEqual>
											<isNotEqual property="sys" compareValue="A">
												B.BRANCH_NAME||'-'||B.BRANCH_NO BRANCH_NAME,
											</isNotEqual>
												F.RIVER_DIV,
												DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
												F.SYS_KIND,
												(
												SELECT SYS_KIND_NAME
													FROM T_SYS_KIND
												 WHERE SYS_KIND =  F.SYS_KIND
												) SYS_KIND_NAME
											FROM
												T_FACT_INFO F,
												T_FACT_BRANCH_INFO B,
												T_WEATHER_AREA AREA
											WHERE
												F.RIVER_DIV = #sugye#
												AND F.FACT_CODE = B.FACT_CODE
												<isNotEqual property="useflag" compareValue="all">
												AND B.BRANCH_USE_FLAG = 'Y'
												</isNotEqual>
												AND AREA.FACT_CODE(+) = B.FACT_CODE
												<isEqual property="sys" compareValue="U">
												AND AREA.BRANCH_NO(+) = B.BRANCH_NO
												</isEqual>
												<isNotEqual prepend="AND" property="gongku" compareValue="all">
													F.FACT_CODE = #gongku#
												</isNotEqual>
												<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
													B.BRANCH_NO = #chukjeongso#
												</isNotEqual>
												<isNotEqual prepend="AND" property="sys" compareValue="all">
													F.SYS_KIND  = #sys#
												</isNotEqual>
										) A
										WHERE
										<![CDATA[TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE ]]>
								) QQ
						WHERE
							AA.MINTIME(+) = QQ.MIN_TIME 
							AND AA.FACTCODE(+) = QQ.FACT_CODE
							AND AA.BRANCHNO(+) = QQ.BRANCH_NO
						 ORDER BY QQ.MIN_TIME $orderType1$, QQ.FACT_CODE ASC, QQ.BRANCH_NO ASC
				 </isEqual>
				) T
			)
			WHERE
			<![CDATA[  
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>
	</statement>
	
		<statement id="getDetailViewRIVER_HOUR" parameterClass="searchTaksuVO" resultClass="detailViewVO" remapResults="true">
	SELECT
			*
			FROM (
				SELECT
					ROWNUM RNUM, T.*
					FROM
					(
					<isEqual property="sys" compareValue="U">
						SELECT
								QQ.FACT_CODE FACTCODE,
								QQ.FACT_NAME FACTNAME,
								QQ.BRANCH_NO BRANCHNO,
								QQ.BRANCH_NAME BRANCH_NAME,
								QQ.MIN_TIME MINTIME,
								QQ.STRDATE,
								QQ.STRTIME,
								TUR, CON, DOW, TMP, PHY, TOF, CON_OR, DOW_OR, TMP_OR, PHY_OR, TUR_OR, TOF_OR,
								AA.MINDUMP, QQ.RIVER_NAME, QQ.SYS_KIND_NAME, QQ.SYS_KIND, QQ.RIVER_DIV
						FROM
							(
					</isEqual>
						SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
									MINTIME, STRDATE, STRTIME,  MINDUMP,
									TO_CHAR(SUM(CON), 'FM999,990.000') CON,
									TO_CHAR(SUM(TUR), 'FM999,990.00') TUR,
									TO_CHAR(SUM(DOW), 'FM999,990.00') DOW,
									TO_CHAR(SUM(TMP), 'FM999,990.00') TMP,
									TO_CHAR(SUM(PHY), 'FM999,990.00') PHY,
									TO_CHAR(SUM(TOF), 'FM999,990.00') TOF,
									SUM(CON_OR) CON_OR,
									SUM(TUR_OR) TUR_OR,
									SUM(DOW_OR) DOW_OR,
									SUM(TMP_OR) TMP_OR,
									SUM(PHY_OR) PHY_OR,
									SUM(TOF_OR) TOF_OR,
									MAX(MINST) MINST, RIVER_DIV,
									RIVER_NAME, SYS_KIND, SYS_KIND_NAME
							FROM (
									SELECT A.FACT_CODE AS FACTCODE,
										C.FACT_NAME AS FACTNAME,
										A.BRANCH_NO AS BRANCHNO,
										D.BRANCH_NAME||'-'||A.BRANCH_NO BRANCH_NAME,
										A.HOUR_TIME AS MINTIME ,
										TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
										TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
										A.HOUR_DUMP  AS MINDUMP ,
										DECODE(A.ITEM_CODE, 'CON00', HOUR_VL) CON,
										DECODE(A.ITEM_CODE, 'TUR00', HOUR_VL) TUR,
										DECODE(A.ITEM_CODE, 'DOW00', HOUR_VL) DOW,
										DECODE(A.ITEM_CODE, 'TMP00', HOUR_VL) TMP,
										DECODE(A.ITEM_CODE, 'PHY00', HOUR_VL) PHY,
										DECODE(A.ITEM_CODE, 'TOF00', HOUR_VL) TOF,
										DECODE(A.ITEM_CODE, 'CON00', HOUR_OR) CON_OR,
										DECODE(A.ITEM_CODE, 'TUR00', HOUR_OR) TUR_OR,
										DECODE(A.ITEM_CODE, 'DOW00', HOUR_OR) DOW_OR,
										DECODE(A.ITEM_CODE, 'TMP00', HOUR_OR)TMP_OR,
										DECODE(A.ITEM_CODE, 'PHY00', HOUR_OR) PHY_OR,
										DECODE(A.ITEM_CODE, 'TOF00', HOUR_OR) TOF_OR,
										A.HOUR_ST AS MINST,
										C.RIVER_DIV,
										DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
										C.SYS_KIND,
										(
										SELECT SYS_KIND_NAME 
											FROM T_SYS_KIND 
										 WHERE SYS_KIND =  C.SYS_KIND
										) SYS_KIND_NAME
									FROM T_HOUR_DATA A, 
										  T_ITEM_INFO B, 
										  T_FACT_INFO C,
										  T_FACT_BRANCH_INFO D,
										  T_FACT_MEASU_ITEM I
										  <isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
											 , T_MEMBER_AUTHORINFO F
										  </isNotEqual>
									WHERE A.ITEM_CODE  = B.ITEM_CODE
										 AND I.ITEM_CODE = A.ITEM_CODE
										 AND I.FACT_CODE = A.FACT_CODE
										 AND I.BRANCH_NO = A.BRANCH_NO
										 AND I.ITEM_USE_FLAG = 'Y'
										 AND A.FACT_CODE  = C.FACT_CODE
										 AND C.FACT_CODE = D.FACT_CODE
										 AND A.BRANCH_NO = D.BRANCH_NO
										<isNotEqual property="useflag" compareValue="all">
										 AND D.BRANCH_USE_FLAG = 'Y'
										 AND C.FACT_USE_FLAG  = 'Y'
										</isNotEqual>
										 AND C.RIVER_DIV = #sugye#
										<isNotEqual prepend="AND" property="gongku" compareValue="all">
											 A.FACT_CODE = #gongku#
										</isNotEqual>
										<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
											 A.BRANCH_NO = #chukjeongso#
										</isNotEqual>
										<isNotEqual prepend="AND" property="sys" compareValue="all">
											 C.SYS_KIND  = #sys#
										</isNotEqual>
										<isNotEqual prepend="AND" property="minor" compareValue="all">
										<isEqual property="minor" compareValue="0">
											 A.HOUR_OR = '0'	/* 정상인 데이터만 */
										</isEqual>
										<isEqual property="minor" compareValue="1">
											 A.HOUR_OR != '0'	/* 기준초과인 데이터만 */
										</isEqual>
										</isNotEqual>
										 AND A.HOUR_TIME BETWEEN SUBSTR(#frDate#||#frTime#, 0, 10) AND SUBSTR(#toDate#||#toTime#, 0, 10)
										 <isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
											 AND F.MEMBER_ID = #userId#
									         AND A.FACT_CODE = F.FACT_CODE
									         AND A.BRANCH_NO = F.BRANCH_NO
										 </isNotEqual>
									)
						GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
										MINTIME, STRDATE, STRTIME, MINDUMP,
										RIVER_DIV,
										RIVER_NAME, SYS_KIND, SYS_KIND_NAME
						ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
					<isEqual property="sys" compareValue="U">
					) AA,
					 (
										SELECT
											SUBSTR(Q.MIN_TIME, 0, 10) MIN_TIME,
											TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
											TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
											A.FACT_CODE, 
											A.BRANCH_NO, 
											A.FACT_NAME,
											A.BRANCH_NAME,
											A.SYS_KIND,
											A.RIVER_NAME,
											A.SYS_KIND_NAME,
											A.RIVER_DIV
										FROM
										(
										<![CDATA[
											SELECT
													TO_CHAR(TO_DATE(#frDate#||#frTime#, 'YYYYMMDDHH24MI')+(LEVEL*60/24/60)-(60/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
											FROM
											(
												SELECT 
														TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime#, 'YYYYMMDDHH24MI') + (120/24/60) AS DAYCNT
												FROM DUAL
											)
											CONNECT BY (LEVEL*60/24/60+(60/24/60)) < DAYCNT
										]]>
										) Q,
										(
											SELECT 
												B.FACT_CODE,
												B.BRANCH_NO,
											<isEqual property="sys" compareValue="T">
												AREA.REG_NAME || '(' || NVL(F.FACT_NO,'-') || ')' AS FACT_NAME,
											</isEqual>
											<isNotEqual property="sys" compareValue="T">
												AREA.REG_NAME AS FACT_NAME,
											</isNotEqual>
											<isEqual property="sys" compareValue="A">
												B.BRANCH_NAME BRANCH_NAME,
											</isEqual>
											<isNotEqual property="sys" compareValue="A">
												B.BRANCH_NAME||'-'||B.BRANCH_NO BRANCH_NAME,
											</isNotEqual>
												F.RIVER_DIV,
												DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
												F.SYS_KIND,
												(
												SELECT SYS_KIND_NAME
													FROM T_SYS_KIND
												 WHERE SYS_KIND = F.SYS_KIND
												) SYS_KIND_NAME
											FROM
												T_FACT_INFO F,
												T_FACT_BRANCH_INFO B,
												T_WEATHER_AREA AREA
											WHERE
												F.RIVER_DIV = #sugye#
												AND F.FACT_CODE = B.FACT_CODE
												<isNotEqual property="useflag" compareValue="all">
												AND B.BRANCH_USE_FLAG = 'Y'
												</isNotEqual>
												AND AREA.FACT_CODE(+) = B.FACT_CODE
												<isEqual property="sys" compareValue="U">
												AND AREA.BRANCH_NO(+) = B.BRANCH_NO
												</isEqual>
												<isNotEqual prepend="AND" property="gongku" compareValue="all">
													F.FACT_CODE = #gongku#
												</isNotEqual>
												<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
													B.BRANCH_NO = #chukjeongso#
												</isNotEqual>
												<isNotEqual prepend="AND" property="sys" compareValue="all">
													F.SYS_KIND  = #sys#
												</isNotEqual>
										) A
										WHERE
										<![CDATA[TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE ]]>
								) QQ
						WHERE
							AA.MINTIME(+) = QQ.MIN_TIME 
							AND AA.FACTCODE(+) = QQ.FACT_CODE
							AND AA.BRANCHNO(+) = QQ.BRANCH_NO 
						 ORDER BY QQ.MIN_TIME $orderType1$, QQ.FACT_CODE ASC, QQ.BRANCH_NO ASC
				 </isEqual>
				) T
			)
			WHERE
			<![CDATA[  
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>
	</statement>
	
	<statement id="getDetailViewRIVER_MIN_OLD" parameterClass="searchTaksuVO" resultClass="detailViewVO" remapResults="true">
		SELECT 
			 * 
			 FROM ( 
						 SELECT 
							 ROWNUM RNUM, T.*
							FROM
							(
							<isEqual property="sys" compareValue="U">
								SELECT
									QQ.FACT_CODE FACTCODE, 
									QQ.FACT_NAME FACTNAME, 
									QQ.BRANCH_NO BRANCHNO, 
									QQ.BRANCH_NAME BRANCH_NAME, 
									QQ.MIN_TIME MINTIME,
									QQ.STRDATE,
									QQ.STRTIME,
									TUR, CON, DOW, TMP, PHY, CON_OR, DOW_OR, TMP_OR, PHY_OR, TUR_OR,
									IMP, LIM, RIM, LIM_OR, RIM_OR, LTX, RTX, LTX_OR, RTX_OR, TOX, TOX_OR, EVN, EVN_OR, TOF, TOF_OR, 
									VOC1, VOC2, VOC3, VOC4, VOC5, VOC6, VOC7, VOC8, VOC9, VOC10, VOC11, VOC12, VOC13, VOC14, VOC15,
									VOC1_OR, VOC2_OR, VOC3_OR, VOC4_OR, VOC5_OR, VOC6_OR, VOC7_OR, VOC8_OR, VOC9_OR, VOC10_OR, VOC11_OR, VOC12_OR, VOC13_OR, VOC14_OR, VOC15_OR,
									COP, PLU, ZIN, CAD, PHE, PHL, TOC, TON, TOP, NH4, NO3, PO4, RIN
									COP_OR, PLU_OR, ZIN_OR, CAD_OR, PHE_OR, PHL_OR, TOC_OR, TON_OR, TOP_OR, NH4_OR, NO3_OR, PO4_OR, RIN_OR,
									AA.MINDUMP, QQ.RIVER_NAME, QQ.SYS_KIND_NAME, QQ.SYS_KIND, QQ.RIVER_DIV
								FROM
								(
							</isEqual>
										SELECT
															FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
															MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
															/* 일반 항목 (내부) */			  
															TO_CHAR(SUM(TUR), 'FM999,990.00') TUR,
															TO_CHAR(SUM(DECODE(CON2, NULL, CON, CON2)), 'FM999,990.00') CON,
															TO_CHAR(SUM(DECODE(DOW2, NULL, DOW, DOW2)), 'FM999,990.00') DOW,
															TO_CHAR(SUM(DECODE(TMP2, NULL, TMP, TMP2)), 'FM999,990.00') TMP,
															TO_CHAR(SUM(DECODE(PHY2, NULL, PHY, PHY2)), 'FM999,990.00') PHY,
															SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) CON_OR,
															SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) DOW_OR,
															SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) TMP_OR,
															SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) PHY_OR, 
															SUM(TUR_OR) TUR_OR,
															/* 생물독성(물고기) */
															TO_CHAR(SUM(IMP), 'FM999,990.00') IMP,
															SUM(IMP_OR) IMP_OR,
															/* 생물독성(물벼룩1) */
															TO_CHAR(SUM(LIM), 'FM999,990.00') LIM,
															TO_CHAR(SUM(RIM), 'FM999,990.00') RIM,
															SUM(LIM_OR) LIM_OR,
															SUM(RIM_OR) RIM_OR,
															/* 생물독성(물벼룩2) */
															TO_CHAR(SUM(LTX), 'FM999,990.00') LTX,
															TO_CHAR(SUM(RTX), 'FM999,990.00') RTX,
															SUM(LTX_OR) LTX_OR,
															SUM(RTX_OR) RTX_OR,
															/* 생물독성(미생물) */
															TO_CHAR(SUM(TOX), 'FM999,990.00') TOX,
															SUM(TOX_OR) TOX_OR,
															/* 생물독성(조류) */
															TO_CHAR(SUM(EVN), 'FM999,990.00') EVN,
															SUM(EVN_OR) EVN_OR,
															/* 클로로필-a */
															TO_CHAR(SUM(TOF), 'FM999,990.00') TOF,
															SUM(TOF_OR) TOF_OR,
															/* 휘발성 유기화합물 */
															TO_CHAR(SUM(VOC1), 'FM999,990.00') VOC1,
															TO_CHAR(SUM(VOC2), 'FM999,990.00') VOC2,
															TO_CHAR(SUM(VOC3), 'FM999,990.00') VOC3,
															TO_CHAR(SUM(VOC4), 'FM999,990.00') VOC4,
															TO_CHAR(SUM(VOC5), 'FM999,990.00') VOC5,
															TO_CHAR(SUM(VOC6), 'FM999,990.00') VOC6,
															TO_CHAR(SUM(VOC7), 'FM999,990.00') VOC7,
															TO_CHAR(SUM(VOC8), 'FM999,990.00') VOC8,
															TO_CHAR(SUM(VOC9), 'FM999,990.00') VOC9,
															TO_CHAR(SUM(VOC10), 'FM999,990.00') VOC10,
															TO_CHAR(SUM(VOC11), 'FM999,990.00') VOC11,
															TO_CHAR(SUM(VOC12), 'FM999,990.00') VOC12,
															TO_CHAR(SUM(VOC13), 'FM999,990.00') VOC13,
															TO_CHAR(SUM(VOC14), 'FM999,990.00') VOC14,
															TO_CHAR(SUM(VOC15), 'FM999,990.00') VOC15,
															SUM(VOC1_OR) VOC1_OR,
															SUM(VOC2_OR) VOC2_OR,
															SUM(VOC3_OR) VOC3_OR,
															SUM(VOC4_OR) VOC4_OR,
															SUM(VOC5_OR) VOC5_OR,
															SUM(VOC6_OR) VOC6_OR,
															SUM(VOC7_OR) VOC7_OR,
															SUM(VOC8_OR) VOC8_OR,
															SUM(VOC9_OR) VOC9_OR,
															SUM(VOC10_OR) VOC10_OR,
															SUM(VOC11_OR) VOC11_OR,
															SUM(VOC12_OR) VOC12_OR,
															SUM(VOC13_OR) VOC13_OR,
															SUM(VOC14_OR) VOC14_OR,
															SUM(VOC15_OR) VOC15_OR,
															/* 중금속 */
															TO_CHAR(SUM(COP), 'FM999,990.00') COP,
															TO_CHAR(SUM(PLU), 'FM999,990.00') PLU,
															TO_CHAR(SUM(ZIN), 'FM999,990.00') ZIN,
															TO_CHAR(SUM(CAD), 'FM999,990.00') CAD,
															SUM(COP_OR) COP_OR,
															SUM(PLU_OR) PLU_OR,
															SUM(ZIN_OR) ZIN_OR,
															SUM(CAD_OR) CAD_OR,
															/* 페놀 */
															TO_CHAR(SUM(PHE), 'FM999,990.00') PHE,
															TO_CHAR(SUM(PHL), 'FM999,990.00') PHL,
															SUM(PHE_OR) PHE_OR,
															SUM(PHL_OR) PHL_OR,
															/* 유기물질 */
															TO_CHAR(SUM(TOC), 'FM999,990.00') TOC,
															SUM(TOC_OR) TOC_OR,
															/* 영양염류 */
															TO_CHAR(SUM(TON), 'FM999,990.00') TON,
															TO_CHAR(SUM(TOP), 'FM999,990.00') TOP,
															TO_CHAR(SUM(NH4), 'FM999,990.00') NH4,
															TO_CHAR(SUM(NO3), 'FM999,990.00') NO3,
															TO_CHAR(SUM(PO4), 'FM999,990.00') PO4,
															SUM(TON_OR) TON_OR,
															SUM(TOP_OR) TOP_OR,
															SUM(NH4_OR) NH4_OR,
															SUM(NO3_OR) NO3_OR,
															SUM(PO4_OR) PO4_OR,
															/* 강수량계 */
															TO_CHAR(SUM(RIN), 'FM999,990.00') RIN,
															SUM(RIN_OR) RIN_OR,
															MAX(MINST) MINST, '' MINAB, RIVER_DIV,
															RIVER_NAME, SYS_KIND, SYS_KIND_NAME
												FROM (				
														SELECT DISTINCT
																A.ITEM_CODE AS ITEMCODE,
																B.ITEM_NAME AS ITEMNAME,
																A.FACT_CODE AS FACTCODE,
																<isEqual property="sys" compareValue="T">
																AREA.REG_NAME || '(' || NVL(C.FACT_NO,'-') || ')' AS FACTNAME,
																</isEqual>
																<isNotEqual property="sys" compareValue="T">
																AREA.REG_NAME AS FACTNAME,
																</isNotEqual>
																A.BRANCH_NO AS BRANCHNO,
																<isEqual property="sys" compareValue="A">
																D.BRANCH_NAME BRANCH_NAME,
																</isEqual>
																<isNotEqual property="sys" compareValue="A">
																D.BRANCH_NAME||'-'||A.BRANCH_NO BRANCH_NAME,
																</isNotEqual>
																A.MIN_TIME  AS MINTIME ,
																TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
																TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
																A.MIN_RTIME AS MINRTIME,
																A.MIN_DUMP  AS MINDUMP ,
																/*  일반항목 내부 */
																DECODE(A.ITEM_CODE, 'CON00', MIN_VL) CON,
																DECODE(A.ITEM_CODE, 'DOW00', MIN_VL) DOW,
																DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) TMP,
																DECODE(A.ITEM_CODE, 'PHY00', MIN_VL) PHY,
																DECODE(A.ITEM_CODE, 'CON00', MIN_OR) CON_OR,
																DECODE(A.ITEM_CODE, 'DOW00', MIN_OR) DOW_OR,
																DECODE(A.ITEM_CODE, 'TMP00', MIN_OR)TMP_OR,
																DECODE(A.ITEM_CODE, 'PHY00', MIN_OR) PHY_OR,
																/* 일반 항목 외부 */
																DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) TMP2,
																DECODE(A.ITEM_CODE, 'PHY01', MIN_VL) PHY2,
																DECODE(A.ITEM_CODE, 'DOW01', MIN_VL) DOW2,
																DECODE(A.ITEM_CODE, 'CON01', MIN_VL) CON2,
																DECODE(A.ITEM_CODE, 'TMP01', MIN_OR) TMP2_OR,
																DECODE(A.ITEM_CODE, 'PHY01', MIN_OR) PHY2_OR,
																DECODE(A.ITEM_CODE, 'DOW01', MIN_OR) DOW2_OR,
																DECODE(A.ITEM_CODE, 'CON01', MIN_OR) CON2_OR,
																DECODE(A.ITEM_CODE, 'TUR00', MIN_OR) TUR_OR,
																DECODE(A.ITEM_CODE, 'TUR00', MIN_VL) TUR,
																/* 생물 독성 (물고기)*/
																DECODE(A.ITEM_CODE, 'IMP00', MIN_VL) IMP,
																DECODE(A.ITEM_CODE, 'IMP00', MIN_OR) IMP_OR,
																/* 생물 독성 (물벼룩1) */
																DECODE(A.ITEM_CODE, 'LIM00', MIN_VL) LIM,
																DECODE(A.ITEM_CODE, 'RIM00', MIN_VL) RIM,
																DECODE(A.ITEM_CODE, 'LIM00', MIN_OR) LIM_OR,
																DECODE(A.ITEM_CODE, 'RIM00', MIN_OR) RIM_OR,
																/* 생물 독성 (물벼룩2) */
																DECODE(A.ITEM_CODE, 'LTX00', MIN_VL) LTX,
																DECODE(A.ITEM_CODE, 'RTX00', MIN_VL) RTX,
																DECODE(A.ITEM_CODE, 'LTX00', MIN_OR) LTX_OR,
																DECODE(A.ITEM_CODE, 'RTX00', MIN_OR) RTX_OR,
																/* 생물 독성 (미생물) */
																DECODE(A.ITEM_CODE, 'TOX00', MIN_VL) TOX,
																DECODE(A.ITEM_CODE, 'TOX00', MIN_OR) TOX_OR,
																/* 생물 독성 (조류) */
																DECODE(A.ITEM_CODE, 'EVN00', MIN_VL) EVN,
																DECODE(A.ITEM_CODE, 'EVN00', MIN_OR) EVN_OR,
																/* 클로로필-a */
																DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) TOF,
																DECODE(A.ITEM_CODE, 'TOF00', MIN_OR) TOF_OR,
																/* 휘발성 유기화합물 */
																DECODE(A.ITEM_CODE, 'VOC01', MIN_VL) VOC1,
																DECODE(A.ITEM_CODE, 'VOC02', MIN_VL) VOC2,
																DECODE(A.ITEM_CODE, 'VOC03', MIN_VL) VOC3,
																DECODE(A.ITEM_CODE, 'VOC04', MIN_VL) VOC4,
																DECODE(A.ITEM_CODE, 'VOC05', MIN_VL) VOC5,
																DECODE(A.ITEM_CODE, 'VOC06', MIN_VL) VOC6,
																DECODE(A.ITEM_CODE, 'VOC07', MIN_VL) VOC7,
																DECODE(A.ITEM_CODE, 'VOC08', MIN_VL) VOC8,
																DECODE(A.ITEM_CODE, 'VOC09', MIN_VL) VOC9,
																DECODE(A.ITEM_CODE, 'VOC10', MIN_VL) VOC10,
																DECODE(A.ITEM_CODE, 'VOC11', MIN_VL) VOC11,
																DECODE(A.ITEM_CODE, 'VOC12', MIN_VL) VOC12,
																DECODE(A.ITEM_CODE, 'VOC13', MIN_VL) VOC13,
																DECODE(A.ITEM_CODE, 'VOC14', MIN_VL) VOC14,
																DECODE(A.ITEM_CODE, 'VOC15', MIN_VL) VOC15,
																DECODE(A.ITEM_CODE, 'VOC01', MIN_OR) VOC1_OR,
																DECODE(A.ITEM_CODE, 'VOC02', MIN_OR) VOC2_OR,
																DECODE(A.ITEM_CODE, 'VOC03', MIN_OR) VOC3_OR,
																DECODE(A.ITEM_CODE, 'VOC04', MIN_OR) VOC4_OR,
																DECODE(A.ITEM_CODE, 'VOC05', MIN_OR) VOC5_OR,
																DECODE(A.ITEM_CODE, 'VOC06', MIN_OR) VOC6_OR,
																DECODE(A.ITEM_CODE, 'VOC07', MIN_OR) VOC7_OR,
																DECODE(A.ITEM_CODE, 'VOC08', MIN_OR) VOC8_OR,
																DECODE(A.ITEM_CODE, 'VOC09', MIN_OR) VOC9_OR,
																DECODE(A.ITEM_CODE, 'VOC10', MIN_OR) VOC10_OR,
																DECODE(A.ITEM_CODE, 'VOC11', MIN_OR) VOC11_OR,
																DECODE(A.ITEM_CODE, 'VOC12', MIN_OR) VOC12_OR,
																DECODE(A.ITEM_CODE, 'VOC13', MIN_OR) VOC13_OR,
																DECODE(A.ITEM_CODE, 'VOC14', MIN_OR) VOC14_OR,
																DECODE(A.ITEM_CODE, 'VOC15', MIN_OR) VOC15_OR,
																/* 중금속 */
																DECODE(A.ITEM_CODE, 'COP00', MIN_VL) COP,
																DECODE(A.ITEM_CODE, 'PLU00', MIN_VL) PLU,
																DECODE(A.ITEM_CODE, 'ZIN00', MIN_VL) ZIN,
																DECODE(A.ITEM_CODE, 'CAD00', MIN_VL) CAD,
																DECODE(A.ITEM_CODE, 'COP00', MIN_OR) COP_OR,
																DECODE(A.ITEM_CODE, 'PLU00', MIN_OR) PLU_OR,
																DECODE(A.ITEM_CODE, 'ZIN00', MIN_OR) ZIN_OR,
																DECODE(A.ITEM_CODE, 'CAD00', MIN_OR) CAD_OR,
																/* 페놀 */
																DECODE(A.ITEM_CODE, 'PHE00', MIN_VL) PHE,
																DECODE(A.ITEM_CODE, 'PHL00', MIN_VL) PHL,
																DECODE(A.ITEM_CODE, 'PHE00', MIN_OR) PHE_OR,
																DECODE(A.ITEM_CODE, 'PHL00', MIN_OR) PHL_OR,
																/* 유기물질 */
																DECODE(A.ITEM_CODE, 'TOC00', MIN_VL) TOC,
																DECODE(A.ITEM_CODE, 'TOC00', MIN_OR) TOC_OR,
																/* 영양염류 */
																DECODE(A.ITEM_CODE, 'TON00', MIN_VL) TON,
																DECODE(A.ITEM_CODE, 'TOP00', MIN_VL) TOP,
																DECODE(A.ITEM_CODE, 'NH400', MIN_VL) NH4,
																DECODE(A.ITEM_CODE, 'NO300', MIN_VL) NO3,
																DECODE(A.ITEM_CODE, 'PO400', MIN_VL) PO4,
																DECODE(A.ITEM_CODE, 'TON00', MIN_OR) TON_OR,
																DECODE(A.ITEM_CODE, 'TOP00', MIN_OR) TOP_OR,
																DECODE(A.ITEM_CODE, 'NH400', MIN_OR) NH4_OR,
																DECODE(A.ITEM_CODE, 'NO300', MIN_OR) NO3_OR,
																DECODE(A.ITEM_CODE, 'PO400', MIN_OR) PO4_OR,
																/* 강수량계 */
																DECODE(A.ITEM_CODE, 'RIN00', MIN_VL) RIN,
																DECODE(A.ITEM_CODE, 'RIN00', MIN_OR) RIN_OR,
																A.MIN_ST	AS MINST	,
																''	AS MINAB	,
																C.RIVER_DIV,
																DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
																C.SYS_KIND,
																(
																SELECT SYS_KIND_NAME 
																	FROM T_SYS_KIND 
																 WHERE SYS_KIND =  C.SYS_KIND
																) SYS_KIND_NAME
														FROM T_MIN_DATA A, 
																T_WEATHER_AREA AREA,
																T_ITEM_INFO B, 
																T_FACT_INFO C,
																T_FACT_BRANCH_INFO D,
															<isNotEqual property="sys" compareValue="A">
																T_FACT_MEASU_ITEM I,
															</isNotEqual>
																T_WQA_ITEM M
														WHERE 
																A.FACT_CODE = AREA.FACT_CODE(+)
															<isEqual property="sys" compareValue="U">
																AND A.BRANCH_NO = AREA.BRANCH_NO(+)
															</isEqual>
																AND A.ITEM_CODE  = B.ITEM_CODE
															<isNotEqual property="sys" compareValue="A">
																AND I.ITEM_CODE = A.ITEM_CODE
																AND I.FACT_CODE = A.FACT_CODE
																AND I.BRANCH_NO = A.BRANCH_NO
																AND I.ITEM_USE_FLAG = 'Y'
															</isNotEqual>
																AND A.FACT_CODE  = C.FACT_CODE
																AND C.FACT_CODE = D.FACT_CODE
																AND A.BRANCH_NO = D.BRANCH_NO
															<isNotEqual property="useflag" compareValue="all">
																AND D.BRANCH_USE_FLAG = 'Y'
																AND C.FACT_USE_FLAG  = 'Y'
															</isNotEqual>
															<isNotEqual prepend="AND" property="sugye" compareValue="all">
																	C.RIVER_DIV = #sugye#
															</isNotEqual>
																
															<isNotEqual prepend="AND" property="gongku" compareValue="all">
																	A.FACT_CODE = #gongku#
															</isNotEqual>
															<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
																	A.BRANCH_NO = #chukjeongso#
															</isNotEqual>
															<isNotEqual prepend="AND" property="sys" compareValue="all">
																	C.SYS_KIND  = #sys#
															</isNotEqual>
															<isNotEqual prepend="AND" property="minor" compareValue="all">
																<isEqual property="minor" compareValue="0">
																	A.MIN_OR = '0'		 /* 정상인 데이터만 */
																</isEqual>
																<isEqual property="minor" compareValue="1">
																	A.MIN_OR != '0'	/* 기준초과인 데이터만 */
																</isEqual>
															</isNotEqual>
																AND M.ITEM_CODE = A.ITEM_CODE
															<isEqual property="sys" compareValue="A">
																<isNotEqual property="item" compareValue="all">
																AND M.ITEM_KIND IN (#item#, DECODE(#item#, 'COM1', 'COM2', 'XXX'))
																</isNotEqual>			
																<isNotEqual property="valid" compareValue="all">
																AND A.MIN_ST = '00'
																</isNotEqual>
															</isEqual>
															<isEqual property="lastFlag" compareValue="X">
																AND A.MIN_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
															</isEqual>
															<isEqual property="lastFlag" compareValue="O">
																AND (A.MIN_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
																	AND A.MIN_TIME = 
																		(SELECT 
																				/*+INDEX_DESC(CC IX_MIN_DATA_05 )*/  min_time
																		FROM T_MIN_DATA cc 
																		WHERE CC.FACT_CODE = A.FACT_CODE
																		AND CC.BRANCH_NO= A.BRANCH_NO
																		AND ROWNUM =1 
																		))
															</isEqual>
														)
												GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
																MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
																RIVER_DIV,
																RIVER_NAME, SYS_KIND, SYS_KIND_NAME
												ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
						 <isEqual property="sys" compareValue="U">
									) AA,
									(
											SELECT 
												Q.MIN_TIME, 
												TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
												TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
												A.FACT_CODE, 
												A.BRANCH_NO, 
												A.FACT_NAME,
												A.BRANCH_NAME,
												A.SYS_KIND,
												A.RIVER_NAME,
												A.SYS_KIND_NAME,
												A.RIVER_DIV
											FROM
											(
											<isEqual property="sys" compareValue="U">
											<![CDATA[
												SELECT
														TO_CHAR(TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI')+(LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
												FROM
												(
													SELECT 
															TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
													FROM DUAL
												  )
												CONNECT BY (LEVEL*10/24/60+(10/24/60)) < DAYCNT
											]]>
											</isEqual>
											<isEqual property="sys" compareValue="T">
											<![CDATA[
												SELECT
														TO_CHAR(TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI')+(LEVEL*30/24/60)-(30/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
												FROM
												(
													SELECT 
															TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI') + (60/24/60) AS DAYCNT
													FROM DUAL
												)
												CONNECT BY (LEVEL*30/24/60+(30/24/60)) < DAYCNT
											]]>
											</isEqual>
											<isEqual property="sys" compareValue="A">
											<![CDATA[
												SELECT
														TO_CHAR(TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI')+(LEVEL*5/24/60)-(5/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
												FROM
												(
													SELECT 
															TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI') + (10/24/60) AS DAYCNT
													FROM DUAL
												)
												CONNECT BY (LEVEL*5/24/60+(5/24/60)) < DAYCNT
											]]>
											</isEqual>
											) Q,
											(
												SELECT 
													B.FACT_CODE,
													B.BRANCH_NO,
												  <isEqual property="sys" compareValue="T">
													AREA.REG_NAME || '(' || NVL(F.FACT_NO,'-') || ')' AS FACT_NAME,
													</isEqual>
													<isNotEqual property="sys" compareValue="T">
													AREA.REG_NAME AS FACT_NAME,
													</isNotEqual>
													<isEqual property="sys" compareValue="A">
													B.BRANCH_NAME BRANCH_NAME,
													</isEqual>
													<isNotEqual property="sys" compareValue="A">
													B.BRANCH_NAME||'-'||B.BRANCH_NO BRANCH_NAME,
													</isNotEqual>
													F.RIVER_DIV,
													DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
													F.SYS_KIND,
													(
													SELECT SYS_KIND_NAME 
														FROM T_SYS_KIND 
													 WHERE SYS_KIND =  F.SYS_KIND
													) SYS_KIND_NAME	
												FROM
													T_FACT_INFO F,
													T_FACT_BRANCH_INFO B,
													T_WEATHER_AREA AREA
												WHERE
													F.FACT_CODE = B.FACT_CODE
													<isNotEqual property="useflag" compareValue="all">
													AND B.BRANCH_USE_FLAG = 'Y'
													</isNotEqual>
													AND AREA.FACT_CODE(+) = B.FACT_CODE
													
													<isNotEqual prepend="AND" property="sugye" compareValue="all">
														F.RIVER_DIV = #sugye#
													</isNotEqual>
													
													<isEqual property="sys" compareValue="U">
													AND AREA.BRANCH_NO(+) = B.BRANCH_NO
													</isEqual>
													<isNotEqual prepend="AND" property="gongku" compareValue="all">
														F.FACT_CODE = #gongku#
													</isNotEqual>
													<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
														B.BRANCH_NO = #chukjeongso#
													</isNotEqual>
													<isNotEqual prepend="AND" property="sys" compareValue="all">
														F.SYS_KIND  = #sys#
													</isNotEqual>
											) A
											WHERE
											<![CDATA[TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE ]]>
									) QQ
							WHERE
								AA.MINTIME(+) = QQ.MIN_TIME 
								AND AA.FACTCODE(+) = QQ.FACT_CODE
								AND AA.BRANCHNO(+) = QQ.BRANCH_NO 
							ORDER BY QQ.MIN_TIME $orderType1$, QQ.FACT_CODE ASC, QQ.BRANCH_NO ASC
					</isEqual>
					) T
			)
			WHERE
			<![CDATA[
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>
	</statement>
	
	<statement id="getDetailViewRIVER_MIN" parameterClass="searchTaksuVO" resultClass="detailViewVO" remapResults="true">
		SELECT
			*
			FROM (
						SELECT 
							ROWNUM RNUM, T.*
						FROM
							(
							<isEqual property="sys" compareValue="U">
								SELECT
									QQ.FACT_CODE FACTCODE,
									QQ.FACT_NAME FACTNAME,
									QQ.BRANCH_NO BRANCHNO,
									QQ.BRANCH_NAME BRANCH_NAME,
									QQ.MIN_TIME MINTIME,
									QQ.STRDATE,
									QQ.STRTIME,
									TUR, CON, DOW, TMP, PHY, CON_OR, DOW_OR, TMP_OR, PHY_OR, TUR_OR,
									IMP, LIM, RIM, LIM_OR, RIM_OR, LTX, RTX, LTX_OR, RTX_OR, TOX, TOX_OR, EVN, EVN_OR, TOF, TOF_OR,
									VOC1, VOC2, VOC3, VOC4, VOC5, VOC6, VOC7, VOC8, VOC9, VOC10, VOC11, VOC12, VOC13, VOC14, VOC15,
									VOC1_OR, VOC2_OR, VOC3_OR, VOC4_OR, VOC5_OR, VOC6_OR, VOC7_OR, VOC8_OR, VOC9_OR, VOC10_OR, VOC11_OR, VOC12_OR, VOC13_OR, VOC14_OR, VOC15_OR,
									COP, PLU, ZIN, CAD, PHE, PHL, TOC, TON, TOP, NH4, NO3, PO4, RIN
									COP_OR, PLU_OR, ZIN_OR, CAD_OR, PHE_OR, PHL_OR, TOC_OR, TON_OR, TOP_OR, NH4_OR, NO3_OR, PO4_OR, RIN_OR,
									AA.MINDUMP, QQ.RIVER_NAME, QQ.SYS_KIND_NAME, QQ.SYS_KIND, QQ.RIVER_DIV
								FROM
								(
							</isEqual>
										SELECT
															FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
															MINTIME, STRDATE, STRTIME,  MINDUMP,
															/* 일반 항목 (내부) */
															/* TO_CHAR(SUM(TUR), 'FM999,990.00') TUR, */
															TO_CHAR(SUM(TUR), RPAD('FM999,990.', 10+(SELECT VALUE_FORMAT FROM T_ITEM_INFO_ADD WHERE ITEM_CODE = 'TUR00'), '0') ) TUR, 
															/* TO_CHAR(SUM(DECODE(CON2, NULL, CON, CON2)), 'FM999,990.000') CON, */
															TO_CHAR(SUM(DECODE(CON2, NULL, CON, CON2)), RPAD('FM999,990.', 10+(SELECT VALUE_FORMAT FROM T_ITEM_INFO_ADD WHERE ITEM_CODE = 'CON00'), '0')) CON, 
															/* TO_CHAR(SUM(DECODE(DOW2, NULL, DOW, DOW2)), 'FM999,990.00') DOW, */
															TO_CHAR(SUM(DECODE(DOW2, NULL, DOW, DOW2)), RPAD('FM999,990.', 10+(SELECT VALUE_FORMAT FROM T_ITEM_INFO_ADD WHERE ITEM_CODE = 'DOW00'), '0')) DOW, 
															/* TO_CHAR(SUM(DECODE(TMP2, NULL, TMP, TMP2)), 'FM999,990.00') TMP, */
															TO_CHAR(SUM(DECODE(TMP2, NULL, TMP, TMP2)), RPAD('FM999,990.', 10+(SELECT VALUE_FORMAT FROM T_ITEM_INFO_ADD WHERE ITEM_CODE = 'TMP00'), '0')) TMP, 
															/* TO_CHAR(SUM(DECODE(PHY2, NULL, PHY, PHY2)), 'FM999,990.00') PHY, */
															TO_CHAR(SUM(DECODE(PHY2, NULL, PHY, PHY2)), RPAD('FM999,990.', 10+(SELECT VALUE_FORMAT FROM T_ITEM_INFO_ADD WHERE ITEM_CODE = 'PHY00'), '0')) PHY, 
															SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) CON_OR,
															SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) DOW_OR,
															SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) TMP_OR,
															SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) PHY_OR,
															SUM(TUR_OR) TUR_OR,
															/* 생물독성(물고기) */
															TO_CHAR(SUM(IMP), 'FM999,990.00') IMP,
															SUM(IMP_OR) IMP_OR,
															/* 생물독성(물벼룩1) */
															TO_CHAR(SUM(LIM), 'FM999,990.00') LIM,
															TO_CHAR(SUM(RIM), 'FM999,990.00') RIM,
															SUM(LIM_OR) LIM_OR,
															SUM(RIM_OR) RIM_OR,
															/* 생물독성(물벼룩2) */
															TO_CHAR(SUM(LTX), 'FM999,990.00') LTX,
															TO_CHAR(SUM(RTX), 'FM999,990.00') RTX,
															SUM(LTX_OR) LTX_OR,
															SUM(RTX_OR) RTX_OR,
															/* 생물독성(미생물) */
															TO_CHAR(SUM(TOX), 'FM999,990.00') TOX,
															SUM(TOX_OR) TOX_OR,
															/* 생물독성(조류) */
															TO_CHAR(SUM(EVN), 'FM999,990.00') EVN,
															SUM(EVN_OR) EVN_OR,
															/* 클로로필-a */
															/* TO_CHAR(SUM(TOF), 'FM999,990.00') TOF, */
															TO_CHAR(SUM(TOF), RPAD('FM999,990.', 10+(SELECT VALUE_FORMAT FROM T_ITEM_INFO_ADD WHERE ITEM_CODE = 'TOF00'), '0')) TOF,
															SUM(TOF_OR) TOF_OR,
															/* 휘발성 유기화합물 */
															TO_CHAR(SUM(VOC1), 'FM999,990.00') VOC1,
															TO_CHAR(SUM(VOC2), 'FM999,990.00') VOC2,
															TO_CHAR(SUM(VOC3), 'FM999,990.00') VOC3,
															TO_CHAR(SUM(VOC4), 'FM999,990.00') VOC4,
															TO_CHAR(SUM(VOC5), 'FM999,990.00') VOC5,
															TO_CHAR(SUM(VOC6), 'FM999,990.00') VOC6,
															TO_CHAR(SUM(VOC7), 'FM999,990.00') VOC7,
															TO_CHAR(SUM(VOC8), 'FM999,990.00') VOC8,
															TO_CHAR(SUM(VOC9), 'FM999,990.00') VOC9,
															TO_CHAR(SUM(VOC10), 'FM999,990.00') VOC10,
															TO_CHAR(SUM(VOC11), 'FM999,990.00') VOC11,
															TO_CHAR(SUM(VOC12), 'FM999,990.00') VOC12,
															TO_CHAR(SUM(VOC13), 'FM999,990.00') VOC13,
															TO_CHAR(SUM(VOC14), 'FM999,990.00') VOC14,
															TO_CHAR(SUM(VOC15), 'FM999,990.00') VOC15,
															SUM(VOC1_OR) VOC1_OR,
															SUM(VOC2_OR) VOC2_OR,
															SUM(VOC3_OR) VOC3_OR,
															SUM(VOC4_OR) VOC4_OR,
															SUM(VOC5_OR) VOC5_OR,
															SUM(VOC6_OR) VOC6_OR,
															SUM(VOC7_OR) VOC7_OR,
															SUM(VOC8_OR) VOC8_OR,
															SUM(VOC9_OR) VOC9_OR,
															SUM(VOC10_OR) VOC10_OR,
															SUM(VOC11_OR) VOC11_OR,
															SUM(VOC12_OR) VOC12_OR,
															SUM(VOC13_OR) VOC13_OR,
															SUM(VOC14_OR) VOC14_OR,
															SUM(VOC15_OR) VOC15_OR,
															/* 중금속 */
															TO_CHAR(SUM(COP), 'FM999,990.00') COP,
															TO_CHAR(SUM(PLU), 'FM999,990.00') PLU,
															TO_CHAR(SUM(ZIN), 'FM999,990.00') ZIN,
															TO_CHAR(SUM(CAD), 'FM999,990.00') CAD,
															SUM(COP_OR) COP_OR,
															SUM(PLU_OR) PLU_OR,
															SUM(ZIN_OR) ZIN_OR,
															SUM(CAD_OR) CAD_OR,
															/* 페놀 */
															TO_CHAR(SUM(PHE), 'FM999,990.00') PHE,
															TO_CHAR(SUM(PHL), 'FM999,990.00') PHL,
															SUM(PHE_OR) PHE_OR,
															SUM(PHL_OR) PHL_OR,
															/* 유기물질 */
															TO_CHAR(SUM(TOC), 'FM999,990.00') TOC,
															SUM(TOC_OR) TOC_OR,
															/* 영양염류 */
															TO_CHAR(SUM(TON), 'FM999,990.00') TON,
															TO_CHAR(SUM(TOP), 'FM999,990.00') TOP,
															TO_CHAR(SUM(NH4), 'FM999,990.00') NH4,
															TO_CHAR(SUM(NO3), 'FM999,990.00') NO3,
															TO_CHAR(SUM(PO4), 'FM999,990.00') PO4,
															SUM(TON_OR) TON_OR,
															SUM(TOP_OR) TOP_OR,
															SUM(NH4_OR) NH4_OR,
															SUM(NO3_OR) NO3_OR,
															SUM(PO4_OR) PO4_OR,
															/* 강수량계 */
															TO_CHAR(SUM(RIN), 'FM999,990.00') RIN,
															SUM(RIN_OR) RIN_OR,
															MAX(MINST) MINST, '' MINAB, RIVER_DIV,
															RIVER_NAME, SYS_KIND, SYS_KIND_NAME
												FROM (
														SELECT DISTINCT
																A.ITEM_CODE AS ITEMCODE,
																B.ITEM_NAME AS ITEMNAME,
																A.FACT_CODE AS FACTCODE,
																<isEqual property="sys" compareValue="T">
																AREA.REG_NAME || '(' || NVL(C.FACT_NO,'-') || ')' AS FACTNAME,
																</isEqual>
																<isNotEqual property="sys" compareValue="T">
																AREA.REG_NAME AS FACTNAME,
																</isNotEqual>
																A.BRANCH_NO AS BRANCHNO,
																<isEqual property="sys" compareValue="A">
																D.BRANCH_NAME BRANCH_NAME,
																</isEqual>
																<isNotEqual property="sys" compareValue="A">
																D.BRANCH_NAME||'-'||A.BRANCH_NO BRANCH_NAME,
																</isNotEqual>
																A.MIN_TIME  AS MINTIME ,
																TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
																TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
																
																A.MIN_DUMP  AS MINDUMP ,
																/*  일반항목 내부 */
																DECODE(A.ITEM_CODE, 'CON00', MIN_VL) CON,
																DECODE(A.ITEM_CODE, 'DOW00', MIN_VL) DOW,
																DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) TMP,
																DECODE(A.ITEM_CODE, 'PHY00', MIN_VL) PHY,
																DECODE(A.ITEM_CODE, 'CON00', MIN_OR) CON_OR,
																DECODE(A.ITEM_CODE, 'DOW00', MIN_OR) DOW_OR,
																DECODE(A.ITEM_CODE, 'TMP00', MIN_OR)TMP_OR,
																DECODE(A.ITEM_CODE, 'PHY00', MIN_OR) PHY_OR,
																/* 일반 항목 외부 */
																DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) TMP2,
																DECODE(A.ITEM_CODE, 'PHY01', MIN_VL) PHY2,
																DECODE(A.ITEM_CODE, 'DOW01', MIN_VL) DOW2,
																DECODE(A.ITEM_CODE, 'CON01', MIN_VL) CON2,
																DECODE(A.ITEM_CODE, 'TMP01', MIN_OR) TMP2_OR,
																DECODE(A.ITEM_CODE, 'PHY01', MIN_OR) PHY2_OR,
																DECODE(A.ITEM_CODE, 'DOW01', MIN_OR) DOW2_OR,
																DECODE(A.ITEM_CODE, 'CON01', MIN_OR) CON2_OR,
																DECODE(A.ITEM_CODE, 'TUR00', MIN_OR) TUR_OR,
																DECODE(A.ITEM_CODE, 'TUR00', MIN_VL) TUR,
																/* 생물 독성 (물고기)*/
																DECODE(A.ITEM_CODE, 'IMP00', MIN_VL) IMP,
																DECODE(A.ITEM_CODE, 'IMP00', MIN_OR) IMP_OR,
																/* 생물 독성 (물벼룩1) */
																DECODE(A.ITEM_CODE, 'LIM00', MIN_VL) LIM,
																DECODE(A.ITEM_CODE, 'RIM00', MIN_VL) RIM,
																DECODE(A.ITEM_CODE, 'LIM00', MIN_OR) LIM_OR,
																DECODE(A.ITEM_CODE, 'RIM00', MIN_OR) RIM_OR,
																/* 생물 독성 (물벼룩2) */
																DECODE(A.ITEM_CODE, 'LTX00', MIN_VL) LTX,
																DECODE(A.ITEM_CODE, 'RTX00', MIN_VL) RTX,
																DECODE(A.ITEM_CODE, 'LTX00', MIN_OR) LTX_OR,
																DECODE(A.ITEM_CODE, 'RTX00', MIN_OR) RTX_OR,
																/* 생물 독성 (미생물) */
																DECODE(A.ITEM_CODE, 'TOX00', MIN_VL) TOX,
																DECODE(A.ITEM_CODE, 'TOX00', MIN_OR) TOX_OR,
																/* 생물 독성 (조류) */
																DECODE(A.ITEM_CODE, 'EVN00', MIN_VL) EVN,
																DECODE(A.ITEM_CODE, 'EVN00', MIN_OR) EVN_OR,
																/* 클로로필-a */
																DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) TOF,
																DECODE(A.ITEM_CODE, 'TOF00', MIN_OR) TOF_OR,
																/* 휘발성 유기화합물 */
																DECODE(A.ITEM_CODE, 'VOC01', MIN_VL) VOC1,
																DECODE(A.ITEM_CODE, 'VOC02', MIN_VL) VOC2,
																DECODE(A.ITEM_CODE, 'VOC03', MIN_VL) VOC3,
																DECODE(A.ITEM_CODE, 'VOC04', MIN_VL) VOC4,
																DECODE(A.ITEM_CODE, 'VOC05', MIN_VL) VOC5,
																DECODE(A.ITEM_CODE, 'VOC06', MIN_VL) VOC6,
																DECODE(A.ITEM_CODE, 'VOC07', MIN_VL) VOC7,
																DECODE(A.ITEM_CODE, 'VOC08', MIN_VL) VOC8,
																DECODE(A.ITEM_CODE, 'VOC09', MIN_VL) VOC9,
																DECODE(A.ITEM_CODE, 'VOC10', MIN_VL) VOC10,
																DECODE(A.ITEM_CODE, 'VOC11', MIN_VL) VOC11,
																DECODE(A.ITEM_CODE, 'VOC12', MIN_VL) VOC12,
																DECODE(A.ITEM_CODE, 'VOC13', MIN_VL) VOC13,
																DECODE(A.ITEM_CODE, 'VOC14', MIN_VL) VOC14,
																DECODE(A.ITEM_CODE, 'VOC15', MIN_VL) VOC15,
																DECODE(A.ITEM_CODE, 'VOC01', MIN_OR) VOC1_OR,
																DECODE(A.ITEM_CODE, 'VOC02', MIN_OR) VOC2_OR,
																DECODE(A.ITEM_CODE, 'VOC03', MIN_OR) VOC3_OR,
																DECODE(A.ITEM_CODE, 'VOC04', MIN_OR) VOC4_OR,
																DECODE(A.ITEM_CODE, 'VOC05', MIN_OR) VOC5_OR,
																DECODE(A.ITEM_CODE, 'VOC06', MIN_OR) VOC6_OR,
																DECODE(A.ITEM_CODE, 'VOC07', MIN_OR) VOC7_OR,
																DECODE(A.ITEM_CODE, 'VOC08', MIN_OR) VOC8_OR,
																DECODE(A.ITEM_CODE, 'VOC09', MIN_OR) VOC9_OR,
																DECODE(A.ITEM_CODE, 'VOC10', MIN_OR) VOC10_OR,
																DECODE(A.ITEM_CODE, 'VOC11', MIN_OR) VOC11_OR,
																DECODE(A.ITEM_CODE, 'VOC12', MIN_OR) VOC12_OR,
																DECODE(A.ITEM_CODE, 'VOC13', MIN_OR) VOC13_OR,
																DECODE(A.ITEM_CODE, 'VOC14', MIN_OR) VOC14_OR,
																DECODE(A.ITEM_CODE, 'VOC15', MIN_OR) VOC15_OR,
																/* 중금속 */
																DECODE(A.ITEM_CODE, 'COP00', MIN_VL) COP,
																DECODE(A.ITEM_CODE, 'PLU00', MIN_VL) PLU,
																DECODE(A.ITEM_CODE, 'ZIN00', MIN_VL) ZIN,
																DECODE(A.ITEM_CODE, 'CAD00', MIN_VL) CAD,
																DECODE(A.ITEM_CODE, 'COP00', MIN_OR) COP_OR,
																DECODE(A.ITEM_CODE, 'PLU00', MIN_OR) PLU_OR,
																DECODE(A.ITEM_CODE, 'ZIN00', MIN_OR) ZIN_OR,
																DECODE(A.ITEM_CODE, 'CAD00', MIN_OR) CAD_OR,
																/* 페놀 */
																DECODE(A.ITEM_CODE, 'PHE00', MIN_VL) PHE,
																DECODE(A.ITEM_CODE, 'PHL00', MIN_VL) PHL,
																DECODE(A.ITEM_CODE, 'PHE00', MIN_OR) PHE_OR,
																DECODE(A.ITEM_CODE, 'PHL00', MIN_OR) PHL_OR,
																/* 유기물질 */
																DECODE(A.ITEM_CODE, 'TOC00', MIN_VL) TOC,
																DECODE(A.ITEM_CODE, 'TOC00', MIN_OR) TOC_OR,
																/* 영양염류 */
																DECODE(A.ITEM_CODE, 'TON00', MIN_VL) TON,
																DECODE(A.ITEM_CODE, 'TOP00', MIN_VL) TOP,
																DECODE(A.ITEM_CODE, 'NH400', MIN_VL) NH4,
																DECODE(A.ITEM_CODE, 'NO300', MIN_VL) NO3,
																DECODE(A.ITEM_CODE, 'PO400', MIN_VL) PO4,
																DECODE(A.ITEM_CODE, 'TON00', MIN_OR) TON_OR,
																DECODE(A.ITEM_CODE, 'TOP00', MIN_OR) TOP_OR,
																DECODE(A.ITEM_CODE, 'NH400', MIN_OR) NH4_OR,
																DECODE(A.ITEM_CODE, 'NO300', MIN_OR) NO3_OR,
																DECODE(A.ITEM_CODE, 'PO400', MIN_OR) PO4_OR,
																/* 강수량계 */
																DECODE(A.ITEM_CODE, 'RIN00', MIN_VL) RIN,
																DECODE(A.ITEM_CODE, 'RIN00', MIN_OR) RIN_OR,
																A.MIN_ST	AS MINST	,
																''	AS MINAB	,
																C.RIVER_DIV,
																DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
																C.SYS_KIND,
																(
																SELECT SYS_KIND_NAME 
																	FROM T_SYS_KIND 
																WHERE SYS_KIND =  C.SYS_KIND
																) SYS_KIND_NAME
														FROM T_MIN_DATA A, 
																T_WEATHER_AREA AREA,
																T_ITEM_INFO B, 
																T_FACT_INFO C,
																T_FACT_BRANCH_INFO D,
															<isNotEqual property="sys" compareValue="A">
																T_FACT_MEASU_ITEM I,
															</isNotEqual>
																T_WQA_ITEM M
																<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
																 , T_MEMBER_AUTHORINFO F
															   </isNotEqual>
														WHERE A.FACT_CODE = AREA.FACT_CODE(+)
															<isEqual property="sys" compareValue="U">
																AND A.BRANCH_NO = AREA.BRANCH_NO(+)
															</isEqual>
																AND A.ITEM_CODE  = B.ITEM_CODE
															<isNotEqual property="sys" compareValue="A">
																AND I.ITEM_CODE = A.ITEM_CODE
																AND I.FACT_CODE = A.FACT_CODE
																AND I.BRANCH_NO = A.BRANCH_NO
																AND I.ITEM_USE_FLAG = 'Y'
															</isNotEqual>
																AND A.FACT_CODE  = C.FACT_CODE
																AND C.FACT_CODE = D.FACT_CODE
																AND A.BRANCH_NO = D.BRANCH_NO
															<isNotEqual property="useflag" compareValue="all">
																AND D.BRANCH_USE_FLAG = 'Y'
																AND C.FACT_USE_FLAG  = 'Y'
															</isNotEqual>
															<isNotEqual prepend="AND" property="sugye" compareValue="all">
																	C.RIVER_DIV = #sugye#
															</isNotEqual>
																
															<isNotEqual prepend="AND" property="gongku" compareValue="all">
																	A.FACT_CODE = #gongku#
															</isNotEqual>
															<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
																	A.BRANCH_NO = #chukjeongso#
															</isNotEqual>
															<isNotEqual prepend="AND" property="sys" compareValue="all">
																	C.SYS_KIND  = #sys#
															</isNotEqual>
															<isNotEqual prepend="AND" property="minor" compareValue="all">
																<isEqual property="minor" compareValue="0">
																	A.MIN_OR = '0'		 /* 정상인 데이터만 */
																</isEqual>
																<isEqual property="minor" compareValue="1">
																	A.MIN_OR != '0'	/* 기준초과인 데이터만 */
																</isEqual>
															</isNotEqual>
																AND M.ITEM_CODE = A.ITEM_CODE
																AND A.ITEM_CODE IN ('TUR00','CON00','DOW00','TMP00','PHY00','TMP01','PHY01','DOW01','CON01','IMP00','LIM00','RIM00','LTX00','RTX00','TOX00','EVN00','TOF00','VOC01','VOC02','VOC03','VOC04',
																								  'VOC05','VOC06','VOC07','VOC08','VOC09','VOC10','VOC11','VOC12','VOC13','VOC14','VOC15','COP00','PLU00','ZIN00','CAD00','PHE00','PHL00','TOC00','TON00','TOP00',
																								  'NH400','NO300','PO400','RIN00')
															<isEqual property="sys" compareValue="A">
																<isNotEqual property="item" compareValue="all">
																<isNotEmpty property="item">
																AND M.ITEM_KIND IN (#item#, DECODE(#item#, 'COM1', 'COM2', 'XXX'))
																</isNotEmpty>
																</isNotEqual>			
																<isNotEqual property="valid" compareValue="all">
																AND A.MIN_ST = '00'
																</isNotEqual>
															</isEqual>
															<isEqual property="lastFlag" compareValue="X">
																AND A.MIN_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
															</isEqual>
															<isEqual property="lastFlag" compareValue="O">
																AND (A.MIN_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
																	AND A.MIN_TIME = 
																		(SELECT 
																				/*+INDEX_DESC(CC IX_MIN_DATA_05 )*/  min_time
																		FROM T_MIN_DATA cc 
																		WHERE CC.FACT_CODE = A.FACT_CODE
																		AND CC.MIN_DCD = 0
																		AND CC.BRANCH_NO= A.BRANCH_NO
																		AND ROWNUM =1 
																		))
															</isEqual>
															<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
																 AND F.MEMBER_ID = #userId#
														         AND A.FACT_CODE = F.FACT_CODE
														         AND A.BRANCH_NO = F.BRANCH_NO
															</isNotEqual>
														)
												GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
																MINTIME, STRDATE, STRTIME,  MINDUMP,
																RIVER_DIV,
																RIVER_NAME, SYS_KIND, SYS_KIND_NAME
												ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
						 <isEqual property="sys" compareValue="U">
									) AA,
									(
											SELECT 
												Q.MIN_TIME, 
												TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
												TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
												A.FACT_CODE, 
												A.BRANCH_NO, 
												A.FACT_NAME,
												A.BRANCH_NAME,
												A.SYS_KIND,
												A.RIVER_NAME,
												A.SYS_KIND_NAME,
												A.RIVER_DIV
											FROM
											(
											<isEqual property="sys" compareValue="U">
											<![CDATA[
												SELECT
														TO_CHAR(TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI')+(LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
												FROM
												(
													SELECT 
															TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
													FROM DUAL
												)
												CONNECT BY (LEVEL*10/24/60+(10/24/60)) < DAYCNT
											]]>
											</isEqual>
											<isEqual property="sys" compareValue="T">
											<![CDATA[
												SELECT
														TO_CHAR(TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI')+(LEVEL*30/24/60)-(30/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
												FROM
												(
													SELECT 
															TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI') + (60/24/60) AS DAYCNT
													FROM DUAL
												)
												CONNECT BY (LEVEL*30/24/60+(30/24/60)) < DAYCNT
											]]>
											</isEqual>
											<isEqual property="sys" compareValue="A">
											<![CDATA[
												SELECT
														TO_CHAR(TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI')+(LEVEL*5/24/60)-(5/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
												FROM
												(
													SELECT 
															TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime# , 'YYYYMMDDHH24MI') + (10/24/60) AS DAYCNT
													FROM DUAL
												)
												CONNECT BY (LEVEL*5/24/60+(5/24/60)) < DAYCNT
											]]>
											</isEqual>
											) Q,
											(
												SELECT 
													B.FACT_CODE,
													B.BRANCH_NO,
												<isEqual property="sys" compareValue="T">
													AREA.REG_NAME || '(' || NVL(F.FACT_NO,'-') || ')' AS FACT_NAME,
													</isEqual>
													<isNotEqual property="sys" compareValue="T">
													AREA.REG_NAME AS FACT_NAME,
													</isNotEqual>
													<isEqual property="sys" compareValue="A">
													B.BRANCH_NAME BRANCH_NAME,
													</isEqual>
													<isNotEqual property="sys" compareValue="A">
													B.BRANCH_NAME||'-'||B.BRANCH_NO BRANCH_NAME,
													</isNotEqual>
													F.RIVER_DIV,
													DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
													F.SYS_KIND,
													(
													SELECT SYS_KIND_NAME 
														FROM T_SYS_KIND 
													 WHERE SYS_KIND =  F.SYS_KIND
													) SYS_KIND_NAME	
												FROM
													T_FACT_INFO F,
													T_FACT_BRANCH_INFO B,
													T_WEATHER_AREA AREA
												WHERE
													F.FACT_CODE = B.FACT_CODE
													<isNotEqual property="useflag" compareValue="all">
													AND B.BRANCH_USE_FLAG = 'Y'
													</isNotEqual>
													AND AREA.FACT_CODE(+) = B.FACT_CODE
													
													<isNotEqual prepend="AND" property="sugye" compareValue="all">
														F.RIVER_DIV = #sugye#
													</isNotEqual>
													
													<isEqual property="sys" compareValue="U">
													AND AREA.BRANCH_NO(+) = B.BRANCH_NO
													</isEqual>
													<isNotEqual prepend="AND" property="gongku" compareValue="all">
														F.FACT_CODE = #gongku#
													</isNotEqual>
													<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
														B.BRANCH_NO = #chukjeongso#
													</isNotEqual>
													<isNotEqual prepend="AND" property="sys" compareValue="all">
														F.SYS_KIND  = #sys#
													</isNotEqual>
											) A
											WHERE
											<![CDATA[TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE ]]>
									) QQ
							WHERE
								AA.MINTIME(+) = QQ.MIN_TIME 
								AND AA.FACTCODE(+) = QQ.FACT_CODE
								AND AA.BRANCHNO(+) = QQ.BRANCH_NO 
							ORDER BY QQ.MIN_TIME $orderType1$, QQ.FACT_CODE ASC, QQ.BRANCH_NO ASC
					</isEqual>
					) T
			)
			WHERE
			<![CDATA[
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>
	</statement>
	
	<statement id="getRiverGraph_HOUR" parameterClass="searchTaksuVO" resultClass="detailViewVO" remapResults="true">
			<isEqual property="sys" compareValue="U">
				SELECT
						QQ.FACT_CODE FACTCODE, 
						QQ.FACT_NAME FACTNAME, 
						QQ.BRANCH_NO BRANCHNO, 
						QQ.BRANCH_NAME BRANCH_NAME, 
						QQ.MIN_TIME MINTIME,
						QQ.STRDATE,
						QQ.STRTIME,
						TUR, CON, DOW, TMP, PHY, TOF, CON_OR, DOW_OR, TMP_OR, PHY_OR, TUR_OR, TOF_OR,
						AA.MINDUMP, QQ.RIVER_NAME, QQ.SYS_KIND_NAME, QQ.SYS_KIND, QQ.RIVER_DIV
					FROM
					(
			 </isEqual>
								SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
											MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
											TO_CHAR(SUM(CON), 'FM999,990.000') CON,
											TO_CHAR(SUM(TUR), 'FM999,990.00') TUR,
											TO_CHAR(SUM(DOW), 'FM999,990.00') DOW,
											TO_CHAR(SUM(TMP), 'FM999,990.00') TMP,
											TO_CHAR(SUM(PHY), 'FM999,990.00') PHY,
											TO_CHAR(SUM(TOF), 'FM999,990.00') TOF,
											SUM(CON_OR) CON_OR,
											SUM(TUR_OR) TUR_OR,
											SUM(DOW_OR) DOW_OR,
											SUM(TMP_OR) TMP_OR,
											SUM(PHY_OR) PHY_OR,
											SUM(TOF_OR) TOF_OR,
											MAX(MINST) MINST, RIVER_DIV,
											RIVER_NAME, SYS_KIND, SYS_KIND_NAME
								  FROM (
										SELECT A.FACT_CODE AS FACTCODE,
												C.FACT_NAME AS FACTNAME,
												A.BRANCH_NO AS BRANCHNO,
												D.BRANCH_NAME||'-'||A.BRANCH_NO BRANCH_NAME,
												A.HOUR_TIME AS MINTIME ,
												TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
												TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
												A.HOUR_RTIME AS MINRTIME,
												A.HOUR_DUMP AS MINDUMP ,
												DECODE(A.ITEM_CODE, 'CON00', HOUR_VL) CON,
												DECODE(A.ITEM_CODE, 'TUR00', HOUR_VL) TUR,
												DECODE(A.ITEM_CODE, 'DOW00', HOUR_VL) DOW,
												DECODE(A.ITEM_CODE, 'TMP00', HOUR_VL) TMP,
												DECODE(A.ITEM_CODE, 'PHY00', HOUR_VL) PHY,
												DECODE(A.ITEM_CODE, 'TOF00', HOUR_VL) TOF,
												DECODE(A.ITEM_CODE, 'CON00', HOUR_OR) CON_OR,
												DECODE(A.ITEM_CODE, 'TUR00', HOUR_OR) TUR_OR,
												DECODE(A.ITEM_CODE, 'DOW00', HOUR_OR) DOW_OR,
												DECODE(A.ITEM_CODE, 'TMP00', HOUR_OR)TMP_OR,
												DECODE(A.ITEM_CODE, 'PHY00', HOUR_OR) PHY_OR,
												DECODE(A.ITEM_CODE, 'TOF00', HOUR_OR) TOF_OR,
												A.HOUR_ST AS MINST,
												C.RIVER_DIV,
												DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
												C.SYS_KIND,
												(
												SELECT SYS_KIND_NAME
													FROM T_SYS_KIND
												WHERE SYS_KIND =  C.SYS_KIND
												) SYS_KIND_NAME
										FROM T_HOUR_DATA A,
												T_ITEM_INFO B,
												T_FACT_INFO C,
												T_FACT_BRANCH_INFO D,
												T_FACT_MEASU_ITEM I
										WHERE A.ITEM_CODE  = B.ITEM_CODE
												AND I.ITEM_CODE = A.ITEM_CODE
												AND I.FACT_CODE = A.FACT_CODE
												AND I.BRANCH_NO = A.BRANCH_NO
												AND I.ITEM_USE_FLAG = 'Y'
												AND A.FACT_CODE  = C.FACT_CODE
												AND C.FACT_CODE = D.FACT_CODE
												AND A.BRANCH_NO = D.BRANCH_NO
												AND D.BRANCH_USE_FLAG = 'Y'
												AND C.FACT_USE_FLAG  = 'Y'
												AND C.RIVER_DIV = #sugye#
												<isNotEqual prepend="AND" property="gongku" compareValue="all">
													A.FACT_CODE = #gongku#
												</isNotEqual>
												<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
													A.BRANCH_NO = #chukjeongso#
												</isNotEqual>
												<isNotEqual prepend="AND" property="sys" compareValue="all">
													C.SYS_KIND  = #sys#
												</isNotEqual>
												<isNotEqual prepend="AND" property="minor" compareValue="all">
													<isEqual property="minor" compareValue="0">
													A.HOUR_OR = '0'		 /* 정상인 데이터만 */
													</isEqual>
													<isEqual property="minor" compareValue="1">
													A.HOUR_OR != '0'	/* 기준초과인 데이터만 */
													</isEqual>
												</isNotEqual>
												<isNotEqual prepend="AND" property="item" compareValue="all">
													 A.ITEM_CODE = #item#
												</isNotEqual>
												 AND A.HOUR_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
											)
								GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
												MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
												RIVER_DIV,
												RIVER_NAME, SYS_KIND, SYS_KIND_NAME	
								ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
			<isEqual property="sys" compareValue="U">
			) AA,
			 (
								SELECT 
									SUBSTR(Q.MIN_TIME, 0, 10) MIN_TIME,
									TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
									TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
									A.FACT_CODE,
									A.BRANCH_NO,
									A.FACT_NAME,
									A.BRANCH_NAME,
									A.SYS_KIND,
									A.RIVER_NAME,
									A.SYS_KIND_NAME,
									A.RIVER_DIV
								FROM
								(
								<![CDATA[
									SELECT
											TO_CHAR(TO_DATE(#frDate#||#frTime#, 'YYYYMMDDHH24MI')+(LEVEL*60/24/60)-(60/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
									FROM
									(
										SELECT 
												TO_DATE(#toDate#||#toTime#, 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime#, 'YYYYMMDDHH24MI') + (120/24/60) AS DAYCNT
										FROM DUAL
									)
									CONNECT BY (LEVEL*60/24/60+(60/24/60)) < DAYCNT
								]]>
								) Q,
								(
									SELECT 
										B.FACT_CODE,
										B.BRANCH_NO,
										<isEqual property="sys" compareValue="T">
										AREA.REG_NAME || '(' || NVL(F.FACT_NO,'-') || ')' AS FACT_NAME,
										</isEqual>
										<isNotEqual property="sys" compareValue="T">
										AREA.REG_NAME AS FACT_NAME,
										</isNotEqual>
										<isEqual property="sys" compareValue="A">
										B.BRANCH_NAME BRANCH_NAME,
										</isEqual>
										<isNotEqual property="sys" compareValue="A">
										B.BRANCH_NAME||'-'||B.BRANCH_NO BRANCH_NAME,
										</isNotEqual>
										F.RIVER_DIV,
										DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
										F.SYS_KIND,
										(
										SELECT SYS_KIND_NAME
											FROM T_SYS_KIND
										 WHERE SYS_KIND = F.SYS_KIND
										) SYS_KIND_NAME
									FROM
										T_FACT_INFO F,
										T_FACT_BRANCH_INFO B,
										T_WEATHER_AREA AREA
									WHERE
										F.RIVER_DIV = #sugye#
										AND F.FACT_CODE = B.FACT_CODE
										AND B.BRANCH_USE_FLAG = 'Y'
										AND AREA.FACT_CODE(+) = B.FACT_CODE
										<isEqual property="sys" compareValue="U">
										AND AREA.BRANCH_NO(+) = B.BRANCH_NO
										</isEqual>
										<isNotEqual prepend="AND" property="gongku" compareValue="all">
											F.FACT_CODE = #gongku#
										</isNotEqual>
										<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
											B.BRANCH_NO = #chukjeongso#
										</isNotEqual>
										<isNotEqual prepend="AND" property="sys" compareValue="all">
											F.SYS_KIND  = #sys#
										</isNotEqual>
								) A
								WHERE
								<![CDATA[TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE ]]>
						) QQ
				WHERE
					AA.MINTIME(+) = QQ.MIN_TIME
					AND AA.FACTCODE(+) = QQ.FACT_CODE
					AND AA.BRANCHNO(+) = QQ.BRANCH_NO
				 ORDER BY QQ.MIN_TIME ASC, QQ.FACT_CODE ASC, QQ.BRANCH_NO ASC
		</isEqual>
	</statement>
	
	<statement id="getRiverGraph_MIN" parameterClass="searchTaksuVO" resultClass="detailViewVO" remapResults="true">
	
		<isNull property="minTime">
			<isEqual property="sys" compareValue="U">
			SELECT
					  QQ.FACT_CODE, QQ.FACT_NAME, QQ.BRANCH_NO, QQ.BRANCH_NAME, QQ.MIN_TIME,
					  QQ.STRDATE, QQ.STRTIME,
					  TUR, CON, DOW, TMP, PHY, CON_OR, DOW_OR, TMP_OR, PHY_OR, TUR_OR,
					  IMP, LIM, RIM, LIM_OR, RIM_OR, LTX, RTX, LTX_OR, RTX_OR, TOX, TOX_OR, EVN, EVN_OR, TOF, TOF_OR, 
					  VOC1, VOC2, VOC3, VOC4, VOC5, VOC6, VOC7, VOC8, VOC9, VOC10, VOC11, VOC12, VOC13, VOC14, VOC15,
					  VOC1_OR, VOC2_OR, VOC3_OR, VOC4_OR, VOC5_OR, VOC6_OR, VOC7_OR, VOC8_OR, VOC9_OR, VOC10_OR, VOC11_OR, VOC12_OR, VOC13_OR, VOC14_OR, VOC15_OR,
					  COP, PLU, ZIN, CAD, PHE, PHL, TOC, TON, TOP, NH4, NO3, PO4, RIN
					  COP_OR, PLU_OR, ZIN_OR, CAD_OR, PHE_OR, PHL_OR, TOC_OR, TON_OR, TOP_OR, NH4_OR, NO3_OR, PO4_OR, RIN_OR,
					  AA.MINDUMP, QQ.RIVER_NAME, QQ.SYS_KIND_NAME, QQ.SYS_KIND 
			FROM
			(
			</isEqual>
			</isNull>
				  SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
						 MINTIME, STRDATE, STRTIME,  MINDUMP,
						 /* 일반 항목 (내부) */			  
						 TO_CHAR(SUM(TUR), 'FM999,990.00') TUR,
						 TO_CHAR(SUM(DECODE(CON2, NULL, CON, CON2)), 'FM999,990.000') CON,
						 TO_CHAR(SUM(DECODE(DOW2, NULL, DOW, DOW2)), 'FM999,990.00') DOW,
						 TO_CHAR(SUM(DECODE(TMP2, NULL, TMP, TMP2)), 'FM999,990.00') TMP,
						 TO_CHAR(SUM(DECODE(PHY2, NULL, PHY, PHY2)), 'FM999,990.00') PHY,
						 SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) CON_OR,
						 SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) DOW_OR,
						 SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) TMP_OR,
						 SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) PHY_OR, 
						 SUM(TUR_OR) TUR_OR,
						 /* 생물독성(물고기) */
						 TO_CHAR(SUM(IMP), 'FM999990.00') IMP,
						 SUM(IMP_OR) IMP_OR,
						 /* 생물독성(물벼룩1) */
						 TO_CHAR(SUM(LIM), 'FM999990.00') LIM,
						 TO_CHAR(SUM(RIM), 'FM999990.00') RIM,
						 SUM(LIM_OR) LIM_OR,
						 SUM(RIM_OR) RIM_OR,
						 /* 생물독성(물벼룩2) */
						 TO_CHAR(SUM(LTX), 'FM999990.00') LTX,
						 TO_CHAR(SUM(RTX), 'FM999990.00') RTX,
						 SUM(LTX_OR) LTX_OR,
						 SUM(RTX_OR) RTX_OR,
						  /* 생물독성(미생물) */
						 TO_CHAR(SUM(TOX), 'FM999990.00') TOX,
						 SUM(TOX_OR) TOX_OR,
						  /* 생물독성(조류) */
						 TO_CHAR(SUM(EVN), 'FM999990.00') EVN,
						 SUM(EVN_OR) EVN_OR,
						  /* 클로로필-a */
						 TO_CHAR(SUM(TOF), 'FM999990.00') TOF,
						 SUM(TOF_OR) TOF_OR,
						 /* 휘발성 유기화합물 */
						 TO_CHAR(SUM(VOC1), 'FM999990.00') VOC1,
						 TO_CHAR(SUM(VOC2), 'FM999990.00') VOC2,
						 TO_CHAR(SUM(VOC3), 'FM999990.00') VOC3,
						 TO_CHAR(SUM(VOC4), 'FM999990.00') VOC4,
						 TO_CHAR(SUM(VOC5), 'FM999990.00') VOC5,
						 TO_CHAR(SUM(VOC6), 'FM999990.00') VOC6,
						 TO_CHAR(SUM(VOC7), 'FM999990.00') VOC7,
						 TO_CHAR(SUM(VOC8), 'FM999990.00') VOC8,
						 TO_CHAR(SUM(VOC9), 'FM999990.00') VOC9,
						 TO_CHAR(SUM(VOC10), 'FM999990.00') VOC10,
						 TO_CHAR(SUM(VOC11), 'FM999990.00') VOC11,
						 TO_CHAR(SUM(VOC12), 'FM999990.00') VOC12,
						 TO_CHAR(SUM(VOC13), 'FM999990.00') VOC13,
						 TO_CHAR(SUM(VOC14), 'FM999990.00') VOC14,
						 TO_CHAR(SUM(VOC15), 'FM999990.00') VOC15,
						 SUM(VOC1_OR) VOC1_OR,
						 SUM(VOC2_OR) VOC2_OR,
						 SUM(VOC3_OR) VOC3_OR,
						 SUM(VOC4_OR) VOC4_OR,
						 SUM(VOC5_OR) VOC5_OR,
						 SUM(VOC6_OR) VOC6_OR,
						 SUM(VOC7_OR) VOC7_OR,
						 SUM(VOC8_OR) VOC8_OR,
						 SUM(VOC9_OR) VOC9_OR,
						 SUM(VOC10_OR) VOC10_OR,
						 SUM(VOC11_OR) VOC11_OR,
						 SUM(VOC12_OR) VOC12_OR,
						 SUM(VOC13_OR) VOC13_OR,
						 SUM(VOC14_OR) VOC14_OR,
						 SUM(VOC15_OR) VOC15_OR,
						 /* 중금속 */
						 TO_CHAR(SUM(COP), 'FM999990.00') COP,
						 TO_CHAR(SUM(PLU), 'FM999990.00') PLU,
						 TO_CHAR(SUM(ZIN), 'FM999990.00') ZIN,
						 TO_CHAR(SUM(CAD), 'FM999990.00') CAD,
						 SUM(COP_OR) COP_OR,
						 SUM(PLU_OR) PLU_OR,
						 SUM(ZIN_OR) ZIN_OR,
						 SUM(CAD_OR) CAD_OR,
						 /* 페놀 */
						 TO_CHAR(SUM(PHE), 'FM999990.00') PHE,
						 TO_CHAR(SUM(PHL), 'FM999990.00') PHL,
						 SUM(PHE_OR) PHE_OR,
						 SUM(PHL_OR) PHL_OR,
						  /* 유기물질 */
						 TO_CHAR(SUM(TOC), 'FM999990.00') TOC,
						 SUM(TOC_OR) TOC_OR,
						 /* 영양염류 */
						 TO_CHAR(SUM(TON), 'FM999990.00') TON,
						 TO_CHAR(SUM(TOP), 'FM999990.00') TOP,
						 TO_CHAR(SUM(NH4), 'FM999990.00') NH4,
						 TO_CHAR(SUM(NO3), 'FM999990.00') NO3,
						 TO_CHAR(SUM(PO4), 'FM999990.00') PO4,
						 SUM(TON_OR) TON_OR,
						 SUM(TOP_OR) TOP_OR,
						 SUM(NH4_OR) NH4_OR,
						 SUM(NO3_OR) NO3_OR,
						 SUM(PO4_OR) PO4_OR,
						 /* 강수량계 */
						 TO_CHAR(SUM(RIN), 'FM999990.00') RIN,
						 SUM(RIN_OR) RIN_OR,
						 MAX(MINST) MINST, '' MINAB, RIVER_DIV,
						 RIVER_NAME, SYS_KIND, SYS_KIND_NAME
				FROM (
					  SELECT A.ITEM_CODE AS ITEMCODE,
							 B.ITEM_NAME AS ITEMNAME,
							 A.FACT_CODE AS FACTCODE,
							 C.FACT_NAME AS FACTNAME,
							 A.BRANCH_NO AS BRANCHNO,
							 <isEqual property="sys" compareValue="A">
							 D.BRANCH_NAME BRANCH_NAME,
							 </isEqual>
							 <isNotEqual property="sys" compareValue="A">
							 D.BRANCH_NAME||'-'||A.BRANCH_NO BRANCH_NAME,
							 </isNotEqual>
							 A.MIN_TIME  AS MINTIME ,
							 TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
							 TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
							 A.MIN_DUMP  AS MINDUMP ,
							/*  일반항목 내부 */
							 DECODE(A.ITEM_CODE, 'CON00', MIN_VL) CON,
							 DECODE(A.ITEM_CODE, 'DOW00', MIN_VL) DOW,
							 DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) TMP,
							 DECODE(A.ITEM_CODE, 'PHY00', MIN_VL) PHY,
							 DECODE(A.ITEM_CODE, 'CON00', MIN_OR) CON_OR,
							 DECODE(A.ITEM_CODE, 'DOW00', MIN_OR) DOW_OR,
							 DECODE(A.ITEM_CODE, 'TMP00', MIN_OR)TMP_OR,
							 DECODE(A.ITEM_CODE, 'PHY00', MIN_OR) PHY_OR,
							 /* 일반 항목 외부 */
							 DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) TMP2,
							 DECODE(A.ITEM_CODE, 'TMP02', MIN_VL) TMP3,
							 DECODE(A.ITEM_CODE, 'PHY01', MIN_VL) PHY2,
							 DECODE(A.ITEM_CODE, 'PHY02', MIN_VL) PHY3,
							 DECODE(A.ITEM_CODE, 'DOW01', MIN_VL) DOW2,
							 DECODE(A.ITEM_CODE, 'DOW02', MIN_VL) DOW3,
							 DECODE(A.ITEM_CODE, 'CON01', MIN_VL) CON2,
							 DECODE(A.ITEM_CODE, 'CON02', MIN_VL) CON3,
							 DECODE(A.ITEM_CODE, 'TMP01', MIN_OR) TMP2_OR,
							 DECODE(A.ITEM_CODE, 'TMP02', MIN_OR) TMP3_OR,
							 DECODE(A.ITEM_CODE, 'PHY01', MIN_OR) PHY2_OR,
							 DECODE(A.ITEM_CODE, 'PHY02', MIN_OR) PHY3_OR,
							 DECODE(A.ITEM_CODE, 'DOW01', MIN_OR) DOW2_OR,
							 DECODE(A.ITEM_CODE, 'DOW02', MIN_OR) DOW3_OR,
							 DECODE(A.ITEM_CODE, 'CON01', MIN_OR) CON2_OR,
							 DECODE(A.ITEM_CODE, 'CON02', MIN_OR) CON3_OR,
							 DECODE(A.ITEM_CODE, 'TUR00', MIN_OR) TUR_OR,
							 DECODE(A.ITEM_CODE, 'TUR00', MIN_VL) TUR,
							 /* 생물 독성 (물고기)*/
							 DECODE(A.ITEM_CODE, 'IMP00', MIN_VL) IMP,
							 DECODE(A.ITEM_CODE, 'IMP00', MIN_OR) IMP_OR,
							 /* 생물 독성 (물벼룩1) */
							 DECODE(A.ITEM_CODE, 'LIM00', MIN_VL) LIM,
							 DECODE(A.ITEM_CODE, 'RIM00', MIN_VL) RIM,
							 DECODE(A.ITEM_CODE, 'LIM00', MIN_OR) LIM_OR,
							 DECODE(A.ITEM_CODE, 'RIM00', MIN_OR) RIM_OR,
							 /* 생물 독성 (물벼룩2) */
							 DECODE(A.ITEM_CODE, 'LTX00', MIN_VL) LTX,
							 DECODE(A.ITEM_CODE, 'RTX00', MIN_VL) RTX,
							 DECODE(A.ITEM_CODE, 'LTX00', MIN_OR) LTX_OR,
							 DECODE(A.ITEM_CODE, 'RTX00', MIN_OR) RTX_OR,
							 /* 생물 독성 (미생물) */
							 DECODE(A.ITEM_CODE, 'TOX00', MIN_VL) TOX,
							 DECODE(A.ITEM_CODE, 'TOX00', MIN_OR) TOX_OR,
							 /* 생물 독성 (조류) */
							 DECODE(A.ITEM_CODE, 'EVN00', MIN_VL) EVN,
							 DECODE(A.ITEM_CODE, 'EVN00', MIN_OR) EVN_OR,
							 /* 클로로필-a */
							 DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) TOF,
							 DECODE(A.ITEM_CODE, 'TOF00', MIN_OR) TOF_OR,
							 /* 휘발성 유기화합물 */
							 DECODE(A.ITEM_CODE, 'VOC01', MIN_VL) VOC1,
							 DECODE(A.ITEM_CODE, 'VOC02', MIN_VL) VOC2,
							 DECODE(A.ITEM_CODE, 'VOC03', MIN_VL) VOC3,
							 DECODE(A.ITEM_CODE, 'VOC04', MIN_VL) VOC4,
							 DECODE(A.ITEM_CODE, 'VOC05', MIN_VL) VOC5,
							 DECODE(A.ITEM_CODE, 'VOC06', MIN_VL) VOC6,
							 DECODE(A.ITEM_CODE, 'VOC07', MIN_VL) VOC7,
							 DECODE(A.ITEM_CODE, 'VOC08', MIN_VL) VOC8,
							 DECODE(A.ITEM_CODE, 'VOC09', MIN_VL) VOC9,
							 DECODE(A.ITEM_CODE, 'VOC10', MIN_VL) VOC10,
							 DECODE(A.ITEM_CODE, 'VOC11', MIN_VL) VOC11,
							 DECODE(A.ITEM_CODE, 'VOC12', MIN_VL) VOC12,
							 DECODE(A.ITEM_CODE, 'VOC13', MIN_VL) VOC13,
							 DECODE(A.ITEM_CODE, 'VOC14', MIN_VL) VOC14,
							 DECODE(A.ITEM_CODE, 'VOC15', MIN_VL) VOC15,
							 DECODE(A.ITEM_CODE, 'VOC01', MIN_OR) VOC1_OR,
							 DECODE(A.ITEM_CODE, 'VOC02', MIN_OR) VOC2_OR,
							 DECODE(A.ITEM_CODE, 'VOC03', MIN_OR) VOC3_OR,
							 DECODE(A.ITEM_CODE, 'VOC04', MIN_OR) VOC4_OR,
							 DECODE(A.ITEM_CODE, 'VOC05', MIN_OR) VOC5_OR,
							 DECODE(A.ITEM_CODE, 'VOC06', MIN_OR) VOC6_OR,
							 DECODE(A.ITEM_CODE, 'VOC07', MIN_OR) VOC7_OR,
							 DECODE(A.ITEM_CODE, 'VOC08', MIN_OR) VOC8_OR,
							 DECODE(A.ITEM_CODE, 'VOC09', MIN_OR) VOC9_OR,
							 DECODE(A.ITEM_CODE, 'VOC10', MIN_OR) VOC10_OR,
							 DECODE(A.ITEM_CODE, 'VOC11', MIN_OR) VOC11_OR,
							 DECODE(A.ITEM_CODE, 'VOC12', MIN_OR) VOC12_OR,
							 DECODE(A.ITEM_CODE, 'VOC13', MIN_OR) VOC13_OR,
							 DECODE(A.ITEM_CODE, 'VOC14', MIN_OR) VOC14_OR,
							 DECODE(A.ITEM_CODE, 'VOC15', MIN_OR) VOC15_OR,
							 /* 중금속 */
							 DECODE(A.ITEM_CODE, 'COP00', MIN_VL) COP,
							 DECODE(A.ITEM_CODE, 'PLU00', MIN_VL) PLU,
							 DECODE(A.ITEM_CODE, 'ZIN00', MIN_VL) ZIN,
							 DECODE(A.ITEM_CODE, 'CAD00', MIN_VL) CAD,
							 DECODE(A.ITEM_CODE, 'COP00', MIN_OR) COP_OR,
							 DECODE(A.ITEM_CODE, 'PLU00', MIN_OR) PLU_OR,
							 DECODE(A.ITEM_CODE, 'ZIN00', MIN_OR) ZIN_OR,
							 DECODE(A.ITEM_CODE, 'CAD00', MIN_OR) CAD_OR,
							 /* 페놀 */
							 DECODE(A.ITEM_CODE, 'PHE00', MIN_VL) PHE,
							 DECODE(A.ITEM_CODE, 'PHL00', MIN_VL) PHL,
							 DECODE(A.ITEM_CODE, 'PHE00', MIN_OR) PHE_OR,
							 DECODE(A.ITEM_CODE, 'PHL00', MIN_OR) PHL_OR,
							 /* 유기물질 */
							 DECODE(A.ITEM_CODE, 'TOC00', MIN_VL) TOC,
							 DECODE(A.ITEM_CODE, 'TOC00', MIN_OR) TOC_OR,
							 /* 영양염류 */
							 DECODE(A.ITEM_CODE, 'TON00', MIN_VL) TON,
							 DECODE(A.ITEM_CODE, 'TOP00', MIN_VL) TOP,
							 DECODE(A.ITEM_CODE, 'NH400', MIN_VL) NH4,
							 DECODE(A.ITEM_CODE, 'NO300', MIN_VL) NO3,
							 DECODE(A.ITEM_CODE, 'PO400', MIN_VL) PO4,
							 DECODE(A.ITEM_CODE, 'TON00', MIN_OR) TON_OR,
							 DECODE(A.ITEM_CODE, 'TOP00', MIN_OR) TOP_OR,
							 DECODE(A.ITEM_CODE, 'NH400', MIN_OR) NH4_OR,
							 DECODE(A.ITEM_CODE, 'NO300', MIN_OR) NO3_OR,
							 DECODE(A.ITEM_CODE, 'PO400', MIN_OR) PO4_OR,
							 /* 강수량계 */
							 DECODE(A.ITEM_CODE, 'RIN00', MIN_VL) RIN,
							 DECODE(A.ITEM_CODE, 'RIN00', MIN_OR) RIN_OR,
							 A.MIN_ST	AS MINST	,
							 C.RIVER_DIV,
							 DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
							 C.SYS_KIND,
							 (
							  SELECT SYS_KIND_NAME 
								 FROM T_SYS_KIND 
								WHERE SYS_KIND =  C.SYS_KIND
							 ) SYS_KIND_NAME
						FROM T_MIN_DATA A, 
								T_ITEM_INFO B, 
								T_FACT_INFO C,
								T_FACT_BRANCH_INFO D,
								<isNotEqual property="sys" compareValue="A">
								 T_FACT_MEASU_ITEM I,
								</isNotEqual>
								T_WQA_ITEM M
						WHERE A.ITEM_CODE  = B.ITEM_CODE
							 <isNotEqual property="sys" compareValue="A">
								  AND I.ITEM_CODE = A.ITEM_CODE
								  AND I.FACT_CODE = A.FACT_CODE
								  AND I.BRANCH_NO = A.BRANCH_NO
								  AND I.ITEM_USE_FLAG = 'Y'
								</isNotEqual>
								 AND A.FACT_CODE  = C.FACT_CODE
							  AND C.FACT_CODE = D.FACT_CODE
							  AND A.BRANCH_NO = D.BRANCH_NO
							  AND D.BRANCH_USE_FLAG = 'Y'
							  AND C.FACT_USE_FLAG  = 'Y'
							  AND C.RIVER_DIV = #sugye#
							 <isNotEqual prepend="AND" property="gongku" compareValue="all">
								A.FACT_CODE = #gongku#
							 </isNotEqual>
							 <isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
							 A.BRANCH_NO = #chukjeongso#
							 </isNotEqual>
							 <isNotEqual prepend="AND" property="sys" compareValue="all">
							 C.SYS_KIND  = #sys#
							 </isNotEqual>
							 <isNotEqual prepend="AND" property="minor" compareValue="all">
									 <isEqual property="minor" compareValue="0">
									  A.MIN_OR = '0'		 /* 정상인 데이터만 */
								  </isEqual>
								  <isEqual property="minor" compareValue="1">
									  A.MIN_OR != '0'	/* 기준초과인 데이터만 */
								  </isEqual>
							 </isNotEqual>
							 /* 측정망이 아닐 때 항목으로 검색 */
							 <isNotEqual property="sys" compareValue="A">
								 <isNotEqual prepend="AND" property="item" compareValue="all">
										 A.ITEM_CODE IN (#item#, #item02#, #item03#)
								 </isNotEqual>
							 </isNotEqual>
							 AND M.ITEM_CODE = A.ITEM_CODE
							 /* 측정망일 때 대분류로 검색 */
							 <isEqual property="sys" compareValue="A">
									 <isNotEqual property="item" compareValue="all">
										  AND M.ITEM_KIND IN (#item#, DECODE(#item#, 'COM1', 'COM2', 'XXX'))
									 </isNotEqual>
							 </isEqual>
							 <isNotNull property="minTime">
								 AND A.MIN_TIME BETWEEN #minTime# AND #endTime#
							 </isNotNull>
							 <isNull property="minTime">
								 AND A.MIN_TIME BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
							 </isNull>
						)
				GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
							 MINTIME, STRDATE, STRTIME, MINDUMP,
							 RIVER_DIV,
							 RIVER_NAME, SYS_KIND, SYS_KIND_NAME
				ORDER BY STRDATE ASC, STRTIME ASC, FACTNAME ASC, BRANCHNO ASC
		<isNull property="minTime">
		<isEqual property="sys" compareValue="U">
		) AA,
		(
					  SELECT 
						  Q.MIN_TIME, 
						  TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
						  TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
						  A.FACT_CODE, 
						  A.BRANCH_NO, 
						  A.FACT_NAME,
						  A.BRANCH_NAME,
						  A.SYS_KIND,
						  A.RIVER_NAME,
						  A.SYS_KIND_NAME,
						  A.RIVER_DIV
					  FROM
					  (
					  <isEqual property="sys" compareValue="U">
					  <![CDATA[
						  SELECT
								  TO_CHAR(TO_DATE(#frDate#||#frTime#||'00' , 'YYYYMMDDHH24MI')+(LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
						  FROM
						  (
							  SELECT 
									 TO_DATE(#toDate#||#toTime#||'59', 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime#||'00' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
							  FROM DUAL
							)
						  CONNECT BY (LEVEL*10/24/60+(10/24/60)) < DAYCNT
					  ]]>
					  </isEqual>
					  <isEqual property="sys" compareValue="T">
					  <![CDATA[
						  SELECT
								  TO_CHAR(TO_DATE(#frDate#||#frTime#||'00' , 'YYYYMMDDHH24MI')+(LEVEL*30/24/60)-(30/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
						  FROM
						  (
							  SELECT 
									 TO_DATE(#toDate#||#toTime#||'59', 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime#||'00' , 'YYYYMMDDHH24MI') + (60/24/60) AS DAYCNT
							  FROM DUAL
							)
						  CONNECT BY (LEVEL*30/24/60+(30/24/60)) < DAYCNT
					  ]]>
					  </isEqual>
					  <isEqual property="sys" compareValue="A">
					  <![CDATA[
						  SELECT
								  TO_CHAR(TO_DATE(#frDate#||#frTime#||'00' , 'YYYYMMDDHH24MI')+(LEVEL*5/24/60)-(5/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
						  FROM
						  (
							  SELECT 
									 TO_DATE(#toDate#||#toTime#||'59', 'YYYYMMDDHH24MI') - TO_DATE(#frDate#||#frTime#||'00' , 'YYYYMMDDHH24MI') + (10/24/60) AS DAYCNT
							  FROM DUAL
							)
						  CONNECT BY (LEVEL*5/24/60+(5/24/60)) < DAYCNT
					  ]]>
					  </isEqual>
					  ) Q,
					  (
						  SELECT 
							 B.FACT_CODE,
							 B.BRANCH_NO,
							<isEqual property="sys" compareValue="T">
								  AREA.REG_NAME || '(' || NVL(F.FACT_NO,'-') || ')' AS FACT_NAME,
							 </isEqual>
							 <isNotEqual property="sys" compareValue="T">
								  AREA.REG_NAME AS FACT_NAME,
							 </isNotEqual>
							 <isEqual property="sys" compareValue="A">
								  B.BRANCH_NAME BRANCH_NAME,
							 </isEqual>
							 <isNotEqual property="sys" compareValue="A">
								  B.BRANCH_NAME||'-'||B.BRANCH_NO BRANCH_NAME,
							 </isNotEqual>
							 F.RIVER_DIV,
							 DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
							 F.SYS_KIND,
							 (
							  SELECT SYS_KIND_NAME 
								 FROM T_SYS_KIND 
								WHERE SYS_KIND =  F.SYS_KIND
							 ) SYS_KIND_NAME	
						  FROM
							  T_FACT_INFO F,
							  T_FACT_BRANCH_INFO B,
							  T_WEATHER_AREA AREA
						  WHERE
							  F.RIVER_DIV = #sugye#
							  AND F.FACT_CODE = B.FACT_CODE
							  AND B.BRANCH_USE_FLAG = 'Y'
							  AND AREA.FACT_CODE(+) = B.FACT_CODE
							  <isEqual property="sys" compareValue="U">
								  AND AREA.BRANCH_NO(+) = B.BRANCH_NO
							  </isEqual>
							  <isNotEqual prepend="AND" property="gongku" compareValue="all">
									  F.FACT_CODE = #gongku#
							  </isNotEqual>
							  <isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
									 B.BRANCH_NO = #chukjeongso#
							  </isNotEqual>
							  <isNotEqual prepend="AND" property="sys" compareValue="all">
									 F.SYS_KIND  = #sys#
							 </isNotEqual>
					  ) A
					  WHERE
					  <![CDATA[TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE ]]>
			  ) QQ
	  WHERE
		  AA.MINTIME(+) = QQ.MIN_TIME 
		  AND AA.FACTCODE(+) = QQ.FACT_CODE
		  AND AA.BRANCHNO(+) = QQ.BRANCH_NO	 
		ORDER BY QQ.MIN_TIME ASC, QQ.FACT_CODE ASC, QQ.BRANCH_NO ASC
	 </isEqual>
	 </isNull>
	</statement>
	
	<statement id="getDetailViewDISCHARGE_MIN"  parameterClass="searchTaksuVO" resultClass="detailViewVO">
		SELECT 
			* 
			FROM ( 
				SELECT 
					ROWNUM RNUM, T.*
					FROM
					(
						SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
											MINTIME, STRDATE, STRTIME, MINDUMP,
											TO_CHAR(SUM(PHY), 'FM999,990.00') PHY,
											TO_CHAR(SUM(BOD), 'FM999,990.00') BOD,
											TO_CHAR(SUM(COD), 'FM999,990.00') COD,
											TO_CHAR(SUM(SUS), 'FM999,990.00') SUS,
											TO_CHAR(SUM(TOP), 'FM999,990.00') TOP,
											TO_CHAR(SUM(TON), 'FM999,990.00') TON,
											TO_CHAR(SUM(FLW), 'FM999,990') FLW,
											SUM(PHY_OR) PHY_OR,
											SUM(BOD_OR) BOD_OR,
											SUM(COD_OR) COD_OR,
											SUM(SUS_OR) SUS_OR,
											SUM(TOP_OR) TOP_OR,
											SUM(TON_OR) TON_OR,
											SUM(FLW_OR) FLW_OR,
											MAX(MINST) MINST, MAX(MINAB) MINAB, RIVER_DIV,
											RIVER_NAME, SYS_KIND, SYS_KIND_NAME
								  FROM (				
										SELECT A.ITEM_CODE AS ITEMCODE,
												B.ITEM_NAME AS ITEMNAME,
												A.FACT_CODE AS FACTCODE,
												C.FACT_NAME AS FACTNAME,
												A.WAST_NO	AS BRANCHNO,
												A.WAST_NO BRANCH_NAME,
												A.MIN_TIME  AS MINTIME ,
												TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
												TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
												A.MIN_DUMP  AS MINDUMP ,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', MIN_VL) PHY,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', MIN_VL) BOD,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', MIN_VL) COD,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'SUS', MIN_VL) SUS,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', MIN_VL) TOP,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'TON', MIN_VL) TON,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', MIN_VL) FLW,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', MIN_OR) PHY_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', MIN_OR) BOD_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', MIN_OR) COD_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'SUS', MIN_OR) SUS_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', MIN_OR) TOP_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', MIN_OR) TON_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', MIN_OR) FLW_OR,
												A.MIN_ST	AS MINST	,
												A.MIN_AB	AS MINAB	,
												'R'||AREA.AREA_GBN AS RIVER_DIV,
												DECODE(AREA.AREA_GBN,'01','수도권','02','충청/강원','03','영남','04','호남') AS RIVER_NAME,
												'W' SYS_KIND,
												'수질TMS' SYS_KIND_NAME		
<!-- 												인라인 쿼리시 속도가 너무 느림 -->
<!-- 												( -->
<!-- 												SELECT SYS_KIND_NAME  -->
<!-- 													FROM T_SYS_KIND  -->
<!-- 												 WHERE SYS_KIND =  'W' -->
<!-- 												) SYS_KIND_NAME						 -->
										  FROM WTMSC_MIN_REAL@TMS A, 
												  WTMSC_ITEM@TMS B, 
												  WTMSC_FACT@TMS C,
												  WTMSC_FACT_WAST@TMS D,
												  WTMSC_AREA@TMS AREA
										 WHERE A.ITEM_CODE  = B.ITEM_CODE
												AND A.FACT_CODE  = C.FACT_CODE
												AND C.FACT_CODE = D.FACT_CODE
												AND A.WAST_NO = D.WAST_NO
												AND D.WAST_USED = 'Y'
												AND C.FACT_USED  = 'Y'
												AND AREA.CTY_CODE = C.CTY_CODE
												<isNotEqual prepend="AND" property="sugye" compareValue="all">
													AREA.DO_CODE = #sugye#
												</isNotEqual>
												<isNotEqual prepend="AND" property="gongku" compareValue="all">
													A.FACT_CODE = #gongku#
												</isNotEqual>
												<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
													A.WAST_NO = #chukjeongso#
												</isNotEqual>
												AND A.MIN_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
										  )
								 GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
												MINTIME, STRDATE, STRTIME, MINDUMP,
												RIVER_DIV,
												RIVER_NAME, SYS_KIND, SYS_KIND_NAME
								 ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
					) T
			)
			WHERE
			<![CDATA[  
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>	
	</statement>
	
	<select id="getTotCntDischarge_MIN"  parameterClass="searchTaksuVO" resultClass="java.lang.Integer">
		SELECT 
					COUNT(*)
					FROM
					(
						SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
											MINTIME, STRDATE, STRTIME, MINDUMP,
											TO_CHAR(SUM(PHY), 'FM999,990.00') PHY,
											TO_CHAR(SUM(BOD), 'FM999,990.00') BOD,
											TO_CHAR(SUM(COD), 'FM999,990.00') COD,
											TO_CHAR(SUM(SUS), 'FM999,990.00') SUS,
											TO_CHAR(SUM(TOP), 'FM999,990.00') TOP,
											TO_CHAR(SUM(TON), 'FM999,990.00') TON,
											TO_CHAR(SUM(FLW), 'FM999,990') FLW,
											SUM(PHY_OR) PHY_OR,
											SUM(BOD_OR) BOD_OR,
											SUM(COD_OR) COD_OR,
											SUM(SUS_OR) SUS_OR,
											SUM(TOP_OR) TOP_OR,
											SUM(TON_OR) TON_OR,
											SUM(FLW_OR) FLW_OR,
											MAX(MINST) MINST, MAX(MINAB) MINAB, RIVER_DIV,
											RIVER_NAME, SYS_KIND, SYS_KIND_NAME
								  FROM (				
										SELECT A.ITEM_CODE AS ITEMCODE,
												B.ITEM_NAME AS ITEMNAME,
												A.FACT_CODE AS FACTCODE,
												C.FACT_NAME AS FACTNAME,
												A.WAST_NO	AS BRANCHNO,
												A.WAST_NO BRANCH_NAME,
												A.MIN_TIME  AS MINTIME ,
												TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
												TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
												A.MIN_DUMP  AS MINDUMP ,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', MIN_VL) PHY,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', MIN_VL) BOD,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', MIN_VL) COD,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'SUS', MIN_VL) SUS,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', MIN_VL) TOP,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'TON', MIN_VL) TON,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', MIN_VL) FLW,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', MIN_OR) PHY_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', MIN_OR) BOD_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', MIN_OR) COD_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'SUS', MIN_OR) SUS_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', MIN_OR) TOP_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', MIN_OR) TON_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', MIN_OR) FLW_OR,
												A.MIN_ST	AS MINST	,
												A.MIN_AB	AS MINAB	,
											  'R'||AREA.AREA_GBN AS RIVER_DIV,
												DECODE(AREA.AREA_GBN,'01','한강','02','낙동강','03','금강','04','영산강') AS RIVER_NAME,
												'W' SYS_KIND,
												'수질TMS' SYS_KIND_NAME		
<!-- 												인라인 쿼리시 속도가 너무 느림 -->
<!-- 												( -->
<!-- 												SELECT SYS_KIND_NAME  -->
<!-- 													FROM T_SYS_KIND  -->
<!-- 												 WHERE SYS_KIND =  'W' -->
<!-- 												) SYS_KIND_NAME						 -->
										  FROM WTMSC_MIN_REAL@TMS A, 
												  WTMSC_ITEM@TMS B, 
												  WTMSC_FACT@TMS C,
												  WTMSC_FACT_WAST@TMS D,
												  WTMSC_AREA@TMS AREA
										 WHERE A.ITEM_CODE  = B.ITEM_CODE
												AND A.FACT_CODE  = C.FACT_CODE
												AND C.FACT_CODE = D.FACT_CODE
												AND A.WAST_NO = D.WAST_NO
												AND D.WAST_USED = 'Y'
												AND C.FACT_USED  = 'Y'
												AND AREA.CTY_CODE = C.CTY_CODE
												<isNotEqual prepend="AND" property="sugye" compareValue="all">
													AREA.DO_CODE = #sugye#
												</isNotEqual>
												<isNotEqual prepend="AND" property="gongku" compareValue="all">
													A.FACT_CODE = #gongku#
												</isNotEqual>
												<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
													A.WAST_NO = #chukjeongso#
												</isNotEqual>
												AND A.MIN_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
										  )
								 GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
												MINTIME, STRDATE, STRTIME, MINDUMP,
												RIVER_DIV,
												RIVER_NAME, SYS_KIND, SYS_KIND_NAME
								 ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
					)
	</select>

	<statement id="getDetailViewDISCHARGE_HOUR"  parameterClass="searchTaksuVO" resultClass="detailViewVO">
		SELECT 
			* 
			FROM ( 
				SELECT 
					ROWNUM RNUM, T.*
					FROM
					(
						SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
											MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
											TO_CHAR(SUM(PHY), 'FM999,990.00') PHY,
											TO_CHAR(SUM(BOD), 'FM999,990.00') BOD,
											TO_CHAR(SUM(COD), 'FM999,990.00') COD,
											TO_CHAR(SUM(SUS), 'FM999,990.00') SUS,
											TO_CHAR(SUM(TOP), 'FM999,990.00') TOP,
											TO_CHAR(SUM(TON), 'FM999,990.00') TON,
											TO_CHAR(SUM(FLW), 'FM999,990') FLW,
											SUM(PHY_OR) PHY_OR,
											SUM(BOD_OR) BOD_OR,
											SUM(COD_OR) COD_OR,
											SUM(SUS_OR) SUS_OR,
											SUM(TOP_OR) TOP_OR,
											SUM(TON_OR) TON_OR,
											SUM(FLW_OR) FLW_OR,
											MAX(MINST) MINST, MAX(MINAB) MINAB, RIVER_DIV,
											RIVER_NAME, SYS_KIND, SYS_KIND_NAME
								  FROM (				
										SELECT A.ITEM_CODE AS ITEMCODE,
												B.ITEM_NAME AS ITEMNAME,
												A.FACT_CODE AS FACTCODE,
												C.FACT_NAME AS FACTNAME,
												A.WAST_NO	AS BRANCHNO,
												A.WAST_NO BRANCH_NAME,
												A.HOUR_TIME  AS MINTIME ,
												TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
												TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
												A.HOUR_RTIME AS MINRTIME,
												A.HOUR_DUMP  AS MINDUMP ,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', HOUR_VL) PHY,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_VL) BOD,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_VL) COD,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'SUS', HOUR_VL) SUS,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_VL) TOP,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'TON', HOUR_VL) TON,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_VL) FLW,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', HOUR_OR) PHY_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_OR) BOD_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_OR) COD_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'SUS', HOUR_OR) SUS_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_OR) TOP_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', HOUR_OR) TON_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_OR) FLW_OR,
												A.HOUR_ST	AS MINST	,
												A.HOUR_AB	AS MINAB	,
												'R'||AREA.AREA_GBN AS RIVER_DIV,
												DECODE(AREA.AREA_GBN,'01','수도권','02','충청/강원','03','영남','04','호남') AS RIVER_NAME,
												'W' SYS_KIND,
												'수질TMS' SYS_KIND_NAME		
<!-- 												인라인 쿼리시 속도가 너무 느림 -->
<!-- 												( -->
<!-- 												SELECT SYS_KIND_NAME  -->
<!-- 													FROM T_SYS_KIND  -->
<!-- 												 WHERE SYS_KIND =  'W' -->
<!-- 												) SYS_KIND_NAME -->
										  FROM WTMSC_HOUR_REAL@TMS A, 
												  WTMSC_ITEM@TMS B, 
												  WTMSC_FACT@TMS C,
												  WTMSC_FACT_WAST@TMS D,
												  WTMSC_AREA@TMS AREA
										 WHERE A.ITEM_CODE  = B.ITEM_CODE
												AND A.FACT_CODE  = C.FACT_CODE
												AND C.FACT_CODE = D.FACT_CODE
												AND A.WAST_NO = D.WAST_NO
												AND D.WAST_USED = 'Y'
												AND C.FACT_USED  = 'Y'
												AND AREA.CTY_CODE = C.CTY_CODE
												<isNotEqual prepend="AND" property="sugye" compareValue="all">
													AREA.DO_CODE = #sugye#
												</isNotEqual>
												<isNotEqual prepend="AND" property="gongku" compareValue="all">
													A.FACT_CODE = #gongku#
												</isNotEqual>
												<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
													A.WAST_NO = #chukjeongso#
												</isNotEqual>
												AND A.HOUR_TIME BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
										  )
								 GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
												MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
												RIVER_DIV,
												RIVER_NAME, SYS_KIND, SYS_KIND_NAME
								 ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
					) T
			)
			WHERE
			<![CDATA[  
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>	
	</statement>
	
	<select id="getTotCntDischarge_HOUR" parameterClass="searchTaksuVO" resultClass="java.lang.Integer">
		SELECT 
					COUNT(*)
					FROM
					(
						SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
											MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
											TO_CHAR(SUM(PHY), 'FM999,990.00') PHY,
											TO_CHAR(SUM(BOD), 'FM999,990.00') BOD,
											TO_CHAR(SUM(COD), 'FM999,990.00') COD,
											TO_CHAR(SUM(SUS), 'FM999,990.00') SUS,
											TO_CHAR(SUM(TOP), 'FM999,990.00') TOP,
											TO_CHAR(SUM(TON), 'FM999,990.00') TON,
											TO_CHAR(SUM(FLW), 'FM999,990') FLW,
											SUM(PHY_OR) PHY_OR,
											SUM(BOD_OR) BOD_OR,
											SUM(COD_OR) COD_OR,
											SUM(SUS_OR) SUS_OR,
											SUM(TOP_OR) TOP_OR,
											SUM(TON_OR) TON_OR,
											SUM(FLW_OR) FLW_OR,
											MAX(MINST) MINST, MAX(MINAB) MINAB, RIVER_DIV,
											RIVER_NAME, SYS_KIND, SYS_KIND_NAME
								FROM (				
										SELECT A.ITEM_CODE AS ITEMCODE,
												B.ITEM_NAME AS ITEMNAME,
												A.FACT_CODE AS FACTCODE,
												C.FACT_NAME AS FACTNAME,
												A.WAST_NO	AS BRANCHNO,
												A.WAST_NO BRANCH_NAME,
												A.HOUR_TIME  AS MINTIME ,
												TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
												TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
												A.HOUR_RTIME AS MINRTIME,
												A.HOUR_DUMP  AS MINDUMP ,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', HOUR_VL) PHY,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_VL) BOD,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_VL) COD,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'SUS', HOUR_VL) SUS,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_VL) TOP,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'TON', HOUR_VL) TON,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_VL) FLW,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', HOUR_OR) PHY_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_OR) BOD_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_OR) COD_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'SUS', HOUR_OR) SUS_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_OR) TOP_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', HOUR_OR) TON_OR,
												DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_OR) FLW_OR,
												A.HOUR_ST	AS MINST	,
												A.HOUR_AB	AS MINAB	,
												'R'||AREA.AREA_GBN AS RIVER_DIV,
												DECODE(AREA.AREA_GBN,'01','한강','02','낙동강','03','금강','04','영산강') AS RIVER_NAME,
												'W' SYS_KIND,
												'수질TMS' SYS_KIND_NAME		
<!-- 												인라인 쿼리시 속도가 너무 느림 -->
<!-- 												( -->
<!-- 												SELECT SYS_KIND_NAME  -->
<!-- 													FROM T_SYS_KIND  -->
<!-- 												 WHERE SYS_KIND =  'W' -->
<!-- 												) SYS_KIND_NAME -->
										  FROM WTMSC_HOUR_REAL@TMS A, 
												  WTMSC_ITEM@TMS B, 
												  WTMSC_FACT@TMS C,
												  WTMSC_FACT_WAST@TMS D,
												  WTMSC_AREA@TMS AREA
										 WHERE A.ITEM_CODE  = B.ITEM_CODE
												AND A.FACT_CODE  = C.FACT_CODE
												AND C.FACT_CODE = D.FACT_CODE
												AND A.WAST_NO = D.WAST_NO
												AND D.WAST_USED = 'Y'
												AND C.FACT_USED  = 'Y'
												AND AREA.CTY_CODE = C.CTY_CODE
												<isNotEqual prepend="AND" property="sugye" compareValue="all">
													AREA.DO_CODE = #sugye#
												</isNotEqual>
												<isNotEqual prepend="AND" property="gongku" compareValue="all">
													A.FACT_CODE = #gongku#
												</isNotEqual>
												<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
													A.WAST_NO = #chukjeongso#
												</isNotEqual>
												AND A.HOUR_TIME BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
										  )
								 GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
												MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
												RIVER_DIV,
												RIVER_NAME, SYS_KIND, SYS_KIND_NAME
								 ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
					) 
	</select>

	<statement id="getDischargeGraph_MIN" parameterClass="searchTaksuVO" resultClass="taksuVO">
				SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
							MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
							TO_CHAR(SUM(PHY), 'FM999,990.00') PHY,
							TO_CHAR(SUM(BOD), 'FM999,990.00') BOD,
							TO_CHAR(SUM(COD), 'FM999,990.00') COD,
							TO_CHAR(SUM(SUS), 'FM999,990.00') SUS,
							TO_CHAR(SUM(TOP), 'FM999,990.00') TOP,
							TO_CHAR(SUM(TON), 'FM999,990.00') TON,
							TO_CHAR(SUM(FLW), 'FM999,990') FLW,
							SUM(PHY_OR) PHY_OR,
							SUM(BOD_OR) BOD_OR,
							SUM(COD_OR) COD_OR,
							SUM(SUS_OR) SUS_OR,
							SUM(TOP_OR) TOP_OR,
							SUM(TON_OR) TON_OR,
							SUM(FLW_OR) FLW_OR,
							MAX(MINST) MINST, MAX(MINAB) MINAB, RIVER_DIV,
							RIVER_NAME, SYS_KIND, SYS_KIND_NAME
				  FROM (				
						SELECT A.ITEM_CODE AS ITEMCODE,
								B.ITEM_NAME AS ITEMNAME,
								A.FACT_CODE AS FACTCODE,
								C.FACT_NAME AS FACTNAME,
								A.WAST_NO	AS BRANCHNO,
								A.WAST_NO BRANCH_NAME,
								A.MIN_TIME  AS MINTIME ,
								TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
								TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
								A.MIN_RTIME AS MINRTIME,
								A.MIN_DUMP  AS MINDUMP ,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', MIN_VL) PHY,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', MIN_VL) BOD,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', MIN_VL) COD,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'SUS', MIN_VL) SUS,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', MIN_VL) TOP,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'TON', MIN_VL) TON,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', MIN_VL) FLW,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', MIN_OR) PHY_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', MIN_OR) BOD_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', MIN_OR) COD_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'SUS', MIN_OR) SUS_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', MIN_OR) TOP_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', MIN_OR) TON_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', MIN_OR) FLW_OR,
								A.MIN_ST	AS MINST	,
								A.MIN_AB	AS MINAB	,
								'R'||AREA.AREA_GBN AS RIVER_DIV,
								DECODE(AREA.AREA_GBN,'01','한강','02','낙동강','03','금강','04','영산강') AS RIVER_NAME,
								'W' SYS_KIND,
								'수질TMS' SYS_KIND_NAME		
<!-- 							인라인 쿼리시 속도가 너무 느림 -->
<!-- 								( -->
<!-- 								SELECT SYS_KIND_NAME  -->
<!-- 									FROM T_SYS_KIND  -->
<!-- 								 WHERE SYS_KIND =  'W' -->
<!-- 								) SYS_KIND_NAME -->
						  FROM WTMSC_MIN_REAL@TMS A, 
								  WTMSC_ITEM@TMS B, 
								  WTMSC_FACT@TMS C,
								  WTMSC_FACT_WAST@TMS D,
								  WTMSC_AREA@TMS AREA
						 WHERE A.ITEM_CODE  = B.ITEM_CODE
								AND A.FACT_CODE  = C.FACT_CODE
								AND C.FACT_CODE = D.FACT_CODE
								AND A.WAST_NO = D.WAST_NO
								AND D.WAST_USED = 'Y'
								AND C.FACT_USED  = 'Y'
								AND AREA.CTY_CODE = C.CTY_CODE
								<isNotEqual prepend="AND" property="sugye" compareValue="all">
									AREA.DO_CODE = #sugye#
								</isNotEqual>
								<isNotEqual prepend="AND" property="gongku" compareValue="all">
									A.FACT_CODE = #gongku#
								</isNotEqual>
								<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
									A.WAST_NO = #chukjeongso#
								</isNotEqual>
								<isNotEqual prepend="AND" property="item" compareValue="all">
					 SUBSTR(A.ITEM_CODE, 0, 3) = #item#
				 </isNotEqual>	
								AND A.MIN_TIME BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
						)
				 GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
								MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
								RIVER_DIV,
								RIVER_NAME, SYS_KIND, SYS_KIND_NAME
				 ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
	</statement>
	
	<statement id="getDischargeGraph_HOUR" parameterClass="searchTaksuVO" resultClass="taksuVO">
			SELECT FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
							MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
							TO_CHAR(SUM(PHY), 'FM999990.00') PHY,
							TO_CHAR(SUM(BOD), 'FM999990.00') BOD,
							TO_CHAR(SUM(COD), 'FM999990.00') COD,
							TO_CHAR(SUM(SUS), 'FM999990.00') SUS,
							TO_CHAR(SUM(TOP), 'FM999990.00') TOP,
							TO_CHAR(SUM(TON), 'FM999990.00') TON,
							TO_CHAR(SUM(FLW), 'FM999990') FLW,
							SUM(PHY_OR) PHY_OR,
							SUM(BOD_OR) BOD_OR,
							SUM(COD_OR) COD_OR,
							SUM(SUS_OR) SUS_OR,
							SUM(TOP_OR) TOP_OR,
							SUM(TON_OR) TON_OR,
							SUM(FLW_OR) FLW_OR,
							MAX(MINST) MINST, MAX(MINAB) MINAB, RIVER_DIV,
							RIVER_NAME, SYS_KIND, SYS_KIND_NAME
				  FROM (				
						SELECT A.ITEM_CODE AS ITEMCODE,
								B.ITEM_NAME AS ITEMNAME,
								A.FACT_CODE AS FACTCODE,
								C.FACT_NAME AS FACTNAME,
								A.WAST_NO	AS BRANCHNO,
								A.WAST_NO BRANCH_NAME,
								A.HOUR_TIME  AS MINTIME ,
								TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
								TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
								A.HOUR_RTIME AS MINRTIME,
								A.HOUR_DUMP  AS MINDUMP ,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', HOUR_VL) PHY,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_VL) BOD,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_VL) COD,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'SUS', HOUR_VL) SUS,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_VL) TOP,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3),'TON', HOUR_VL) TON,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_VL) FLW,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'PHY', HOUR_OR) PHY_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_OR) BOD_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_OR) COD_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'SUS', HOUR_OR) SUS_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_OR) TOP_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', HOUR_OR) TON_OR,
								DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_OR) FLW_OR,
								A.HOUR_ST	AS MINST	,
								A.HOUR_AB	AS MINAB	,
								'R'||AREA.AREA_GBN AS RIVER_DIV,
								DECODE(AREA.AREA_GBN,'01','한강','02','낙동강','03','금강','04','영산강') AS RIVER_NAME,
								'W' SYS_KIND,
								'수질TMS' SYS_KIND_NAME		
<!-- 							인라인 쿼리시 속도가 너무 느림 -->
<!-- 								( -->
<!-- 								 SELECT SYS_KIND_NAME  -->
<!-- 									FROM T_SYS_KIND  -->
<!-- 								  WHERE SYS_KIND =  'W' -->
<!-- 								) SYS_KIND_NAME -->
							FROM WTMSC_HOUR_REAL@TMS A, 
										WTMSC_ITEM@TMS B, 
										WTMSC_FACT@TMS C,
										WTMSC_FACT_WAST@TMS D,
										WTMSC_AREA@TMS AREA
						 WHERE A.ITEM_CODE  = B.ITEM_CODE
							AND A.FACT_CODE  = C.FACT_CODE
							AND C.FACT_CODE = D.FACT_CODE
							AND A.WAST_NO = D.WAST_NO
							AND D.WAST_USED = 'Y'
							AND C.FACT_USED  = 'Y'
							AND AREA.CTY_CODE = C.CTY_CODE
							<isNotEqual prepend="AND" property="sugye" compareValue="all">
								 AREA.DO_CODE = #sugye#
							</isNotEqual>
							<isNotEqual prepend="AND" property="gongku" compareValue="all">
								 A.FACT_CODE = #gongku#
							</isNotEqual>
							<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
								 A.WAST_NO = #chukjeongso#
							</isNotEqual>
							<isNotEqual prepend="AND" property="item" compareValue="all">
								 SUBSTR(A.ITEM_CODE, 0, 3) = #item#
							 </isNotEqual>					
							AND A.HOUR_TIME BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
						  )
				 GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
								MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
								RIVER_DIV,
								RIVER_NAME, SYS_KIND, SYS_KIND_NAME
				 ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
</statement>

	<statement id="getFlowData"  parameterClass="searchTaksuVO" resultClass="flowDataVO" >
		SELECT 
			 * 
			 FROM ( 
				 SELECT 
					 ROWNUM RNUM, T.*
					FROM
					(	
						SELECT
							  A.FWOBSCD AS FACT_CODE,
							  B.OBSNM AS FACT_NAME,
							  TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
							  TO_CHAR(A.FW, 'FM999,990.00') fw,
							  (
									SELECT 
										TO_CHAR(WL/100, 'FM999,990.00')
									FROM
										T_WLHR W1,
										T_WLOBSIF W2
									WHERE
										W2.ADM_CD = B.ADM_CD
										AND W1.WLOBSCD = W2.WLOBSCD
										AND A.YMDH = W1.YMDH
										and rownum = 1
							  ) WL
						  FROM T_FWHR A, 
								T_FWOBSIF B
						 WHERE 
								A.FWOBSCD  =  B.FWOBSCD
								AND B.EVTFG  = 'Y'
								<isNotEqual prepend="AND" property="gongku" compareValue="all">
								  A.FWOBSCD = #gongku#
								</isNotEqual>
								<isNotEqual prepend="AND" property="sugye" compareValue="all">
								  B.RIVER_DIV = #sugye#
								</isNotEqual>
								AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
						ORDER BY 
							 <isEqual property="orderby_time" compareValue="asc" >	
								 A.YMDH ASC
							</isEqual>
							<isNotEqual property="orderby_time" compareValue="asc" >
									A.YMDH DESC  
							</isNotEqual>
							, B.OBSNM ASC
					) T
			)
			WHERE
			<![CDATA[
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>	
	</statement>
	
	<statement id="getFlowData_cnt"  parameterClass="searchTaksuVO" resultClass="java.lang.Integer">
			SELECT 
					COUNT(*)
				FROM
				(
						SELECT
							  A.FWOBSCD AS FACT_CODE,
							  B.OBSNM AS FACT_NAME,
							  TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
							  TO_CHAR(A.FW, 'FM999,990.00') fw,
							  (
									SELECT 
										TO_CHAR(WL/100, 'FM999,990.00')
									FROM
										T_WLHR W1,
										T_WLOBSIF W2
									WHERE
										W2.ADM_CD = B.ADM_CD
										AND W1.WLOBSCD = W2.WLOBSCD
										AND A.YMDH = W1.YMDH
										and rownum = 1
							  ) WL
					 FROM T_FWHR A, 
						  T_FWOBSIF B
					 WHERE 
							A.FWOBSCD  =  B.FWOBSCD
							AND B.EVTFG  = 'Y'
							<isNotEqual prepend="AND" property="gongku" compareValue="all">
							  A.FWOBSCD = #gongku#
							</isNotEqual>
							<isNotEqual prepend="AND" property="sugye" compareValue="all">
								B.RIVER_DIV = #sugye#
							</isNotEqual>
							AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
				)
	</statement>


	<statement id="getFlowData_chartpopup"  parameterClass="searchTaksuVO" resultClass="flowDataVO" >
			 SELECT
					A.FWOBSCD AS FACT_CODE,
					B.OBSNM AS FACT_NAME,
					TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
					TO_CHAR(A.FW, 'FM999,990.00') FW,
					(
						 SELECT 
							 TO_CHAR(WL/100, 'FM999,990.00')
						  FROM
							 T_WLHR W1,
							 T_WLOBSIF W2
						  WHERE
							 W2.ADM_CD = B.ADM_CD
							 AND W1.WLOBSCD = W2.WLOBSCD
							 AND A.YMDH = W1.YMDH
							 and rownum = 1
					) WL
				FROM T_FWHR A, 
					T_FWOBSIF B
			  WHERE 
					A.FWOBSCD  =  B.FWOBSCD
					AND B.EVTFG  = 'Y'
					<isNotEqual prepend="AND" property="gongku" compareValue="all">
						A.FWOBSCD = #gongku#
					</isNotEqual>
					AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
			 ORDER BY	 
					  A.YMDH ASC, B.OBSNM ASC
	</statement>
	
	<statement id="getFlowData_chart"  parameterClass="searchTaksuVO" resultClass="flowDataVO" >
			SELECT
					A.FWOBSCD AS FACT_CODE,
					B.OBSNM AS FACT_NAME,
					TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
					TO_CHAR(A.FW, 'FM999,990.00') FW,
					(
						SELECT 
							TO_CHAR(WL/100, 'FM999,990.00')
						 FROM
							T_WLHR W1,
							WLOBSIF W2
						 WHERE
							W2.ADM_CD = B.ADM_CD
							AND W1.WLOBSCD = W2.WLOBSCD
							AND A.YMDH = W1.YMDH
							and rownum = 1
					) WL
			  FROM T_FWHR A, 
					T_FWOBSIF B
			 WHERE 
					A.FWOBSCD  =  B.FWOBSCD
					AND B.EVTFG  = 'Y'
					<isNotEqual prepend="AND" property="gongku" compareValue="all">
					  A.FWOBSCD = #gongku#
					</isNotEqual>
					AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
			ORDER BY 
					 A.YMDH ASC, B.OBSNM ASC
	</statement>
	
	
	<statement id="getFlowFactLocation" parameterClass="searchTaksuVO" resultClass="locationVO">
		SELECT 
			LAT latitude,
			LON longitude
		FROM
			T_FWOBSIF 
		WHERE
			FWOBSCD = #gongku# 
	</statement>



	<statement id="getWLData"  parameterClass="searchTaksuVO" resultClass="flowDataVO" >
		SELECT 
			 * 
			 FROM ( 
				 SELECT 
					 ROWNUM RNUM, T.*
					FROM
					(	
						SELECT
								A.WLOBSCD AS FACT_CODE,
								B.OBSNM AS FACT_NAME,
								TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
								TO_CHAR(A.WL/100, 'FM999,990') VALUE
						  FROM T_WLHR A, 
								T_WLOBSIF B
						 WHERE 
								A.WLOBSCD  =  B.WLOBSCD
								<isNotEqual prepend="AND" property="gongku" compareValue="all">
								  A.WLOBSCD = #gongku#
								</isNotEqual>
								AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
						ORDER BY 
							 <isEqual property="orderby_time" compareValue="asc" >	
								 A.YMDH ASC
							</isEqual>
							<isNotEqual property="orderby_time" compareValue="asc" >
									A.YMDH DESC  
							</isNotEqual>
							, B.OBSNM ASC
					) T
			)
			WHERE
			<![CDATA[
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>	
	</statement>
	
	<statement id="getWLData_cnt"  parameterClass="searchTaksuVO" resultClass="java.lang.Integer">
			SELECT 
					COUNT(*)
				FROM
				(
					SELECT
							A.WLOBSCD AS FACTCODE,
							B.OBSNM AS FACTNAME,
							TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCVDATE,
							A.WL VL
					FROM T_WLHR A,
						 T_WLOBSIF B
					 WHERE 
							A.WLOBSCD  =  B.WLOBSCD
							<isNotEqual prepend="AND" property="gongku" compareValue="all">
							A.WLOBSCD = #gongku#
							</isNotEqual>
							AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
				)
	</statement>


	<statement id="getWLData_chartpopup"  parameterClass="searchTaksuVO" resultClass="flowDataVO" >
			SELECT
					A.WLOBSCD AS FACT_CODE,
					B.OBSNM AS FACT_NAME,
					TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
					TO_CHAR(A.WL/100, 'FM999,990') VALUE
				FROM T_WLHR A, 
					T_WLOBSIF B
			WHERE 
					A.WLOBSCD  =  B.WLOBSCD
					<isNotEqual prepend="AND" property="gongku" compareValue="all">
						A.WLOBSCD = #gongku#
					</isNotEqual>
					AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
			ORDER BY A.YMDH ASC, B.OBSNM ASC
	</statement>
	
	<statement id="getWLData_chart"  parameterClass="searchTaksuVO" resultClass="flowDataVO" >
			SELECT
					A.WLOBSCD AS FACT_CODE,
					B.OBSNM AS FACT_NAME,
					TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
					TO_CHAR(A.WL/100, 'FM999,990') VALUE
			FROM T_WLHR A, 
					T_WLOBSIF B
			 WHERE 
					A.WLOBSCD  =  B.WLOBSCD
					<isNotEqual prepend="AND" property="gongku" compareValue="all">
					A.WLOBSCD = #gongku#
					</isNotEqual>
					AND  A.YMDH >=
					(
						SELECT SUBSTR(TO_CHAR(SYSDATE, 'YYYYMMDDHH24MI'), 0, 8)||'00' NOW 
						FROM DUAL
					)
			ORDER BY 
					 A.YMDH ASC, B.OBSNM ASC
	</statement>
	
	
	<statement id="getWLFactLocation" parameterClass="searchTaksuVO" resultClass="locationVO">
		SELECT 
			LAT latitude,
			LON longitude
		FROM
			T_WLOBSIF 
		WHERE
			WLOBSCD = #gongku# 
	</statement>


	<statement id="getAlgaCastList"  parameterClass="algaCastDataVO" resultClass="algaCastDataVO">
	SELECT 
			* 
			FROM ( 
				SELECT 
					ROWNUM RNUM, T.*
					FROM
					(
						SELECT
							ALGA_NO cast_num,
							TO_CHAR(TO_DATE(ALGA_SURV_DATE, 'YYYYMMDD') , 'YYYY/MM/DD')		survey_time,
							ALGA_SURV_POINT_1 survey_point,
							ALGA_SURV_NAME					name,
							ALGA_SURV_ORG					 org,
							TO_CHAR(TO_DATE(ALGA_ANLY_DATE, 'YYYYMMDD') , 'YYYY/MM/DD')		analysis_time,
							ALGA_ANLY_NAME analysis_name,
							ALGA_ANLY_POINT_1 analysis_point,
							DECODE(RIVER_DIV, 'R01', '한강', 'R02', '낙동강', 'R03', '금강', 'R04', '영산강') river_div,
							ALGA_TEMP_1					temp,
							ALGA_PH_1						ph,
							ALGA_CHLA_1					chla,
							ALGA_CYAN_1					cyan,
							ALGA_TEMP_2		temp2,
							ALGA_PH_2			ph2,
							ALGA_CHLA_2		chla2,
							ALGA_CYAN_2		cyan2,
							ATCH_FILE					alga_file
						FROM 
							T_ALGA_FCAST
						WHERE
							ALGA_ANLY_DATE BETWEEN TO_DATE(#search_date_start#||'0000', 'YYYYMMDDHH24MI') AND TO_DATE(#search_date_end#||'2359', 'YYYYMMDDHH24MI')
							AND RCD_STATE != 'D'
						<isNotEqual prepend="AND" property='river_div' compareValue='all'>
							RIVER_DIV = #river_div#
						</isNotEqual>
						ORDER BY ALGA_SURV_DATE DESC, ALGA_NO DESC
						) T
		)
		WHERE
		<![CDATA[  
			RNUM  > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>				
	</statement>
	
	<statement id="getAlgaCastList_cnt"  parameterClass="algaCastDataVO" resultClass="java.lang.Integer">
			SELECT 
				COUNT(*)
				FROM
				(
				SELECT
							ALGA_NO cast_num,
							TO_CHAR(TO_DATE(ALGA_SURV_DATE, 'YYYYMMDD') , 'YYYY/MM/DD')		survey_time,
							ALGA_SURV_POINT_1 survey_point,
							ALGA_SURV_NAME					name,
							ALGA_SURV_ORG					 org,
							TO_CHAR(TO_DATE(ALGA_ANLY_DATE, 'YYYYMMDD') , 'YYYY/MM/DD')		analysis_time,
							ALGA_ANLY_NAME analysis_name,
							ALGA_ANLY_POINT_1 analysis_point,
							DECODE(RIVER_DIV, 'R01', '한강', 'R02', '낙동강', 'R03', '금강', 'R04', '영산강') river_div,
							ALGA_TEMP_1					temp,
							ALGA_PH_1						ph,
							ALGA_CHLA_1					chla,
							ALGA_CYAN_1					cyan,
							ALGA_TEMP_2		temp2,
							ALGA_PH_2			ph2,
							ALGA_CHLA_2		chla2,
							ALGA_CYAN_2		cyan2,
							ATCH_FILE					alga_file
				FROM 
					T_ALGA_FCAST
				WHERE
					ALGA_ANLY_DATE BETWEEN TO_DATE(#search_date_start#||'0000', 'YYYYMMDDHH24MI') AND TO_DATE(#search_date_end#||'2359', 'YYYYMMDDHH24MI')
					AND RCD_STATE != 'D'
				<isNotEqual prepend="AND" property='river_div' compareValue='all'>
					RIVER_DIV = #river_div#
				</isNotEqual>
				ORDER BY ALGA_ANLY_DATE DESC
				)
	</statement>
	
	<statement id="getAlgaCastFirst" resultClass="algaCastDataVO" parameterClass="HashMap">
		SELECT
			*
		FROM 
		(
			SELECT
				ALGA_NO						cast_num,
				TO_CHAR(TO_DATE(ALGA_SURV_DATE, 'YYYYMMDD') , 'YYYY/MM/DD') survey_time,
				ALGA_SURV_POINT_1			survey_point,
				DECODE(RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS river_div,
				ALGA_ANLY_DATE				analysis_time,
				ALGA_TEMP_1					temp,
				ALGA_PH_1					ph,
				ALGA_CHLA_1					chla,
				ALGA_CYAN_1					cyan
			FROM 
				T_ALGA_FCAST
			WHERE
				RCD_STATE != 'D'
				 AND ALGA_ANLY_DATE >=
					( 
					 SELECT TO_CHAR(SYSDATE, 'YYYYMMDD') NOW 
						FROM DUAL
					)
				<isNotEqual prepend="AND" property='river_div' compareValue='all'>
					RIVER_DIV = #river_div#
				</isNotEqual>
			ORDER BY ALGA_SURV_DATE DESC, ALGA_NO DESC
		)
		WHERE 
		<![CDATA[
			ROWNUM <= 1
		]]>
	</statement>
	
	<statement id="getAlgaCast" parameterClass="String" resultClass="algaCastDataVO">
		SELECT
			ALGA_NO cast_num,
			RIVER_DIV			river_div,
			TO_CHAR(TO_DATE(ALGA_SURV_DATE, 'YYYYMMDD') , 'YYYY/MM/DD')		survey_time,
			ALGA_SURV_POINT_1 survey_point,
			ALGA_SURV_NAME				name,
			ALGA_SURV_ORG					org,
			TO_CHAR(TO_DATE(ALGA_ANLY_DATE, 'YYYYMMDD') , 'YYYY/MM/DD')	analysis_time,
			ALGA_ANLY_NAME analysis_name,
			ALGA_ANLY_POINT_1 analysis_point,
			ALGA_TEMP_1					temp,
			ALGA_PH_1						ph,
			ALGA_CHLA_1					chla,
			ALGA_CYAN_1					cyan,
			ALGA_TEMP_2		temp2,
			ALGA_PH_2			ph2,
			ALGA_CHLA_2		chla2,
			ALGA_CYAN_2		cyan2,
			ATCH_FILE					alga_file
		FROM 
			T_ALGA_FCAST
		WHERE
			RCD_STATE != 'D'
			AND ALGA_NO = #cast_num#
	</statement>
	
	<update id="deleteAlgaCast" parameterClass="String">
		<![CDATA[
			UPDATE
				T_ALGA_FCAST
			SET 
				RCD_STATE = 'D'
			WHERE 
				ALGA_NO = #cast_num#
		]]>
	</update>
	
	<update id="updateAlgaCast" parameterClass="algaCastDataVO">
<![CDATA[
			UPDATE
				T_ALGA_FCAST
			SET 
				RIVER_DIV			= #river_div#,
				ALGA_SURV_DATE		= #survey_time#,
				ALGA_SURV_POINT_1	= #survey_point#,
				ALGA_SURV_NAME		= #name#,
				ALGA_SURV_ORG		= #org#,
				ALGA_ANLY_DATE		= #analysis_time#,
				ALGA_ANLY_NAME		= #analysis_name#,
				ALGA_ANLY_POINT_1 	= #analysis_point#,
				ALGA_TEMP_1			= #temp#,
				ALGA_PH_1			= #ph#,
				ALGA_CHLA_1			= #chla#,
				ALGA_CYAN_1			= #cyan#,
				ALGA_TEMP_2			= #temp2#,
				ALGA_PH_2			= #ph2#,
				ALGA_CHLA_2			= #chla2#,
				ALGA_CYAN_2			= #cyan2#,
				RCD_STATE 			= 'U',
				MOD_DATE			= (SELECT CURRENT_DATE FROM DUAL)
			WHERE 
				ALGA_NO = #cast_num#
		]]>
</update>
	
	
	<statement id="getAirMntList"  parameterClass="airMntDataVO" resultClass="airMntDataVO">
		SELECT 
			* 
			FROM ( 
				SELECT 
					ROWNUM RNUM, T.*
					FROM
					(
						SELECT
								AVIA_NO					obv_num,
								AVIA_PLANE					plane,
								TO_CHAR(TO_DATE(AVIA_FLT_DATE, 'YYYYMMDD') , 'YYYY/MM/DD')		flight_date,
								AVIA_FLT_SECT fly_section,
								AVIA_LAND_CNT			land_cnt,
								AVIA_TKO_TIME		start_time,
								AVIA_ARV_TIME			reach_time,
								AVIA_FLT_TIME		flight_time,
								AVIA_PILOT					pilot,
								AVIA_PGR					rider,
								AVIA_NOTE					note,
								AVIA_WEATHER				weather,
								AVIA_SUNRISE				sunrise,
								AVIA_SUNSET				sunset,
								AVIA_FCAST			forecast,
								AVIA_WEATHER_TIME_1	weather_time1,
								AVIA_WIND_1					wind1,
								AVIA_SIGHT_1				sight1,
								AVIA_CLOUD_1				cloud1,
								AVIA_WEATHER_TIME_2	weather_time2,
								AVIA_WIND_2					wind2,
								AVIA_SIGHT_2				sight2,
								AVIA_CLOUD_2				cloud2,
								AVIA_WEATHER_TIME_3	weather_time3,
								AVIA_WIND_3					wind3,
								AVIA_SIGHT_3				sight3,
								AVIA_CLOUD_3				cloud3,
								AVIA_WEATHER_TIME_4	weather_time4,
								AVIA_WIND_4					wind4,
								AVIA_SIGHT_4				sight4,
								AVIA_CLOUD_4				cloud4,
								AVIA_RESULT_1				result1,
								AVIA_RESULT_2				result2,
								AVIA_RESULT_3				result3,
								AVIA_RESULT_4				result4,
								AVIA_RESULT_5				result5,		
								AVIA_RESULT_6				result6,
								AVIA_RESULT_7				result7,
								AVIA_RESULT_8				result8,
								AVIA_RESULT_9				result9,
								AVIA_RESULT_10			result10,
								AVIA_RESULT_11			result11,
								DECODE(RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS sugye,
								ATCH_FILE					obv_file
							FROM 
								T_AVIA_OBV
							WHERE
								AVIA_FLT_DATE BETWEEN TO_DATE(#search_date_start#||'0000', 'YYYYMMDDHH24MI') AND TO_DATE(#search_date_end#||'2359', 'YYYYMMDDHH24MI')
								AND RCD_STATE != 'D'
							<isNotEqual prepend="AND" property='sugye' compareValue='all'>
								RIVER_DIV = #sugye#
							</isNotEqual>
							ORDER BY AVIA_FLT_DATE DESC
							) T
			)
			WHERE
			<![CDATA[  
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>				
	</statement>
	
	<statement id="getAirMntList_cnt"  parameterClass="airMntDataVO" resultClass="java.lang.Integer">
			SELECT 
				count(*)
				FROM
				(
				SELECT
						AVIA_NO					obv_num,
						AVIA_PLANE					plane,
						TO_CHAR(TO_DATE(AVIA_FLT_DATE, 'YYYYMMDD') , 'YYYY/MM/DD')		flight_date,
						AVIA_FLT_SECT fly_section,
						AVIA_LAND_CNT			land_cnt,
						AVIA_TKO_TIME		start_time,
						AVIA_ARV_TIME			reach_time,
						AVIA_FLT_TIME		flight_time,
						AVIA_PILOT					pilot,
						AVIA_PGR					rider,
						AVIA_NOTE					note,
						AVIA_WEATHER				weather,
						AVIA_SUNRISE				sunrise,
						AVIA_SUNSET				sunset,
						AVIA_FCAST			forecast,
						AVIA_WEATHER_TIME_1	weather_time1,
						AVIA_WIND_1					wind1,
						AVIA_SIGHT_1				sight1,
						AVIA_CLOUD_1				cloud1,
						AVIA_WEATHER_TIME_2	weather_time2,
						AVIA_WIND_2					wind2,
						AVIA_SIGHT_2				sight2,
						AVIA_CLOUD_2				cloud2,
						AVIA_WEATHER_TIME_3	weather_time3,
						AVIA_WIND_3					wind3,
						AVIA_SIGHT_3				sight3,
						AVIA_CLOUD_3				cloud3,
						AVIA_WEATHER_TIME_4	weather_time4,
						AVIA_WIND_4					wind4,
						AVIA_SIGHT_4				sight4,
						AVIA_CLOUD_4				cloud4,
						AVIA_RESULT_1				result1,
						AVIA_RESULT_2				result2,
						AVIA_RESULT_3				result3,
						AVIA_RESULT_4				result4,
						AVIA_RESULT_5				result5,		
						AVIA_RESULT_6				result6,
						AVIA_RESULT_7				result7,
						AVIA_RESULT_8				result8,
						AVIA_RESULT_9				result9,
						AVIA_RESULT_10			result10,
						AVIA_RESULT_11			result11,
						DECODE(RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS sugye,
						ATCH_FILE					obv_file
					FROM 
						T_AVIA_OBV
					WHERE
						AVIA_FLT_DATE BETWEEN TO_DATE(#search_date_start#||'0000', 'YYYYMMDDHH24MI') AND TO_DATE(#search_date_end#||'2359', 'YYYYMMDDHH24MI')
						AND RCD_STATE != 'D'
					<isNotEqual prepend="AND" property='sugye' compareValue='all'>
						RIVER_DIV = #sugye#
					</isNotEqual>
					ORDER BY AVIA_FLT_DATE DESC
					)
	</statement>
	
	<statement id="getAirMnt"  parameterClass="String" resultClass="airMntDataVO">
		SELECT
			AVIA_NO						obv_num,
			AVIA_PLANE					plane,
			TO_CHAR(TO_DATE(AVIA_FLT_DATE, 'YYYYMMDD'), 'YYYY/MM/DD')		flight_date,
			AVIA_FLT_SECT				 fly_section,
			AVIA_LAND_CNT				land_cnt,
			AVIA_TKO_TIME				start_time,
			AVIA_ARV_TIME				reach_time,
			AVIA_FLT_TIME				flight_time,
			AVIA_PILOT					pilot,
			AVIA_PGR					rider,
			AVIA_NOTE					note,
			AVIA_WEATHER				weather,
			AVIA_SUNRISE				sunrise,
			AVIA_SUNSET					sunset,
			AVIA_FCAST					forecast,
			AVIA_WEATHER_TIME_1			weather_time1,
			AVIA_WIND_1					wind1,
			AVIA_SIGHT_1				sight1,
			AVIA_CLOUD_1				cloud1,
			AVIA_WEATHER_TIME_2			weather_time2,
			AVIA_WIND_2					wind2,
			AVIA_SIGHT_2				sight2,
			AVIA_CLOUD_2				cloud2,
			AVIA_WEATHER_TIME_3			weather_time3,
			AVIA_WIND_3					wind3,
			AVIA_SIGHT_3				sight3,
			AVIA_CLOUD_3				cloud3,
			AVIA_WEATHER_TIME_4			weather_time4,
			AVIA_WIND_4					wind4,
			AVIA_SIGHT_4				sight4,
			AVIA_CLOUD_4				cloud4,
			AVIA_RESULT_1				result1,
			AVIA_RESULT_2				result2,
			AVIA_RESULT_3				result3,
			AVIA_RESULT_4				result4,
			AVIA_RESULT_5				result5,
			AVIA_RESULT_6				result6,
			AVIA_RESULT_7				result7,
			AVIA_RESULT_8				result8,
			AVIA_RESULT_9				result9,
			AVIA_RESULT_10				result10,
			AVIA_RESULT_11				result11,
			DECODE(RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS sugye,
			ATCH_FILE					obv_file
		FROM 
			T_AVIA_OBV
		WHERE
			RCD_STATE != 'D'
			AND AVIA_NO = #obv_num#
	</statement>
	
	<statement id="getAirMntFirst"  resultClass="airMntDataVO" parameterClass="HashMap">
		SELECT 
			*
		FROM
			(
			SELECT
				AVIA_NO						obv_num,
				AVIA_PLANE					plane,
				AVIA_FLT_SECT				fly_section,
				AVIA_NOTE					note,
				DECODE(RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS sugye
			FROM 
				T_AVIA_OBV
			WHERE
				RCD_STATE != 'D'
				AND AVIA_FLT_DATE >=
					( 
					 SELECT TO_CHAR(SYSDATE, 'YYYYMMDD') NOW 
						FROM DUAL
					)
				<isNotEqual prepend="AND" property='sugye' compareValue='all'>
					RIVER_DIV = #sugye#
				</isNotEqual>
			ORDER BY AVIA_FLT_DATE DESC
			)
		WHERE 
		<![CDATA[
			ROWNUM <= 1
		]]>
	</statement>
	
	<update id="deleteAirMnt" parameterClass="String">
		<![CDATA[
			UPDATE
				T_AVIA_OBV
			SET 
				RCD_STATE = 'D'
			WHERE 
				AVIA_NO = #obv_num#
		]]>
	</update>
	
	<update id="updateAirMnt" parameterClass="airMntDataVO">
		<![CDATA[
			UPDATE
				T_AVIA_OBV
			SET 
				AVIA_NO				=#obv_num#,
				AVIA_PLANE			=#plane#,
				AVIA_FLT_DATE		=#flight_date#,
				AVIA_FLT_SECT		=#fly_section#,
				AVIA_LAND_CNT		=#land_cnt#,
				AVIA_TKO_TIME		=#start_time#,
				AVIA_ARV_TIME		=#reach_time#,
				AVIA_FLT_TIME		=#flight_time#,
				AVIA_PILOT			=#pilot#,
				AVIA_PGR			=#rider#,
				AVIA_NOTE			=#note#,
				AVIA_WEATHER		=#weather#,
				AVIA_SUNRISE		=#sunrise#,
				AVIA_SUNSET			=#sunset#,
				AVIA_FCAST			=#forecast#,
				AVIA_WEATHER_TIME_1	=#weather_time1#,
				AVIA_WIND_1			=#wind1#,
				AVIA_SIGHT_1		=#sight1#,
				AVIA_CLOUD_1		=#cloud1#,
				AVIA_WEATHER_TIME_2	=#weather_time2#,
				AVIA_WIND_2			=#wind2#,
				AVIA_SIGHT_2		=#sight2#,
				AVIA_CLOUD_2		=#cloud2#,
				AVIA_WEATHER_TIME_3	=#weather_time3#,
				AVIA_WIND_3			=#wind3#,
				AVIA_SIGHT_3		=#sight3#,
				AVIA_CLOUD_3		=#cloud3#,
				AVIA_WEATHER_TIME_4	=#weather_time4#,
				AVIA_WIND_4			=#wind4#,
				AVIA_SIGHT_4		=#sight4#,
				AVIA_CLOUD_4		=#cloud4#,
				AVIA_RESULT_1		=#result1#,
				AVIA_RESULT_2		=#result2#,
				AVIA_RESULT_3		=#result3#,
				AVIA_RESULT_4		=#result4#,
				AVIA_RESULT_5		=#result5#,
				AVIA_RESULT_6		=#result6#,
				AVIA_RESULT_7		=#result7#,
				AVIA_RESULT_8		=#result8#,
				AVIA_RESULT_9		=#result9#,
				AVIA_RESULT_10		=#result10#,
				AVIA_RESULT_11		=#result11#,
				RIVER_DIV			=#sugye#,
				ATCH_FILE			=#obv_file#,
				RCD_STATE ='U',
				MOD_DATE = (SELECT CURRENT_DATE FROM DUAL)
			WHERE 
				AVIA_NO = #obv_num#
		]]>
	</update>

	<statement id="getRiverWarning_cnt_OLD" parameterClass="riverWater3HourWarningSearchVO" resultClass="java.lang.Integer" remapResults="true">
			SELECT 
					COUNT(*)
			FROM
			(
					SELECT D1.RIVER_DIV, 
								D2.COMMON_CODE_NAME AS RIVER_NAME,
								D1.FACT_CODE FACT_CODE,
								D1.FACT_NAME FACT_NAME,
								B1.BRANCH_NAME||'-'||B1.BRANCH_NO BRANCH_NAME,
								<isNotEqual property="sys_kind" compareValue="U">
								TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') - (1/24)*3, 'YYYY/MM/DD HH24:MI') START_TIME,
								TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') - ((1/24)*3) + ((1/24)*#periodTime#), 'YYYY/MM/DD HH24:MI') LAST_TIME,
								</isNotEqual>
								<isEqual property="sys_kind" compareValue="U">
								TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI'), 'YYYY/MM/DD HH24:MI') START_TIME,
								TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') + ((30/60/24)*(F1.ACCT_CNT-1)), 'YYYY/MM/DD HH24:MI') LAST_TIME,
								</isEqual>
								ITEM_CODE,
								(SELECT ITEM_NAME FROM T_ITEM_INFO WHERE F1.ITEM_CODE = ITEM_CODE) ITEM_NAME,
								(SELECT MIN_VL	
								  FROM T_MIN_DATA 
								WHERE F1.FACT_CODE = FACT_CODE
									AND F1.ITEM_CODE = ITEM_CODE
									AND F1.ACCT_ACT_TIME = MIN_TIME) MIN_VL
					  FROM T_IW_HIS F1,
							T_FACT_INFO D1,
							T_FACT_BRANCH B1,
							T_COMMON_CODE D2
					WHERE F1.FACT_CODE = D1.FACT_CODE
						<isNotEqual property="sys_kind" compareValue="U">
						AND F1.ACCT_CNT = #alertTime#
						</isNotEqual>
						AND D2.COMMON_CODE_CATEGORY = '01'
						AND F1.DEL_YN = 'N'
						AND F1.RIVER_DIV = D2.COMMON_CODE
						AND F1.FACT_CODE = B1.FACT_CODE
						AND F1.BRANCH_NO = B1.BRANCH_NO
						<isNotEqual prepend="AND" property="river_div" compareValue="all">
						D1.RIVER_DIV = #river_div#
						</isNotEqual>
						<isNotEqual prepend="AND" property="fact_code" compareValue="all">
						F1.FACT_CODE = #fact_code#
						</isNotEqual>
						<isNotEqual prepend="AND" property="branch_no" compareValue="all">
						F1.BRANCH_NO = #branch_no#
						</isNotEqual>
						<isNotEqual prepend="AND" property="sys_kind" compareValue="all">
						D1.SYS_KIND  = #sys_kind#
						</isNotEqual>
						AND F1.ACCT_ACT_TIME BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
						AND F1.ACCT_KIND IN ('U', 'B')
						AND F1.ITEM_TYPE IS NULL
			)
	</statement>
	
	<statement id="getRiverWater3HourWarning_OLD" parameterClass="riverWater3HourWarningSearchVO" resultClass="riverWater3HourWarningVO" remapResults="true">
	SELECT 
			* 
			FROM ( 
				SELECT 
					ROWNUM RNUM, T.*
					FROM
					(
							SELECT D1.RIVER_DIV, 
										D2.COMMON_CODE_NAME AS RIVER_NAME,
										D1.FACT_NAME FACT_NAME,
										B1.BRANCH_NAME||'-'||B1.BRANCH_NO BRANCH_NAME,
										F1.BRANCH_NO BRANCH_NO,
										F1.IW_NO AS_ID,
										D1.FACT_CODE FACT_CODE,
										<isNotEqual property="sys_kind" compareValue="U">
										TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') - (1/24)*3, 'YYYY/MM/DD HH24:MI') START_TIME,
										TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') - ((1/24)*3) + ((1/24)*#periodTime#), 'YYYY/MM/DD HH24:MI') LAST_TIME,
										</isNotEqual>
										<isEqual property="sys_kind" compareValue="U">
										TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI'), 'YYYY/MM/DD HH24:MI') START_TIME,
										TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') + ((30/60/24)*(F1.ACCT_CNT-1)), 'YYYY/MM/DD HH24:MI') LAST_TIME,
										</isEqual>
										ITEM_CODE,
										(SELECT ITEM_NAME FROM T_ITEM_INFO WHERE F1.ITEM_CODE = ITEM_CODE) ITEM_NAME,
										MIN_VL MIN_VL,
									  SYS_KIND SYS_KIND,
									 (
										  SELECT SYS_KIND_NAME 
										 FROM T_SYS_KIND 
										  WHERE SYS_KIND =  D1.SYS_KIND
									  ) SYS_KIND_NAME
							  FROM T_IW_HIS F1,
									  T_FACT_INFO D1,
									  T_FACT_BRANCH B1,
									  T_COMMON_CODE D2
							WHERE F1.FACT_CODE = D1.FACT_CODE
								<isNotEqual property="sys_kind" compareValue="U">
								AND F1.ACCT_CNT = #alertTime#
								</isNotEqual>
								AND D2.COMMON_CODE_CATEGORY = '01'
								AND F1.RIVER_DIV = D2.COMMON_CODE
								AND F1.FACT_CODE = B1.FACT_CODE
								AND F1.DEL_YN = 'N'
								AND F1.BRANCH_NO = B1.BRANCH_NO
								<isNotEqual prepend="AND" property="river_div" compareValue="all">
								D1.RIVER_DIV = #river_div#
								</isNotEqual>
								<isNotEqual prepend="AND" property="fact_code" compareValue="all">
								F1.FACT_CODE = #fact_code#
								</isNotEqual>
								<isNotEqual prepend="AND" property="branch_no" compareValue="all">
								F1.BRANCH_NO = #branch_no#
								</isNotEqual>
								<isNotEqual prepend="AND" property="sys_kind" compareValue="all">
								D1.SYS_KIND  = #sys_kind#
								</isNotEqual>
								AND F1.MIN_TIME BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
								AND F1.ACCT_KIND IN ('U', 'B')
								AND F1.ITEM_TYPE IS NULL
							ORDER BY LAST_TIME DESC
					) T
			)
			WHERE
			<![CDATA[
				RNUM > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage# 
			]]>
	</statement>
	
	<statement id="getChartWarning"  parameterClass="riverWater3HourWarningSearchVO" resultClass="riverWater3HourWarningVO" remapResults="true">
			SELECT D1.RIVER_DIV, 
						D2.COMMON_CODE_NAME AS RIVER_NAME,
						D1.FACT_CODE FACT_CODE,
						D2.COMMON_CODE_NAME AS RIVER_NAME,
						D1.FACT_NAME FACT_NAME,
						B1.BRANCH_NAME||'-'||B1.BRANCH_NO BRANCH_NAME,
						F1.BRANCH_NO BRANCH_NO,
						<isNotEqual property="sys_kind" compareValue="U">
						TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') - (1/24)*3, 'YYYY/MM/DD HH24:MI') START_TIME,
						TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') - ((1/24)*3) + ((1/24)*#periodTime#), 'YYYY/MM/DD HH24:MI') LAST_TIME,
						</isNotEqual>
						<isEqual property="sys_kind" compareValue="U">
						TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI'), 'YYYY/MM/DD HH24:MI') START_TIME,
						TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') + ((30/60/24)*(F1.ACCT_CNT-1)), 'YYYY/MM/DD HH24:MI') LAST_TIME,
						</isEqual>
						ITEM_CODE,
						(SELECT ITEM_NAME FROM T_ITEM_INFO WHERE F1.ITEM_CODE = ITEM_CODE) ITEM_NAME,
						MIN_VL MIN_VL,			
						SYS_KIND SYS_KIND,
						(
							SELECT SYS_KIND_NAME 
							FROM T_SYS_KIND 
							WHERE SYS_KIND =  D1.SYS_KIND
						) SYS_KIND_NAME		
			  FROM T_IW_HIS F1,
					T_FACT_INFO D1,
					T_FACT_BRANCH B1,
					T_COMMON_CODE D2
			WHERE F1.FACT_CODE = D1.FACT_CODE
				<isNotEqual property="sys_kind" compareValue="U">
				AND F1.ACCT_CNT = #alertTime#
				</isNotEqual>
				AND D2.COMMON_CODE_CATEGORY = '01'
				AND F1.DEL_YN = 'N'
				AND F1.RIVER_DIV = D2.COMMON_CODE
				AND F1.FACT_CODE = B1.FACT_CODE
				AND F1.BRANCH_NO = B1.BRANCH_NO
				<isNotEqual prepend="AND" property="river_div" compareValue="all">
				D1.RIVER_DIV = #river_div#
				</isNotEqual>
				<isNotEqual prepend="AND" property="fact_code" compareValue="all">
				F1.FACT_CODE = #fact_code#
				</isNotEqual>
				<isNotEqual prepend="AND" property="branch_no" compareValue="all">
				F1.BRANCH_NO = #branch_no#
				</isNotEqual>
				<isNotEqual prepend="AND" property="sys_kind" compareValue="all">
				D1.SYS_KIND  = #sys_kind#
				</isNotEqual>
				AND F1.MIN_TIME BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
				AND F1.ACCT_KIND IN ('U', 'B')
				AND F1.ITEM_TYPE IS NULL
			ORDER BY MIN_TIME ASC
	</statement>	
	
		<statement id="getRiverWater3HourWarningPopDetail" parameterClass="riverWater3HourWarningSearchVO" resultClass="riverWater3HourWarningVO">
		  SELECT 
				SUBSTR(D2.MIN_TIME, 0, 4)||'/'||SUBSTR(D2.MIN_TIME, 5, 2)||'/'||
				SUBSTR(D2.MIN_TIME, 7, 2)||' '||
				SUBSTR(D2.MIN_TIME, 9, 2)||':'||SUBSTR(D2.MIN_TIME, 11, 2) MIN_TIME,
				D2.ITEM_CODE,
				(SELECT ITEM_NAME FROM T_ITEM_INFO WHERE D2.ITEM_CODE = ITEM_CODE) ITEM_NAME,
				D2.MIN_VL,
				( SELECT ITEM_NAME FROM T_ITEM_INFO TTI WHERE TTI.ITEM_CODE = F1.EXECES_ITEM_CODE ) itemName2,
				( SELECT ITEM_NAME FROM T_ITEM_INFO TTI WHERE TTI.ITEM_CODE = F1.EXECES_ITEM_CODE2 ) itemName3,
				F1.EXECES_ITEM_CODE itemCode2,
				F1.EXECES_ITEM_CODE2 itemCode3, 
				TO_CHAR(F1.EXECES_MIN_VL, 'FM999999990.00') as minVl2,
				TO_CHAR(F1.EXECES_MIN_VL2, 'FM999999990.00') as minVl3,  
				D3.BRANCH_NAME,
				F1.MIN_OR MIN_OR,
				DECODE(F1.MIN_OR, '0', '정상', '1', '관심', '2', '주의', '3', '경계', '4', '심각') MIN_OR_NAME
		  FROM T_IW_HIS F1,
				  T_MIN_DATA D2,
				  T_FACT_BRANCH_INFO D3
			WHERE F1.FACT_CODE	 = D2.FACT_CODE
				AND F1.ITEM_CODE	 = D2.ITEM_CODE
				AND F1.BRANCH_NO	 = D2.BRANCH_NO
				AND F1.DEL_YN = 'N'
				AND F1.IW_NO = #as_id#
				<isEqual property="sys_kind" compareValue="U">
			  AND D2.MIN_TIME 
						BETWEEN 
							TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI'), 'YYYYMMDDHH24MI')
								AND 
							 TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') + ((30/60/24)*(F1.ACCT_CNT-1)), 'YYYYMMDDHH24MI')
				</isEqual>
				<isNotEqual property="sys_kind" compareValue="U">
				AND D2.MIN_TIME 
						BETWEEN 
							TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') - (1/24)*3, 'YYYYMMDDHH24MI')
								AND 
							 TO_CHAR(TO_DATE(F1.MIN_TIME, 'YYYYMMDDHH24MI') - ((1/24)*3) + ((1/24)*#alertTime#), 'YYYYMMDDHH24MI')
				</isNotEqual>
				AND F1.ACCT_KIND IN ('U', 'B')
				AND F1.ITEM_TYPE IS NULL
				AND F1.FACT_CODE = D3.FACT_CODE
				AND F1.BRANCH_NO = D3.BRANCH_NO
			<isNotEqual property="orderBy" compareValue="ASC">
				ORDER BY MIN_TIME DESC
			</isNotEqual>
			<isEqual property="orderBy" compareValue="ASC">
				ORDER BY MIN_TIME ASC
			</isEqual>
	</statement>
	
	
	<insert id="insertValidData" parameterClass="detailViewVO">
		INSERT INTO T_MIN_DATA(FACT_CODE, ITEM_CODE, MIN_TIME, MIN_RTIME, MIN_DUMP, MIN_VL, MIN_OR, MIN_ST, MIN_DCD, BRANCH_NO, VALID_FLAG)
		VALUES(
			#factcode#,
			#itemcode#,
			#mintime#,
			#minrtime#,
			'0',
			#minvl#,
			'0',
			'0',
			'0',
			'1',
			'Y'
		)
	</insert>
	
	<statement id="getValidItemSeq" parameterClass="searchTaksuVO" resultClass="java.lang.String">
		SELECT
			ITEM_CODE
		FROM
			T_VALID_ITEM_SEQ
		WHERE
			FACT_CODE = #gongku#
		ORDER BY ITEM_SEQ ASC
	</statement>
	
	<statement id="getDamFact" parameterClass="HashMap" resultClass="HashMap">
		SELECT OBSNM AS CAPTION, DMOBSCD AS VALUE
			FROM T_DMOBSIF
		<isNotEqual property="sugye" compareValue="all">
		WHERE
			RIVER_DIV = #sugye#
		</isNotEqual>
		ORDER BY OBSNM ASC
	</statement>
	
	<statement id="getDamData"  parameterClass="searchTaksuVO" resultClass="damDataVO" >
		SELECT 
			 * 
			 FROM ( 
				 SELECT 
					 ROWNUM RNUM, T.*
					FROM
					(	
						SELECT
								A.DMOBSCD AS FACT_CODE,
								B.OBSNM AS FACT_NAME,
								TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
								TO_CHAR(A.SWL/100, 'FM999,990') SWL,
								TO_CHAR(A.OTF, 'FM999,990.00') SFW
						  FROM T_DMHR A, 
								T_DMOBSIF B
						 WHERE 
								A.DMOBSCD  =  B.DMOBSCD
								<isNotEqual prepend="AND" property="gongku" compareValue="all">
								  A.DMOBSCD = #gongku#
								</isNotEqual>
								<isNotEqual prepend="AND" property="sugye" compareValue="all">
								  B.RIVER_DIV = #sugye#
								</isNotEqual>
								AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
						ORDER BY 
							 <isEqual property="orderby_time" compareValue="asc" >	
								 A.YMDH ASC
							</isEqual>
							<isNotEqual property="orderby_time" compareValue="asc" >
									A.YMDH DESC  
							</isNotEqual>
							, B.OBSNM ASC
					) T
			)
			WHERE
			<![CDATA[
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>	
	</statement>
	
	<statement id="getDamData_cnt"  parameterClass="searchTaksuVO" resultClass="java.lang.Integer">
			SELECT 
					COUNT(*)
				FROM
				(
					SELECT
							A.DMOBSCD AS FACTCODE,
							B.OBSNM AS FACTNAME,
							TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCVDATE,
							A.SWL/100 SWL,
							A.OTF SFW
					 FROM T_DMHR A, 
						  T_DMOBSIF B
					 WHERE 
							A.DMOBSCD  =  B.DMOBSCD
							<isNotEqual prepend="AND" property="gongku" compareValue="all">
							  A.DMOBSCD = #gongku#
							</isNotEqual>
							<isNotEqual prepend="AND" property="sugye" compareValue="all">
								B.RIVER_DIV = #sugye#
							</isNotEqual>
							AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
				)
	</statement>

	<statement id="getDamData_chartpopup"  parameterClass="searchTaksuVO" resultClass="damDataVO" >
			 SELECT
					A.DMOBSCD AS FACT_CODE,
					B.OBSNM AS FACT_NAME,
					TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
					TO_CHAR(A.SWL/100, 'FM999990') SWL,
					TO_CHAR(A.OTF, 'FM999990.00') SFW
				FROM T_DMHR A, 
					T_DMOBSIF B
			  WHERE 
					A.DMOBSCD  =  B.DMOBSCD
					<isNotEqual prepend="AND" property="gongku" compareValue="all">
						A.DMOBSCD = #gongku#
					</isNotEqual>
					AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
			 ORDER BY	 
					  A.YMDH ASC, B.OBSNM ASC
	</statement>
	
	<statement id="getDamData_chart"  parameterClass="searchTaksuVO" resultClass="damDataVO" >
			SELECT
					A.DMOBSCD AS FACT_CODE,
					B.OBSNM AS FACT_NAME,
					TO_CHAR(TO_DATE(A.YMDH,'YYYYMMDDHH24MI'),'YYYY/MM/DD HH24')||':00' AS RCV_DATE,
					TO_CHAR(A.SWL/100, 'FM999990') SWL,
					TO_CHAR(A.OTF, 'FM999990.00') SFW
			  FROM T_DMHR A, 
					T_DMOBSIF B
			 WHERE 
					A.DMOBSCD  =  B.DMOBSCD
					<isNotEqual prepend="AND" property="gongku" compareValue="all">
					  A.DMOBSCD = #gongku#
					</isNotEqual>
					AND A.YMDH BETWEEN #frDate#||#frTime#||'00' AND #toDate#||#toTime#||'59'
			ORDER BY 
					 A.YMDH ASC, B.OBSNM ASC
	</statement>
	
	<statement id="getDamFactLocation" parameterClass="searchTaksuVO" resultClass="locationVO">
		SELECT 
			NVL(LAT,0) latitude,
			NVL(LON,0) longitude
		FROM
			T_DMOBSIF 
		WHERE
			DMOBSCD = #gongku# 
	</statement>
	
	<statement id="getFactLocation" parameterClass="searchTaksuVO" resultClass="locationVO">
		SELECT
			NVL(FACT_STA_LATITUDE, 0) latitude,
			NVL(FACT_STA_LONGITUDE, 0) longitude
		FROM
			T_FACT_INFO
		WHERE 
			FACT_CODE = #gongku#
	</statement>
	
	<statement id="getBranchName" parameterClass="searchTaksuVO" resultClass="searchTaksuVO">
		SELECT
			BRANCH_NAME chukjeongso
		FROM
			T_FACT_BRANCH_INFO
		WHERE
			FACT_CODE = #gongku#
			and BRANCH_NO = #chukjeongso#
	</statement>	
	
	<statement id="getFlowOBSName" parameterClass="searchTaksuVO" resultClass="searchTaksuVO">
		SELECT	
			OBSNM gongku
		FROM
			T_FWOBSIF
		WHERE
			FWOBSCD = #gongku#
	</statement>
	
	<statement id="getFactName" parameterClass="searchTaksuVO" resultClass="searchTaksuVO">
		SELECT
			FACT_NAME gongku
		FROM
			T_FACT_INFO 
		WHERE
			FACT_CODE = #gongku#
	</statement>
	
	<statement id="getBoObsCdList" parameterClass="HashMap" resultClass="HashMap">
		SELECT OBSNM	AS CAPTION,
				BOOBSCD AS VALUE
		  FROM T_BOOBSIF
		 WHERE RIVER_DIV = #sugye#
		 ORDER BY BOOBSCD
	</statement>
	
	<!-- 보 10분 자료 DATA -->
	<select id="getBoManageList_MIN" resultClass="boSearchVO" parameterClass="boSearchVO">
		SELECT * 
		  FROM (SELECT ROWNUM RNUM,
						ROWNUM num,
						ALL_LIST.* 
				  FROM (
						SELECT A.BOOBSCD			AS boObsCd,
								A.OBSNM				AS obsNm,
								A.RIVER_DIV			AS sugye,
								SUBSTR(B.YMDHM,0,4)||'/' || SUBSTR(B.YMDHM,5,2) ||'/'|| SUBSTR(B.YMDHM,7,2) AS recvDay,
								SUBSTR(B.YMDHM,9,2)||':' || SUBSTR(B.YMDHM,11,2)							AS recvTime,
								B.SWL				AS swl,
								B.OWL				AS owl,
								B.SFW				AS sfw,
								B.ECPC				AS ecpc,
								B.INF				AS inf,
								B.TOTOTF			AS otf
						FROM T_BOOBSIF A,  T_BOMST B
						WHERE A.BOOBSCD = B.BOOBSCD(+)
						<isNotEmpty property="sugye">
							AND A.RIVER_DIV = #sugye#
						</isNotEmpty>
						<isNotEmpty property="searchObsCd">
							AND A.BOOBSCD = #searchObsCd#
						</isNotEmpty>
							AND B.YMDHM BETWEEN #startDate#||#frTime#||'00' AND #endDate#||#toTime#||'59'
						ORDER BY A.BOOBSCD DESC
						) ALL_LIST
				)
		<![CDATA[	
		WHERE RNUM > #firstIndex#
			AND RNUM <= #firstIndex# + #recordCountPerPage#
		]]>	
	</select>
	
	<!-- 보 10분 자료 DATA 카운트-->
	<select id="getBoManageListCnt_MIN" resultClass="java.lang.Integer" parameterClass="boSearchVO">
		SELECT COUNT(*) AS TOTCNT
		  FROM T_BOOBSIF A,  T_BOMST B
		 WHERE A.BOOBSCD = B.BOOBSCD(+)
			<isNotEmpty property="sugye">
			AND A.RIVER_DIV = #sugye#
			</isNotEmpty>
			<isNotEmpty property="searchObsCd">
			AND A.BOOBSCD = #searchObsCd#
			</isNotEmpty>
			AND B.YMDHM BETWEEN #startDate#||#frTime#||'00' AND #endDate#||#toTime#||'59'
	</select>
	
	<!-- 보 시간 자료 DATA -->
	<select id="getBoManageList_HOUR" resultClass="boSearchVO" parameterClass="boSearchVO">
		SELECT * 
		FROM (SELECT ROWNUM RNUM,
						ROWNUM num,
						ALL_LIST.* 
				FROM (
						SELECT A.BOOBSCD			AS boObsCd,
								A.OBSNM				AS obsNm,
								A.RIVER_DIV			AS sugye,
								SUBSTR(B.YMDH,0,4)||'/' || SUBSTR(B.YMDH,5,2) ||'/'|| SUBSTR(B.YMDH,7,2) AS recvDay,
								SUBSTR(B.YMDH,9,2)||':' ||'00'											AS recvTime,
								B.SWL				AS swl,
								B.OWL				AS owl,
								B.SFW				AS sfw,
								B.ECPC				AS ecpc,
								B.INF				AS inf,
								B.OTF				AS otf
						FROM T_BOOBSIF A,  T_BOHR B
						WHERE A.BOOBSCD = B.BOOBSCD(+)
						<isNotEmpty property="sugye">
							AND A.RIVER_DIV = #sugye#
						</isNotEmpty>
						<isNotEmpty property="searchObsCd">
							AND A.BOOBSCD = #searchObsCd#
						</isNotEmpty>
							AND B.YMDH BETWEEN #startDate#||'0000' AND #endDate#||'2359'
						ORDER BY A.BOOBSCD DESC
						) ALL_LIST
				)
		<![CDATA[
		WHERE RNUM > #firstIndex#
			AND RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</select>
	
	<!-- 보 10분 자료 DATA 카운트 -->
	<select id="getBoManageListCnt_HOUR" resultClass="java.lang.Integer" parameterClass="boSearchVO">
		SELECT COUNT(*) AS TOTCNT
		FROM T_BOOBSIF A,  T_BOHR B
		WHERE A.BOOBSCD = B.BOOBSCD(+)
		<isNotEmpty property="sugye">
			AND A.RIVER_DIV = #sugye#
		</isNotEmpty>
		<isNotEmpty property="searchObsCd">
			AND A.BOOBSCD = #searchObsCd#
		</isNotEmpty>
			AND B.YMDH BETWEEN #startDate#||'0000' AND #endDate#||'2359'
	</select>
	
	<!-- 조류정보조회 -->
	<statement id="getAlgacastAutoList" parameterClass="searchTaksuVO" resultClass="detailViewVO" remapResults="true">
	
		SELECT *
		FROM (
				SELECT ROWNUM RNUM, T.*
				FROM (
						SELECT
								FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
								MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
								<isEqual property="sys" compareValue="A">
								/* 일반 항목 (내부) */
								TO_CHAR(SUM(DECODE(TMP2, NULL, TMP, TMP2)), 'FM999,990.00') TMP,
								/* 클로로필-a */
								TO_CHAR(SUM(TOF), 'FM999,990.00') TOF,
								</isEqual>
								<isEqual property="sys" compareValue="U">
								TO_CHAR(SUM(DECODE(TMP2, NULL, TMP, TMP2)), RPAD('FM999,990.', 10+(SELECT VALUE_FORMAT FROM T_ITEM_INFO_ADD WHERE ITEM_CODE = 'TMP00'), '0')) TMP,
								TO_CHAR(SUM(TOF), RPAD('FM999,990.', 10+(SELECT VALUE_FORMAT FROM T_ITEM_INFO_ADD WHERE ITEM_CODE = 'TOF00'), '0')) TOF,
								</isEqual>
								RIVER_DIV,
								RIVER_NAME, SYS_KIND, SYS_KIND_NAME
						FROM (
							SELECT DISTINCT
								A.ITEM_CODE AS ITEMCODE,
								B.ITEM_NAME AS ITEMNAME,
								A.FACT_CODE AS FACTCODE,
								AREA.REG_NAME AS FACTNAME,
								A.BRANCH_NO AS BRANCHNO,
								D.BRANCH_NAME BRANCH_NAME,
								A.MIN_TIME AS MINTIME ,
								TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
								TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
								A.MIN_RTIME AS MINRTIME,
								A.MIN_DUMP AS MINDUMP ,
								/* 일반항목 내부 */
								DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) TMP,
								DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) TMP2,
								/* 클로로필-a */
								DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) TOF,
								C.RIVER_DIV,
								DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
								C.SYS_KIND,
								(
									SELECT SYS_KIND_NAME 
									FROM T_SYS_KIND 
									WHERE SYS_KIND = C.SYS_KIND
								) SYS_KIND_NAME
							FROM T_MIN_DATA A
								,T_WEATHER_AREA AREA
								,T_ITEM_INFO B
								,T_FACT_INFO C
								,T_FACT_BRANCH_INFO D
								,T_WQA_ITEM M
							WHERE
									A.FACT_CODE = AREA.FACT_CODE(+)
								AND A.ITEM_CODE  = B.ITEM_CODE
								AND A.FACT_CODE  = C.FACT_CODE
								AND C.FACT_CODE = D.FACT_CODE
								AND A.BRANCH_NO = D.BRANCH_NO
								AND D.BRANCH_USE_FLAG = 'Y'
								AND C.FACT_USE_FLAG  = 'Y'
								AND M.ITEM_CODE = A.ITEM_CODE
								AND C.SYS_KIND  = #sys#
								AND M.ITEM_CODE = A.ITEM_CODE
								<isNotEqual prepend="AND" property="sugye" compareValue="all">
									C.RIVER_DIV = #sugye#
								</isNotEqual>
								<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
									A.BRANCH_NO = #chukjeongso#
								</isNotEqual>
								<isNotEqual prepend="AND" property="gongku" compareValue="all">
									A.FACT_CODE = #gongku#
								</isNotEqual>
								<isEqual property="minor" compareValue="0">
									A.MIN_OR = '0'		/* 정상인 데이터만 */
								</isEqual>
								<isEqual property="minor" compareValue="1">
									A.MIN_OR != '0'		/* 기준초과인 데이터만 */
								</isEqual>
								<isNotEqual prepend="AND" property="valid" compareValue="all">
									A.MIN_ST = '00'
								</isNotEqual>
								AND A.ITEM_CODE IN ('TMP00','TMP01','TOF00')
								AND A.MIN_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
								)
						GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
									MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
									RIVER_DIV,
									RIVER_NAME, SYS_KIND, SYS_KIND_NAME
						ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
					) T
					WHERE TOF IS NOT NULL
			)
			WHERE
			<![CDATA[
				RNUM > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>
	</statement>
	
<!--	조류측정정보조회 수량 -->
	<statement id="getAlgacastAutoCnt" parameterClass="searchTaksuVO" resultClass="java.lang.Integer" remapResults="true">
				SELECT  COUNT(*)
					FROM (
						SELECT
								FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME,
								MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
								 /* 일반 항목 (내부) */
								TO_CHAR(SUM(DECODE(TMP2, NULL, TMP, TMP2)), 'FM999,990.00') TMP,
								 /* 클로로필-a */
								TO_CHAR(SUM(TOF), 'FM999,990.00') TOF,
								 RIVER_DIV,
								RIVER_NAME, SYS_KIND, SYS_KIND_NAME
						FROM (
							SELECT DISTINCT 
								A.ITEM_CODE AS ITEMCODE,
								B.ITEM_NAME AS ITEMNAME,
								A.FACT_CODE AS FACTCODE,
								AREA.REG_NAME AS FACTNAME,
								A.BRANCH_NO	AS BRANCHNO,
								D.BRANCH_NAME BRANCH_NAME,
								A.MIN_TIME  AS MINTIME ,
								TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STRDATE,
								TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STRTIME,
								A.MIN_RTIME AS MINRTIME,
								A.MIN_DUMP  AS MINDUMP ,
								/*  일반항목 내부 */
								DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) TMP,
										 DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) TMP2,
								/* 클로로필-a */
								DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) TOF,
									C.RIVER_DIV,
								DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME,
								C.SYS_KIND,
								(
									SELECT SYS_KIND_NAME 
									FROM T_SYS_KIND 
									WHERE SYS_KIND =  C.SYS_KIND
								) SYS_KIND_NAME
							FROM T_MIN_DATA A, 
									T_WEATHER_AREA AREA,
									T_ITEM_INFO B, 
									T_FACT_INFO C,
									T_FACT_BRANCH_INFO D
									,T_WQA_ITEM M
							WHERE 
								A.FACT_CODE = AREA.FACT_CODE(+)
								AND A.ITEM_CODE  = B.ITEM_CODE
								AND A.FACT_CODE  = C.FACT_CODE
								AND C.FACT_CODE  = D.FACT_CODE
								AND A.BRANCH_NO  = D.BRANCH_NO
								AND D.BRANCH_USE_FLAG = 'Y'
								AND C.FACT_USE_FLAG  = 'Y'
								AND M.ITEM_CODE = A.ITEM_CODE
								AND C.SYS_KIND  = #sys#
								AND M.ITEM_CODE = A.ITEM_CODE
							<isNotEqual prepend="AND" property="sugye" compareValue="all">
									C.RIVER_DIV = #sugye#
							</isNotEqual>
							
							<isNotEqual prepend="AND" property="chukjeongso" compareValue="all">
									A.BRANCH_NO = #chukjeongso#
							</isNotEqual>
							<isNotEqual prepend="AND" property="gongku" compareValue="all">
									  A.FACT_CODE = #gongku#
							</isNotEqual>
							<isEqual property="minor" compareValue="0">
										A.MIN_OR = '0'		 /* 정상인 데이터만 */
							</isEqual>
							<isEqual property="minor" compareValue="1">
										A.MIN_OR != '0'	/* 기준초과인 데이터만 */
							</isEqual>
							
							<isNotEqual prepend="AND" property="valid" compareValue="all">
										A.MIN_ST = '00'
							</isNotEqual>
							
							AND A.ITEM_CODE IN ('TMP00','TMP01','TOF00')
							AND A.MIN_TIME BETWEEN #frDate#||#frTime# AND #toDate#||#toTime#
								) 
						GROUP BY FACTCODE, FACTNAME, BRANCHNO, BRANCH_NAME, STRDATE, STRTIME,
									MINTIME, STRDATE, STRTIME, MINRTIME, MINDUMP,
									RIVER_DIV,
									RIVER_NAME, SYS_KIND, SYS_KIND_NAME
						ORDER BY STRDATE DESC, STRTIME DESC, FACTNAME ASC, BRANCHNO ASC
					) T
					WHERE TOF IS NOT NULL
	</statement>

<!--댐 정보조회 -->
	<statement id="getDamList" parameterClass="cmnSearchVO" resultClass="damViewVO" remapResults="true">
		SELECT * 
			FROM (SELECT ROWNUM RNUM,
						ROWNUM num,
						ALL_LIST.* 
					FROM (
						SELECT NVL(ADDRESS,'정보없음') ADDRESS
							, NVL(CTY_CODE,'정보없음') CTY_CODE
							, NVL(DO_CODE,'정보없음') DO_CODE
							, NVL(ETC_MANAGE,'정보없음') ETC_MANAGE
							, NVL(ETC_PHONE,'정보없음') ETC_PHONE
							, ID
							, NVL(LATITUDE,0) LATITUDE
							, NVL(LONGITUDE,0) LONGITUDE
							, NVL(MANAGE,'정보없음') MANAGE
							, NVL(NAME,'정보없음') NAME
							, NVL(NGI_MANAGE,'정보없음') NGI_MANAGE
							, NVL(NGI_PHONE,'정보없음') NGI_PHONE
							, DECODE(RIVER_DIV, 'R01', '한강', 'R02', '낙동강', 'R03', '금강', 'R04', '영산강', '', '정보없음' ) RIVER_DIV
							, NVL(RIVER_NM,'정보없음') RIVER_NM
							, USE_YN
							, NVL(MANAGE_PHONE,'정보없음') MANAGE_PHONE
							, NVL(TYPE,'정보없음') TYPE
							, NVL(KIND,'정보없음') KIND
							, NVL(L_BANK_ADDRESS,'정보없음') L_BANK_ADDRESS
							, NVL(R_BANK_ADDRESS,'정보없음') R_BANK_ADDRESS
							, NVL(HEIGHT,0) HEIGHT
							, NVL(LENGTH,0) LENGTH
							, NVL(VOLUME,0) VOLUME
							, NVL(ALTITUDE,0) ALTITUDE
							, NVL(BASIN_AREA,0) BASIN_AREA
							, NVL(STORE_AREA,0) STORE_AREA
							, NVL(BASIN_ANNUAL_INFLOW,0) BASIN_ANNUAL_INFLOW
							, NVL(BASIN_ANNUAL_RAINFALL,0) BASIN_ANNUAL_RAINFALL
							, NVL(PLANED_FLOOD_LEVEL,0) PLANED_FLOOD_LEVEL
							, NVL(NORMAL_FULL_LEVEL,0) NORMAL_FULL_LEVEL
							, NVL(NORMAL_FULL_LEVEL_VOLUME,0) NORMAL_FULL_LEVEL_VOLUME
							, NVL(FLOOD_LIMIT_LEVEL,0) FLOOD_LIMIT_LEVEL
							, NVL(FLOOD_CONTROL_VOLUME,0) FLOOD_CONTROL_VOLUME
							, NVL(STORE_WLEVEL_VOLUME,0) STORE_WLEVEL_VOLUME
							, NVL(SUPPLY_ENABLE_WLEVEL,0) SUPPLY_ENABLE_WLEVEL
							, NVL(TOTAL_STORE,0) TOTAL_STORE
							, NVL(VALID_STORE,0) VALID_STORE
							, NVL(MINIMUM_STORE,0) MINIMUM_STORE
							, NVL(EMERGENCY_SUPPLY,0) EMERGENCY_SUPPLY
							, NVL(RESERVOIR_LENGTH,0) RESERVOIR_LENGTH
							, NVL(DESIGNED_FLOOD,0) DESIGNED_FLOOD
							, NVL(MINIMUM_WL,0) MINIMUM_WL
							, NVL(DISCHARGE_WL,0) DISCHARGE_WL
							FROM T_DAM
							WHERE 1=1
							<isNotEqual property="sugye" compareValue="all">
								AND RIVER_DIV = #sugye#
							</isNotEqual>
							<isNotNull property="searchKeyword">
								AND NAME LIKE '%' || #searchKeyword# || '%'
							</isNotNull>
								AND USE_YN ='Y'
							ORDER BY NAME
						) ALL_LIST
				)
		<![CDATA[	
		WHERE  RNUM > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<statement id="getDamListCnt" parameterClass="cmnSearchVO" resultClass="java.lang.Integer" remapResults="true">
	
		SELECT COUNT(*) AS TOTCNT
		FROM T_DAM
		WHERE 1=1
		<isNotEqual property="sugye" compareValue="all">
			AND RIVER_DIV = #sugye#
		</isNotEqual>
		<isNotNull property="searchKeyword">
			AND NAME LIKE '%' || #searchKeyword# || '%'
		</isNotNull>
			AND USE_YN ='Y'
		ORDER BY NAME
	</statement>
	
	<!--점오염원 정보조회 -->
	<statement id="getFactoryIndustList" parameterClass="cmnSearchVO" resultClass="factoryIndustViewVO" remapResults="true">
		SELECT * 
		FROM (SELECT ROWNUM RNUM,
					ROWNUM num,
					ALL_LIST.* 
				FROM (
						SELECT
							A.ID
							, A.NAME
							, A.DO_CODE
							, A.CTY_CODE
							, DECODE(A.RIVER_ID,'R01', '한강','R02', '낙동강', 'R03', '금강', 'R04', '영산강',  '', '정보없음' ) RIVER_NM
							, NVL(A.RIVER_ID, '정보없음') RIVER_ID
							, NVL(A.ADDRESS, '정보없음') ADDRESS
							, NVL(A.LONGITUDE,0) LONGITUDE
							, NVL(A.LATITUDE,0) LATITUDE
							, NVL(A.BASIN_LARGE,0) BASIN_LARGE
							, NVL(A.BASIN_MIDDLE,0) BASIN_MIDDLE
							, NVL(A.BASIN_SMALL,0) BASIN_SMALL
							, B.BASIN_LARGE_NM
							, B.BASIN_MIDDLE_NM
						FROM T_FACTORY_INDUST A
							, (SELECT BASIN_LARGE
								, BASIN_MIDDLE
								, BASIN_LARGE_NM
								, BASIN_MIDDLE_NM
							FROM T_BASIN
							GROUP BY BASIN_LARGE, BASIN_MIDDLE, BASIN_LARGE_NM, BASIN_MIDDLE_NM) B
						WHERE A.BASIN_LARGE = B.BASIN_LARGE
							AND A.BASIN_MIDDLE = B.BASIN_MIDDLE
							<isNotEqual property="sugye" compareValue="all">
							AND RIVER_ID = #sugye#
							</isNotEqual>
							<isNotNull property="searchKeyword">
							AND NAME LIKE '%' || #searchKeyword# || '%'
							</isNotNull>
							AND RIVER_ID IS NOT NULL
							AND USE_YN = 'Y'
						ORDER BY NAME
					) ALL_LIST
				)
		<![CDATA[	
		WHERE  RNUM > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<statement id="getFactoryIndustListCnt" parameterClass="cmnSearchVO" resultClass="java.lang.Integer" remapResults="true">
	
		SELECT COUNT(*) AS TOTCNT
		FROM T_FACTORY_INDUST A
			, (SELECT BASIN_LARGE
				, BASIN_MIDDLE
				, BASIN_LARGE_NM
				, BASIN_MIDDLE_NM
			FROM T_BASIN
			GROUP BY BASIN_LARGE, BASIN_MIDDLE, BASIN_LARGE_NM, BASIN_MIDDLE_NM) B
		WHERE A.BASIN_LARGE = B.BASIN_LARGE
			AND A.BASIN_MIDDLE = B.BASIN_MIDDLE
			<isNotEqual prepend="AND" property="sugye" compareValue="all">
				RIVER_ID = #sugye#
			</isNotEqual>
			<isNotNull property="searchKeyword">
			AND NAME LIKE '%' || #searchKeyword# || '%'
			</isNotNull>
			AND RIVER_ID IS NOT NULL
			AND USE_YN = 'Y'
	</statement>
	
	<!--단일  점오염원 정보 조회 -->
	<statement id="getFactoryIndustIdList" parameterClass="cmnSearchVO" resultClass="factoryIndustViewVO" remapResults="true">
		
		SELECT
				A.ID
				, A.NAME
				, A.DO_CODE
				, A.CTY_CODE
				, DECODE(A.RIVER_ID,'R01', '한강','R02', '낙동강', 'R03', '금강', 'R04', '영산강',  '', '정보없음' ) RIVER_NM
				, NVL(A.RIVER_ID, '정보없음') RIVER_ID
				, NVL(A.ADDRESS, '정보없음') ADDRESS
				, NVL(A.LONGITUDE,0) LONGITUDE
				, NVL(A.LATITUDE,0) LATITUDE
				, NVL(A.BASIN_LARGE,0) BASIN_LARGE
				, NVL(A.BASIN_MIDDLE,0) BASIN_MIDDLE
				, NVL(A.BASIN_SMALL,0) BASIN_SMALL
				, B.BASIN_LARGE_NM
				, B.BASIN_MIDDLE_NM
			FROM T_FACTORY_INDUST A
				, (SELECT BASIN_LARGE
					, BASIN_MIDDLE
					, BASIN_LARGE_NM
					, BASIN_MIDDLE_NM
				FROM T_BASIN
				GROUP BY BASIN_LARGE, BASIN_MIDDLE, BASIN_LARGE_NM, BASIN_MIDDLE_NM) B
			WHERE A.BASIN_LARGE = B.BASIN_LARGE
				AND A.BASIN_MIDDLE = B.BASIN_MIDDLE
				AND A.ID = #sId#
	</statement>
	
	<!--점오염원 사업장 규모별 정보조회 -->
	<statement id="getFactoryIndustSizeList" parameterClass="cmnSearchVO" resultClass="factoryIndustViewVO" remapResults="true">
		SELECT 
			  ID
			, NVL(CNT_1,0) CNT_1
			, NVL(DISC_AMT_1,0) DISC_AMT_1
			, NVL(LOAD_AMT_1,0) LOAD_AMT_1
			, NVL(CNT_2,0) CNT_2
			, NVL(DISC_AMT_2,0) DISC_AMT_2
			, NVL(LOAD_AMT_2,0) LOAD_AMT_2
			, NVL(CNT_3,0) CNT_3
			, NVL(DISC_AMT_3,0) DISC_AMT_3
			, NVL(LOAD_AMT_3,0) LOAD_AMT_3
			, NVL(CNT_4,0) CNT_4
			, NVL(DISC_AMT_4,0) DISC_AMT_4
			, NVL(LOAD_AMT_4,0) LOAD_AMT_4
			, NVL(CNT_5,0) CNT_5
			, NVL(DISC_AMT_5,0) DISC_AMT_5
			, NVL(LOAD_AMT_5,0) LOAD_AMT_5
			, (CNT_1+CNT_2+CNT_3+CNT_4+CNT_5) CNT_T
			, (DISC_AMT_1+DISC_AMT_2+DISC_AMT_3+DISC_AMT_4+DISC_AMT_5) DISC_AMT_T
			, (LOAD_AMT_1+LOAD_AMT_2+LOAD_AMT_3+LOAD_AMT_4+LOAD_AMT_5) LOAD_AMT_T
		FROM T_FACTORY_INDUST_SIZE
		WHERE 1=1 
			AND ID LIKE '%' || #sId# || '%'
	</statement>
	
	<!--점오염원 오염물질별 정보조회 -->
	<statement id="getFactoryIndustSpecList" parameterClass="cmnSearchVO" resultClass="factoryIndustViewVO" remapResults="true">
		SELECT
			  ID
			, CU_CNT
			, TO_CHAR(CU_LOAD_AMT, 'FM999999990.00') CU_LOAD_AMT
			, PB_CNT
			, TO_CHAR(PB_LOAD_AMT, 'FM999999990.00') PB_LOAD_AMT
			, HG_CNT
			, TO_CHAR(HG_LOAD_AMT, 'FM999999990.00') HG_LOAD_AMT
			, CN_CNT
			, TO_CHAR(CN_LOAD_AMT, 'FM999999990.00') CN_LOAD_AMT
			, AS_CNT
			, TO_CHAR(AS_LOAD_AMT, 'FM999999990.00') AS_LOAD_AMT
			, YUGI_CNT
			, TO_CHAR(YUGI_LOAD_AMT, 'FM999999990.00') YUGI_LOAD_AMT
			, CR6_CNT
			, TO_CHAR(CR6_LOAD_AMT, 'FM999999990.00') CR6_LOAD_AMT
			, CD_CNT
			, TO_CHAR(CD_LOAD_AMT, 'FM999999990.00') CD_LOAD_AMT
			, PCE_CNT
			, TO_CHAR(PCE_LOAD_AMT, 'FM999999990.00') PCE_LOAD_AMT
			, TCE_CNT
			, TO_CHAR(TCE_LOAD_AMT, 'FM999999990.00') TCE_LOAD_AMT
			, C6H5OH_CNT
			, TO_CHAR(C6H5OH_LOAD_AMT, 'FM999999990.00') C6H5OH_LOAD_AMT
			, PCB_CNT
			, TO_CHAR(PCB_LOAD_AMT, 'FM999999990.00') PCB_LOAD_AMT
			, SE_CNT
			, TO_CHAR(SE_LOAD_AMT, 'FM999999990.00') SE_LOAD_AMT
			, C6H6_CNT
			, TO_CHAR(C6H6_LOAD_AMT, 'FM999999990.00') C6H6_LOAD_AMT
			, CCI4_CNT
			, TO_CHAR(CCI4_LOAD_AMT, 'FM999999990.00') CCI4_LOAD_AMT
			, CH2CL2_CNT
			, TO_CHAR(CH2CL2_LOAD_AMT, 'FM999999990.00') CH2CL2_LOAD_AMT
			, DCE_CNT
			, TO_CHAR(DCE_LOAD_AMT, 'FM999999990.00') DCE_LOAD_AMT
			, EDC_CNT
			, TO_CHAR(EDC_LOAD_AMT, 'FM999999990.00') EDC_LOAD_AMT
			, CHCI3_CNT
			, TO_CHAR(CHCI3_LOAD_AMT, 'FM999999990.00') CHCI3_LOAD_AMT
			, (CU_CNT+PB_CNT+HG_CNT+CN_CNT+ AS_CNT+YUGI_CNT+CR6_CNT+CD_CNT+PCE_CNT+TCE_CNT+C6H5OH_CNT+ PCB_CNT+ SE_CNT+ C6H6_CNT+ CCI4_CNT+ CH2CL2_CNT+ DCE_CNT+ EDC_CNT+ CHCI3_CNT) CNT_T
			, TO_CHAR((CU_LOAD_AMT+ PB_LOAD_AMT+ HG_LOAD_AMT+ CN_LOAD_AMT+ AS_LOAD_AMT+ YUGI_LOAD_AMT+ CR6_LOAD_AMT+ CD_LOAD_AMT+ PCE_LOAD_AMT+ TCE_LOAD_AMT+ C6H5OH_LOAD_AMT+ PCB_LOAD_AMT+SE_LOAD_AMT+C6H6_LOAD_AMT+ CCI4_LOAD_AMT+ CH2CL2_LOAD_AMT+ DCE_LOAD_AMT+ EDC_LOAD_AMT+ CHCI3_LOAD_AMT), 'FM999999990.00') LOAD_AMT_T
		FROM T_FACTORY_INDUST_SPEC
		WHERE 1=1
			AND ID LIKE '%' || #sId# || '%'
	</statement>
	
	<!--점오염원 오염물질별 정보조회 -->
	<statement id="getFactoryIndustSizeSpecCnt" parameterClass="cmnSearchVO" resultClass="factoryIndustViewVO" remapResults="true">
		SELECT 
			  ID
			, NVL(OCCU_AMT,0) OCCU_AMT
			, NVL(DISC_AMT,0) DISC_AMT
			, NVL(ORGA_PROD_OCCU_AMT,0) ORGA_PROD_OCCU_AMT
			, NVL(ORGA_PROD_DISC_AMT,0) ORGA_PROD_DISC_AMT
			, NVL(ID_CNT,0)ID_CNT
			FROM T_FACTORY_INDUST_CNT
			WHERE 1=1
			AND ID LIKE '%' || #sId# || '%'
	</statement>
	
	<!--점오염원 관련하천 대권역 정보조회 -->
	<statement id="getBasinLargeList" parameterClass="cmnSearchVO" resultClass="basinViewVO" remapResults="true">
		SELECT
			  BASIN_LARGE
			, BASIN_LARGE_NM
		FROM T_BASIN
		WHERE BASIN_LARGE_NM IS NOT NULL 
		GROUP BY BASIN_LARGE, BASIN_LARGE_NM
		ORDER BY BASIN_LARGE
	</statement>
	
	<!--점오염원 관련하천 중권역 정보조회 -->
	<statement id="getBasinMiddleList" parameterClass="cmnSearchVO" resultClass="basinViewVO" remapResults="true">
		SELECT 
			  BASIN_LARGE
			, BASIN_MIDDLE
			, BASIN_LARGE_NM
			, BASIN_MIDDLE_NM 
		FROM T_BASIN 
		WHERE BASIN_MIDDLE_NM IS NOT NULL
			AND BASIN_LARGE = #basinLarge#
		GROUP BY BASIN_LARGE, BASIN_MIDDLE, BASIN_LARGE_NM, BASIN_MIDDLE_NM 
		ORDER BY BASIN_MIDDLE_NM
	</statement>
	
	<!-- 사업소 id 중복체크 -->
	<statement id="duplicateFacId" resultClass="java.lang.Integer" parameterClass="factoryIndustViewVO">
		SELECT COUNT(*) AS totcnt
		FROM T_FACTORY_INDUST
		WHERE ID = #id#
	</statement>
	
	<!--점오염원  사업소 등록  -->
	<insert id="insertFactoryIndust" parameterClass="factoryIndustViewVO">
		INSERT INTO T_FACTORY_INDUST(
			ID, NAME, RIVER_ID, BASIN_LARGE
			, BASIN_MIDDLE, LATITUDE, LONGITUDE, DO_CODE, CTY_CODE, ADDRESS, USE_YN
			)
		VALUES(
			#id#, #name#, #river_id#, #basin_large#, #basin_middle#
			, #latitude#, #longitude#, #do_code#, #cty_code#, #address#,'Y'
			)
	</insert>
	
	<!--점오염원  사업소 size 등록  -->
	<insert id="insertFactoryIndustSize" parameterClass="factoryIndustViewVO">
		INSERT INTO T_FACTORY_INDUST_SIZE(ID)
		VALUES(#id#)
	</insert>
	
	<!--점오염원  사업소 spec 등록  -->
	<insert id="insertFactoryIndustSpec" parameterClass="factoryIndustViewVO">
		INSERT INTO T_FACTORY_INDUST_SPEC(ID)
		VALUES(#id#)
	</insert>
	
	<!--점오염원  사업소 cnt 등록  -->
	<insert id="insertFactoryIndustCnt" parameterClass="factoryIndustViewVO">
		INSERT INTO T_FACTORY_INDUST_CNT(ID)
		VALUES(#id#)
	</insert>
	
	<!--점오염원  사업소 수정  -->
	<update id="updatFactoryIndust" parameterClass="factoryIndustViewVO">
		<![CDATA[
		UPDATE T_FACTORY_INDUST 
		SET   ID			= #id#
			, NAME			= #name#
			, RIVER_ID		= #river_id#
			, BASIN_LARGE	= #basin_large#
			, BASIN_MIDDLE	= #basin_middle#
			, LATITUDE		= #latitude#
			, LONGITUDE		= #longitude#
			, DO_CODE		= #do_code#
			, CTY_CODE		= #cty_code#
			, ADDRESS		= #address#
		WHERE ID = #id#
		]]>
	</update>
	
	<!--점오염원  사업소 삭제  -->
	<update id="deleteFactoryIndust" parameterClass="cmnSearchVO">
		<![CDATA[
			UPDATE T_FACTORY_INDUST
			SET USE_YN = 'N'
			WHERE ID = #sId#
		]]>
	</update>
	
	<!--점오염원  사업소별size 측정값 수정  -->
	<update id="updateFactoryIndustSize" parameterClass="factoryIndustViewVO">
		<![CDATA[
		UPDATE T_FACTORY_INDUST_SIZE 
		SET   CNT_1 = #cnt_1#
			, DISC_AMT_1 = #disc_amt_1#
			, LOAD_AMT_1 = #load_amt_1#
			, CNT_2 = #cnt_2#
			, DISC_AMT_2 = #disc_amt_2#
			, LOAD_AMT_2 = #load_amt_2#
			, CNT_3 = #cnt_3#
			, DISC_AMT_3 = #disc_amt_3#
			, LOAD_AMT_3 = #load_amt_3#
			, CNT_4 = #cnt_4#
			, DISC_AMT_4 = #disc_amt_4#
			, LOAD_AMT_4 = #load_amt_4#
			, CNT_5 = #cnt_5#
			, DISC_AMT_5 = #disc_amt_5#
			, LOAD_AMT_5 = #load_amt_5#
		 WHERE ID = #id#
		]]>
	</update>
	
	<!--점오염원  오염물질별spec 측정값 수정  -->
	<update id="updateFactoryIndustSpec" parameterClass="factoryIndustViewVO">
		<![CDATA[
		UPDATE T_FACTORY_INDUST_SPEC
		SET   CU_CNT = #cu_cnt#
			, CU_LOAD_AMT = #cu_load_amt#
			, PB_CNT = #pb_cnt#
			, PB_LOAD_AMT = #pb_load_amt#
			, HG_CNT = #hg_cnt#
			, HG_LOAD_AMT = #hg_load_amt#
			, CN_CNT = #cn_cnt#
			, CN_LOAD_AMT = #cn_load_amt#
			, AS_CNT = #as_cnt#
			, AS_LOAD_AMT = #as_load_amt#
			, YUGI_CNT = #yugi_cnt#
			, YUGI_LOAD_AMT = #yugi_load_amt#
			, CR6_CNT = #cr6_cnt#
			, CR6_LOAD_AMT = #cr6_load_amt#
			, CD_CNT = #cd_cnt#
			, CD_LOAD_AMT = #cd_load_amt#
			, PCE_CNT = #pce_cnt#
			, PCE_LOAD_AMT = #pce_load_amt#
			, TCE_CNT = #tce_cnt#
			, TCE_LOAD_AMT = #tce_load_amt#
			, C6H5OH_CNT = #c6h5oh_cnt#
			, C6H5OH_LOAD_AMT = #c6h5oh_load_amt#
			, PCB_CNT = #pcb_cnt#
			, PCB_LOAD_AMT = #pcb_load_amt#
			, SE_CNT = #se_cnt#
			, SE_LOAD_AMT = #se_load_amt#
			, C6H6_CNT = #c6h6_cnt#
			, C6H6_LOAD_AMT = #c6h6_load_amt#
			, CCI4_CNT = #cci4_cnt#
			, CCI4_LOAD_AMT = #cci4_load_amt#
			, CH2CL2_CNT = #ch2cl2_cnt#
			, CH2CL2_LOAD_AMT = #ch2cl2_load_amt#
			, DCE_CNT = #dce_cnt#
			, DCE_LOAD_AMT = #dce_load_amt#
			, EDC_CNT = #edc_cnt#
			, EDC_LOAD_AMT = #edc_load_amt#
			, CHCI3_CNT = #chci3_cnt#
			, CHCI3_LOAD_AMT = #chci3_load_amt#
		WHERE ID = #id#
		]]>
	</update>
	
	<!--점오염원  사업소별cnt 측정값 수정  -->
	<update id="updateFactoryIndustCnt" parameterClass="factoryIndustViewVO">
		<![CDATA[
		UPDATE T_FACTORY_INDUST_CNT
		SET   ID_CNT = #id_cnt#
			, OCCU_AMT = #occu_amt#
			, DISC_AMT = #disc_amt#
			, ORGA_PROD_OCCU_AMT = #orga_prod_occu_amt#
			, ORGA_PROD_DISC_AMT = #orga_prod_disc_amt#
		WHERE ID = #id#
		]]>
	</update>
	
	<!--취정수장 정보조회 -->
	<statement id="getWaterDcCenterList" parameterClass="cmnSearchVO" resultClass="waterDcViewVO" remapResults="true">
		SELECT * 
		FROM (SELECT ROWNUM RNUM,
						ROWNUM num,
						ALL_LIST.* 
				FROM (
						SELECT
							  ID
							, NVL(NAME,'정보없음') NAME
							, NVL(ADDRESS,'정보없음') ADDRESS
							, NVL(DO_CODE,'정보없음') DO_CODE
							, NVL(CTY_CODE,'정보없음') CTY_CODE
							, NVL(LONGITUDE,0) LONGITUDE
							, NVL(LATITUDE,0) LATITUDE
							, DECODE(TYPE, 'C', '정수장', 'D', '취수장', '', '정보없음' ) TYPE
							, NVL(MANAGE,'정보없음') MANAGE
							, NVL(MANAGER,'정보없음') MANAGER
							, NVL(PHONE,'정보없음') PHONE
							, USE_YN
							, DECODE(RIVER_DIV, 'R01', '한강', 'R02', '낙동강', 'R03', '금강', 'R04', '영산강', '', '정보없음' ) RIVER_DIV
							, NVL(PROC_QTY,0) PROC_QTY
							, NVL(RIVER_NM,'정보없음') RIVER_NM
							, NVL(CONT_TERM,'정보없음') CONT_TERM
							, NVL(SUPPLY_REGION, '정보없음') SUPPLY_REGION
							, NVL(RUN_DAY, 0) RUN_DAY
							FROM T_WATERDC_CENTER 
							WHERE 1=1
							<isNotEqual prepend="AND" property="sugye" compareValue="all">
								RIVER_DIV = #sugye#
							</isNotEqual>
							<isNotEqual prepend="AND" property="dctype" compareValue="all">
								TYPE = #dctype#
							</isNotEqual>
							<isNotNull property="searchKeyword">
							AND NAME LIKE '%' || #searchKeyword# || '%'
							</isNotNull>
							AND USE_YN = 'Y'
							ORDER BY NAME
						) ALL_LIST
				)
		<![CDATA[	
		WHERE  RNUM > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<statement id="getWaterDcCenterListCnt" parameterClass="cmnSearchVO" resultClass="java.lang.Integer" remapResults="true">
	
		SELECT COUNT(*) AS TOTCNT
		FROM T_WATERDC_CENTER 
		WHERE 1=1
		<isNotEqual prepend="AND" property="sugye" compareValue="all">
			RIVER_DIV = #sugye#
		</isNotEqual>
		<isNotEqual prepend="AND" property="dctype" compareValue="all">
			TYPE = #dctype#
		</isNotEqual>
		<isNotNull property="searchKeyword">
		AND NAME LIKE '%' || #searchKeyword# || '%'
		</isNotNull>
		AND USE_YN = 'Y'
		ORDER BY NAME
	</statement>
	
	<!--보 정보조회 -->
	<statement id="getBoObsInfoList" parameterClass="cmnSearchVO" resultClass="boViewVO" remapResults="true">
		SELECT * 
		FROM (SELECT ROWNUM RNUM,
						ROWNUM num,
						ALL_LIST.* 
				FROM (
						SELECT
							  BOOBSCD
							, AGCCD
							, OBSNM
							, HGT
							, BSNARA
							, PFH
							, PFHCPC
							, TOTSTRCPC
							, FBSCD
							, SPCWL
							, HLMWL
							, LLMWL
							, STQTY
							, SPCCPC
							, LLMCPC
							, GTTY
							, GTELM
							, EGTY
							, EGUSQTY
							, FWTY
							, FWUSQTY
							, DECODE(RIVER_DIV, 'R01', '한강', 'R02', '낙동강', 'R03', '금강', 'R04', '영산강', '', '정보없음' ) RIVER_DIV
							FROM T_BOOBSIF 
							WHERE 1=1
								<isNotEqual prepend="AND" property="sugye" compareValue="all">
									RIVER_DIV = #sugye#
								</isNotEqual>
								<isNotNull property="searchKeyword">
								AND OBSNM LIKE '%' || #searchKeyword# || '%'
								</isNotNull>
							ORDER BY OBSNM
						) ALL_LIST
				)
		<![CDATA[	
		WHERE  RNUM > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<!-- 보 수량 -->
	<statement id="getBoObsInfoListCnt" parameterClass="cmnSearchVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*) AS TOTCNT
		FROM T_BOOBSIF
		WHERE 1=1
		<isNotEqual prepend="AND" property="sugye" compareValue="all">
			RIVER_DIV = #sugye#
		</isNotEqual>
		<isNotNull property="searchKeyword">
		AND OBSNM LIKE '%' || #searchKeyword# || '%'
		</isNotNull>
		ORDER BY OBSNM
	</statement>
	
	<!-- 유관기관 조회 -->
	<statement id="getRelOffList" parameterClass="cmnSearchVO" resultClass="relateOfficeDataVO" remapResults="true">
		SELECT * 
		FROM (SELECT ROWNUM RNUM,
						ROWNUM num,
						ALL_LIST.* 
				FROM (
						SELECT
							  ID
							, NVL(NM, '정보없음')  NM
							, NVL(ADDRESS, '정보없음')  ADDRESS
							, DO_CODE
							, CTY_CODE
							, NVL(DEPT,'정보없음') DEPT
							, NVL(DAY_TEL,'정보없음') DAY_TEL
							, NVL(NIGHT_TEL,'정보없음') NIGHT_TEL
							, NVL(DAY_FAX,'정보없음') DAY_FAX
							, NVL(NIGHT_FAX,'정보없음') NIGHT_FAX
						FROM T_RELATE_OFFICE
						WHERE 1=1
						<isNotEqual property="sDoCode" compareValue="all">
							AND DO_CODE = #sDoCode#
						</isNotEqual>
						<isNotEqual property="sCtyCode" compareValue="all">
							AND CTY_CODE = #sCtyCode#
						</isNotEqual>
						<isNotNull property="searchKeyword">
							AND NM LIKE '%' || #searchKeyword# || '%'
						</isNotNull>	
							AND USE_YN='Y'
						ORDER BY NM
						) ALL_LIST
				)
		<![CDATA[	
		WHERE  RNUM > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<!-- 유관기관 수량 -->
	<statement id="getRelOffListCnt" parameterClass="cmnSearchVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*) AS TOTCNT
		FROM T_RELATE_OFFICE
		WHERE 1=1
		<isNotEqual property="sDoCode" compareValue="all">
			AND DO_CODE = #sDoCode#
		</isNotEqual>
		<isNotEqual property="sCtyCode" compareValue="all">
			AND CTY_CODE = #sCtyCode#
		</isNotEqual>
		<isNotNull property="searchKeyword">
			AND NM LIKE '%' || #searchKeyword# || '%'
		</isNotNull>	
			AND USE_YN='Y'
		ORDER BY NM
	</statement>
	
	<!--단일  유관기관 정보 조회 -->
	<statement id="getRelOffDetailList" parameterClass="cmnSearchVO" resultClass="relateOfficeDataVO" remapResults="true">
		SELECT
			  ID
			, NVL(NM, '정보없음')  NM
			, NVL(ADDRESS, '정보없음')  ADDRESS
			, DO_CODE
			, CTY_CODE
			, NVL(DEPT,'정보없음') DEPT
			, NVL(DAY_TEL,'정보없음') DAY_TEL
			, NVL(NIGHT_TEL,'정보없음') NIGHT_TEL
			, NVL(DAY_FAX,'정보없음') DAY_FAX
			, NVL(NIGHT_FAX,'정보없음') NIGHT_FAX
		FROM T_RELATE_OFFICE
		WHERE ID = #sId#
	</statement>
	
	<!-- 유관기관 id 중복체크 -->
	<statement id="duplicateRelOffId" resultClass="java.lang.Integer" parameterClass="relateOfficeDataVO">
		SELECT COUNT(*) AS totcnt
		FROM T_FACTORY_INDUST
		WHERE ID = #id#
	</statement>
	
	<!-- 유관기관 등록 -->
	<insert id="insertRelOff" parameterClass="relateOfficeDataVO">
		INSERT INTO T_RELATE_OFFICE(ID, NM, ADDRESS,DEPT, DO_CODE, CTY_CODE, DAY_TEL, NIGHT_TEL, DAY_FAX, NIGHT_FAX, USE_YN)
		VALUES(#id#, #nm#, #address#, #dept#, #do_code#, #cty_code#, #day_tel#, #night_tel#, #day_fax#, #night_fax#,'Y')
	</insert>
	
	<!-- 유관기관 수정 -->
	<update id="updatRelOff" parameterClass="relateOfficeDataVO">
		<![CDATA[
		UPDATE T_RELATE_OFFICE
		SET   ID		= #id#
			, NM		= #nm#
			, ADDRESS	= #address#
			, DO_CODE	= #do_code#
			, CTY_CODE	= #cty_code#
			, DEPT		= #dept#
			, DAY_TEL	= #day_tel#
			, NIGHT_TEL	= #night_tel#
			, DAY_FAX	= #day_fax#
			, NIGHT_FAX	= #night_fax#
		WHERE ID = #id#
		]]>
	</update>
	
	<!-- 유관기관 삭제 -->
	<update id="deleteRelOff" parameterClass="cmnSearchVO">
		<![CDATA[
			UPDATE T_RELATE_OFFICE
			SET USE_YN = 'N'
			WHERE ID = #sId#
		]]>
	</update>
		
	<!-- 특별시/동  조회 -->
	<statement id="getDoCodeList" parameterClass="cmnSearchVO" resultClass="areaDataVO" remapResults="true">
		SELECT
			  DO_CODE
			, DO_NAME
		FROM T_AREA
		WHERE CTY_USE = 'Y'
		GROUP BY DO_CODE, DO_NAME
		ORDER BY DO_CODE
	</statement>
	
 	<!-- 시군구 조회 -->
	<statement id="getCtyCodeList" parameterClass="cmnSearchVO" resultClass="areaDataVO" remapResults="true">
		SELECT
			  CTY_CODE
			, CTY_NAME
		FROM T_AREA
		WHERE 1=1
		<isNotEqual property="sDoCode" compareValue="all">
			AND DO_CODE = #sDoCode#
		</isNotEqual>
			AND CTY_USE = 'Y'
		GROUP BY CTY_CODE, CTY_NAME
		ORDER BY CTY_CODE
	</statement>
	
	<!-- 방제업체 목록 조회 -->
	<statement id="getEcompanyList" parameterClass="cmnSearchVO" resultClass="ecompanyDataVO" remapResults="true">
	SELECT * 
		FROM (SELECT ROWNUM RNUM,
						ROWNUM num,
						ALL_LIST.* 
				FROM (
						SELECT
							  NVL(ADDRESS,'정보없음') ADDRESS
							, NVL(BASIN_LARGE,0)BASIN_LARGE
							, NVL(BASIN_MIDDLE,0)BASIN_MIDDLE
							, NVL(BASIN_SMALL,0)BASIN_SMALL
							, NVL(CTY_CODE,'정보없음') CTY_CODE
							, NVL(D_PHONE,'정보없음') D_PHONE
							, NVL(DO_CODE,'정보없음') DO_CODE
							, NVL(FAX,'정보없음') FAX
							, ID
							, NVL(LATITUDE,0)LATITUDE
							, NVL(LONGITUDE,0)LONGITUDE
							, NVL(N_PHONE,'정보없음') N_PHONE
							, NVL(NM,'정보없음') NM
							, NVL(OWNER,'정보없음') OWNER
							, NVL(RIVER_DIV,'정보없음') RIVER_DIV
							, NVL(RIVER_NM,'정보없음') RIVER_NM
							, USE_YN, NVL(TYPE,'정보없음') TYPE
							, NVL(E_PHONE,'정보없음') E_PHONE
						FROM T_ECOMPANY
						WHERE 1=1
							<isNotEqual property="sugye" compareValue="all">
								AND RIVER_DIV = #sugye#
							</isNotEqual>
							<isNotEmpty property="searchKeyword">
								<isNotNull property="searchKeyword">
									AND NM LIKE '%' || #searchKeyword# || '%'
								</isNotNull>
							</isNotEmpty>
							AND USE_YN='Y'
						ORDER BY NM
					) ALL_LIST
				)
		<![CDATA[	
		WHERE  RNUM > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<!-- 방제업체 수량 -->
	<statement id="getEcompanyListCnt" parameterClass="cmnSearchVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*) AS TOTCNT
		FROM T_ECOMPANY
		WHERE 1=1
			<isNotEqual property="sugye" compareValue="all">
				AND RIVER_DIV = #sugye#
			</isNotEqual>
			<isNotNull property="searchKeyword">
				AND NM LIKE '%' || #searchKeyword# || '%'
			</isNotNull>
			AND USE_YN='Y'
		ORDER BY NM
	</statement>
	
	<!--단일  방제업체 정보 조회 -->
	<statement id="getEcompanyDetailList" parameterClass="cmnSearchVO" resultClass="ecompanyDataVO" remapResults="true">
		SELECT
			  NVL(ADDRESS,'정보없음') ADDRESS
			, NVL(BASIN_LARGE,0)BASIN_LARGE
			, NVL(BASIN_MIDDLE,0)BASIN_MIDDLE
			, NVL(BASIN_SMALL,0)BASIN_SMALL
			, NVL(CTY_CODE,'정보없음') CTY_CODE
			, NVL(D_PHONE,'정보없음') D_PHONE
			, NVL(DO_CODE,'정보없음') DO_CODE
			, NVL(FAX,'정보없음') FAX
			, ID
			, NVL(LATITUDE,0)LATITUDE
			, NVL(LONGITUDE,0)LONGITUDE
			, NVL(N_PHONE,'정보없음') N_PHONE
			, NVL(NM,'정보없음') NM
			, NVL(OWNER,'정보없음') OWNER
			, NVL(RIVER_DIV,'정보없음') RIVER_DIV
			, NVL(RIVER_NM,'정보없음') RIVER_NM
			, USE_YN, NVL(TYPE,'정보없음') TYPE
			, NVL(E_PHONE,'정보없음') E_PHONE
		FROM T_ECOMPANY
		WHERE ID = #sId#
	</statement>
	
	<!-- 방제업체  id 중복체크 -->
	<statement id="duplicateEcoId" resultClass="java.lang.Integer" parameterClass="ecompanyDataVO">
		SELECT COUNT(*) AS totcnt
		FROM T_FACTORY_INDUST
		WHERE ID = #id#
	</statement>
	
	<!-- 방제업체 등록 -->
	<insert id="insertEcompany" parameterClass="ecompanyDataVO">
		INSERT INTO T_ECOMPANY(ID, NM, OWNER, RIVER_DIV, D_PHONE, N_PHONE, E_PHONE, TYPE, FAX, LATITUDE, LONGITUDE, ADDRESS, DO_CODE, CTY_CODE, USE_YN)
 		VALUES(#id#, #nm#, #owner#, #river_div#, #d_phone#, #n_phone#, #e_phone#, #type#, #fax#, #latitude#, #longitude#, #address#, #do_code#, #cty_code#, 'y')
	</insert>
	
	<!-- 방제업체 수정 -->
	<update id="updatEcompany" parameterClass="ecompanyDataVO">
		<![CDATA[
		UPDATE T_ECOMPANY
		SET   ID		= #id#
			, NM		= #nm#
			, OWNER		= #owner#
			, RIVER_DIV	= #river_div#
			, D_PHONE	= #d_phone#
			, N_PHONE	= #n_phone#
			, E_PHONE	= #e_phone#
			, TYPE		= #type#
			, FAX		= #fax#
			, LATITUDE	= #latitude#
			, LONGITUDE	= #longitude#
			, ADDRESS	= #address#
			, DO_CODE	= #do_code#
			, CTY_CODE	= #cty_code#
		WHERE ID = #id#
		]]>
	</update>
	
	<!-- 방제업체 삭제 -->
	<update id="deleteEcompany" parameterClass="cmnSearchVO">
		<![CDATA[
			UPDATE T_ECOMPANY
			SET USE_YN = 'N'
			WHERE ID = #sId#
		]]>
	</update>
	<!-- 방제물품 조회 -->
	<statement id="getEcompanyOwnItemList" parameterClass="cmnSearchVO" resultClass="ecompayOwnItemDataVO" remapResults="true">
		SELECT
			  A.ECOMPANY_ID
			, A.ITEM_CODE
			, A.ITEM_CODE_DET
			, B.ITEM_NAME
			, NVL(B.ITEM_UNIT, 'EA') ITEM_UNIT
		FROM T_ECOMPANY_OWN_ITEM A, T_ITEM_CODE B
		WHERE A.ITEM_CODE = B.ITEM_CODE
			AND A.ITEM_CODE_DET = B.ITEM_CODE_DET
			AND A.ITEM_CODE_NUM = B.ITEM_CODE_NUM
			AND ECOMPANY_ID = #sId#
		ORDER BY ITEM_NAME
	</statement>
	
	<!-- 방제물품 수량 -->
	<statement id="getEcompanyOwnItemListCnt" parameterClass="cmnSearchVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*) AS TOTCNT
		FROM T_ECOMPANY_OWN_ITEM A, T_ITEM_CODE B
		WHERE A.ITEM_CODE = B.ITEM_CODE
			AND A.ITEM_CODE_DET = B.ITEM_CODE_DET
			AND A.ITEM_CODE_NUM = B.ITEM_CODE_NUM
			AND ECOMPANY_ID = #sId#
		ORDER BY ITEM_NAME
	</statement>
	
	<!-- 방제물품 추가 -->
	<insert id="insertEcompanyOwnItem" parameterClass="ecompayOwnItemDataVO">
		INSERT INTO T_ECOMPANY_OWN_ITEM(ECOMPANY_ID, ITEM_CODE, ITEM_CODE_DET)
		VALUES(#ecompany_id#, #item_code#, #item_code_det#)
	</insert>
	
	<!-- 방제물품 삭제 -->
	<update id="deleteEcompanyOwnItem" parameterClass="ecompayOwnItemDataVO">
		<![CDATA[
			DELETE FROM T_ECOMPANY_OWN_ITEM
			WHERE ITEM_CODE = #item_code#
				AND ITEM_CODE_DET = #item_code_det#
				AND ECOMPANY_ID = #ecompany_id#
		]]>
	</update>
	
	<statement id="getRiverWater3HourWarning" parameterClass="riverWater3HourWarningSearchVO" resultClass="riverWater3HourWarningVO" remapResults="true">
	<!-- 2014-10-22 mypakr 페이징 추가 -->
	SELECT  * 
	  FROM ( 
	       SELECT ROWNUM RNUM, T.*
		  	  FROM (
	<!-- 2014-10-22 mypakr 페이징 추가 -->	  	  
			SELECT
				  DECODE (A.ALERT_LEVEL, '1', '관심', '2', '주의', '3', '경계', '4', '심각', 'M', '미수신', 'L', '위치이탈', 'B', '테스트') ALERT_LEVEL
				, A.ALERT_MSG   ALERT_MSG
				, TO_CHAR(A.ALERT_TIME, 'YYYY/MM/DD HH24:MI') ALERT_TIME
				, A.BRANCH_NO   BRANCH_NO
				, A.FACT_CODE   FACT_CODE
				, A.FACT_NAME   FACT_NAME
				, A.RIVER_NAME  RIVER_NAME
				, A.SMS_SEND_YN SMS_SEND_YN
				, C.BRANCH_NAME BRANCH_NAME
			FROM T_ALERT_INFO_HIS A, T_FACT_INFO B, T_FACT_BRANCH_INFO C
			<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
			  , T_MEMBER_AUTHORINFO D
			 </isNotEqual>
			WHERE A.FACT_CODE = B.FACT_CODE
				AND A.FACT_CODE = C.FACT_CODE
				AND A.BRANCH_NO = C.BRANCH_NO
			<![CDATA[
				AND A.ALERT_LEVEL <> 'M'
			]]>
			<isNotEqual property="alert_level" compareValue="all">
				AND A.ALERT_LEVEL = #alert_level#
			</isNotEqual>
			<isNotEqual property="sys_kind" compareValue="all">
				AND B.SYS_KIND = #sys_kind#
			</isNotEqual>
			<isNotEqual property="river_div" compareValue="all">
				AND B.RIVER_DIV = #river_div#
			</isNotEqual>
			<isNotEqual property="fact_code" compareValue="all">
				AND A.FACT_CODE = #fact_code#
			</isNotEqual>
			<isNotEqual property="branch_no" compareValue="all">
				AND C.BRANCH_NO = #branch_no#
			</isNotEqual>
				AND ALERT_TIME  BETWEEN TO_DATE(#frDate#||#frTime#||'00','YYYYMMDDHH24MI') AND TO_DATE(#toDate#||#toTime#||'59','YYYYMMDDHH24MI')
			<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
				AND D.MEMBER_ID = #userId#
			    AND B.SYS_KIND = D.SYS_KIND
			    AND B.RIVER_DIV = D.RIVER_DIV
			    AND B.FACT_CODE = D.FACT_CODE
			    AND C.BRANCH_NO = D.BRANCH_NO
			</isNotEqual>
			GROUP BY A.ALERT_LEVEL, A.ALERT_MSG, A.ALERT_TIME, A.BRANCH_NO, A.FACT_CODE, A.FACT_NAME, A.RIVER_NAME, A.SMS_SEND_YN, C.BRANCH_NAME
			ORDER BY A.ALERT_TIME DESC
<!-- 2014-10-22 mypark 페이징 추가 -->
					) T
			) WHERE 
<![CDATA[  
				RNUM  > #firstIndex# AND  RNUM <= #firstIndex# + #recordCountPerPage#
]]>
<!-- 2014-10-22 mypark 페이징 추가 -->		
	</statement>
	
	<statement id="getRiverWarning_cnt" parameterClass="riverWater3HourWarningSearchVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT 
				COUNT(*)
		FROM 
			(
			SELECT
				  A.ALERT_LEVEL ALERT_LEVEL
				, A.ALERT_MSG   ALERT_MSG
				, A.ALERT_TIME  ALERT_TIME
				, A.BRANCH_NO   BRANCH_NO
				, A.FACT_CODE   FACT_CODE
				, A.FACT_NAME   FACT_NAME
				, A.RIVER_NAME  RIVER_NAME
				, A.SMS_SEND_YN SMS_SEND_YN
				, C.BRANCH_NAME BRANCH_NAME
			FROM T_ALERT_INFO_HIS A, T_FACT_INFO B, T_FACT_BRANCH_INFO C
			<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
			  , T_MEMBER_AUTHORINFO D
			 </isNotEqual>
			WHERE A.FACT_CODE = B.FACT_CODE
				AND A.FACT_CODE = C.FACT_CODE
				AND A.BRANCH_NO = C.BRANCH_NO
			<![CDATA[
				AND A.ALERT_LEVEL <> 'M'
			]]>
			<isNotEqual property="alert_level" compareValue="all">
				AND A.ALERT_LEVEL = #alert_level#
			</isNotEqual>
			<isNotEqual property="sys_kind" compareValue="all">
				AND B.SYS_KIND = #sys_kind#
			</isNotEqual>
			<isNotEqual property="river_div" compareValue="all">
				AND B.RIVER_DIV = #river_div#
			</isNotEqual>
			<isNotEqual property="fact_code" compareValue="all">
				AND A.FACT_CODE = #fact_code#
			</isNotEqual>
			<isNotEqual property="branch_no" compareValue="all">
				AND C.BRANCH_NO = #branch_no#
			</isNotEqual>
				AND ALERT_TIME  BETWEEN TO_DATE(#frDate#||#frTime#||'00','YYYYMMDDHH24MI') AND TO_DATE(#toDate#||#toTime#||'59','YYYYMMDDHH24MI')
			<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
				AND D.MEMBER_ID = #userId#
			    AND B.SYS_KIND = D.SYS_KIND
			    AND B.RIVER_DIV = D.RIVER_DIV
			    AND B.FACT_CODE = D.FACT_CODE
			    AND C.BRANCH_NO = D.BRANCH_NO
			</isNotEqual>
			GROUP BY A.ALERT_LEVEL, A.ALERT_MSG, A.ALERT_TIME, A.BRANCH_NO, A.FACT_CODE, A.FACT_NAME, A.RIVER_NAME, A.SMS_SEND_YN, C.BRANCH_NAME
			ORDER BY A.ALERT_TIME DESC
		)
	</statement>
	
	<!-- 엑셀 추가 2014.10.31 kyr-->
	<statement id="getRiverWater3HourWarningExcel" parameterClass="riverWater3HourWarningSearchVO" resultClass="riverWater3HourWarningVO" remapResults="true">
			SELECT
				  DECODE (A.ALERT_LEVEL, '1', '관심', '2', '주의', '3', '경계', '4', '심각', 'M', '미수신', 'L', '위치이탈', 'B', '테스트') ALERT_LEVEL
				, A.ALERT_MSG   ALERT_MSG
				, TO_CHAR(A.ALERT_TIME, 'YYYY/MM/DD HH24:MI') ALERT_TIME
				, A.BRANCH_NO   BRANCH_NO
				, A.FACT_CODE   FACT_CODE
				, A.FACT_NAME   FACT_NAME
				, A.RIVER_NAME  RIVER_NAME
				, A.SMS_SEND_YN SMS_SEND_YN
				, C.BRANCH_NAME BRANCH_NAME
			FROM T_ALERT_INFO_HIS A, T_FACT_INFO B, T_FACT_BRANCH_INFO C
			<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
			  , T_MEMBER_AUTHORINFO D
			</isNotEqual>
			WHERE A.FACT_CODE = B.FACT_CODE
				AND A.FACT_CODE = C.FACT_CODE
				AND A.BRANCH_NO = C.BRANCH_NO
			<![CDATA[
				AND A.ALERT_LEVEL <> 'M'
			]]>
			<isNotEqual property="sys_kind" compareValue="all">
				AND B.SYS_KIND = #sys_kind#
			</isNotEqual>
			<isNotEqual property="river_div" compareValue="all">
				AND B.RIVER_DIV = #river_div#
			</isNotEqual>
			<isNotEqual property="fact_code" compareValue="all">
				AND A.FACT_CODE = #fact_code#
			</isNotEqual>
			<isNotEqual property="branch_no" compareValue="all">
				AND C.BRANCH_NO = #branch_no#
			</isNotEqual>
				AND ALERT_TIME  BETWEEN TO_DATE(#frDate#||#frTime#||'00','YYYYMMDDHH24MI') AND TO_DATE(#toDate#||#toTime#||'59','YYYYMMDDHH24MI')
			<isNotEqual property="userGubun" compareValue="ROLE_ADMIN">
				AND D.MEMBER_ID = #userId#
			    AND B.SYS_KIND = D.SYS_KIND
			    AND B.RIVER_DIV = D.RIVER_DIV
			    AND B.FACT_CODE = D.FACT_CODE
			    AND C.BRANCH_NO = D.BRANCH_NO
			</isNotEqual>
			GROUP BY A.ALERT_LEVEL, A.ALERT_MSG, A.ALERT_TIME, A.BRANCH_NO, A.FACT_CODE, A.FACT_NAME, A.RIVER_NAME, A.SMS_SEND_YN, C.BRANCH_NAME
			ORDER BY A.ALERT_TIME DESC
	</statement>
	
	<select id="getDetailViewLIMIT_U" parameterClass="limitDataVO" resultClass="limitDataVO" remapResults="true">
		WITH CODE_LIST AS(
			SELECT
				 #fact_code# AS FACT_CODE
				, #branch_no# AS BRANCH_NO
				, COMMON_CODE||'00' AS ITEM_CODE
				, COMMON_CODE_NAME AS ITEM_NAME
			FROM T_COMMON_CODE
			WHERE USE_FLAG = 'Y'
			AND COMMON_CODE_CATEGORY = '22'
			ORDER BY CODE_SORT ASC
		)
		SELECT
			  A.ITEM_CODE
			, A.ITEM_NAME
			, B.ITEM_VALUE_HI
			, B.ITEM_VALUE_LO 
		FROM
			CODE_LIST A LEFT OUTER JOIN T_ITEM_INFO_FACT B
		ON A.ITEM_CODE = B.ITEM_CODE(+)
		AND A.FACT_CODE = B.FACT_CODE(+)
		AND A.BRANCH_NO = B.BRANCH_NO(+)
	</select>

	<select id="getDetailViewLIMIT_A" parameterClass="limitDataVO" resultClass="limitDataVO" remapResults="true">
		WITH CODE_LIST AS(
			SELECT
				 #fact_code# AS FACT_CODE
				, COMMON_CODE||'00' AS ITEM_CODE
				, COMMON_CODE_NAME AS ITEM_NAME
			FROM T_COMMON_CODE
			WHERE USE_FLAG = 'Y'
			AND COMMON_CODE_CATEGORY = '22'
			ORDER BY CODE_SORT ASC
		)
		SELECT
			  AA.FACT_CODE
			, AA.ITEM_CODE
			, AA.ITEM_NAME
			, BB.MSR_ID
			, BB.ITEM_VALUE_HI
			, BB.ITEM_VALUE_LO
		FROM CODE_LIST AA LEFT OUTER JOIN
			(SELECT
				  B.FACT_CODE
				, B.MSR_ID
				, B.ITEM_CODE
				, A.VALUE_HI AS ITEM_VALUE_HI
				, A.VALUE_LO AS ITEM_VALUE_LO
			FROM MSRLIST_TB A,
				(SELECT
					  A.SITE_ID AS FACT_CODE
					, MAX(A.MSR_ID) AS MSR_ID
					, B.ITEM_CODE
				FROM MSRLIST_TB A LEFT OUTER JOIN T_ITEM_MATCH B
				ON A.MSR_ID = B.MSR_ID(+)
				WHERE A.MSR_ID IN (SELECT MSR_ID FROM T_ITEM_MATCH)
					AND A.USE_YN = 'Y'
				GROUP BY A.SITE_ID, B.ITEM_CODE) B
			WHERE A.SITE_ID = B.FACT_CODE
				AND A.MSR_ID = B.MSR_ID
				AND B.FACT_CODE = #fact_code#
		) BB
		ON AA.ITEM_CODE = BB.ITEM_CODE(+)
		AND AA.FACT_CODE = BB.FACT_CODE(+)
	</select>
	
	<update id="deleteDetailViewLIMIT" parameterClass="limitDataVO">
		DELETE FROM T_ITEM_INFO_FACT
		WHERE FACT_CODE = #to_fact_code# AND BRANCH_NO = #to_branch_no#
	</update>
	
	<insert id="insertDetailViewLIMIT" parameterClass="limitDataVO">
		INSERT INTO T_ITEM_INFO_FACT (
			  FACT_CODE
			, BRANCH_NO
			, ITEM_CODE
			, ITEM_VALUE_HI
			, ITEM_VALUE_LO
			, USE_FLAG
			) 
			SELECT
				  #to_fact_code# AS FACT_CODE
				, #to_branch_no# AS BRANCH_NO
				, B.ITEM_CODE
				, A.VALUE_HI AS ITEM_VALUE_HI
				, A.VALUE_LO AS ITEM_VALUE_LO
				, CASE WHEN A.USE_YN = 'Y' THEN 'Y' ELSE 'N' END USE_FLAG
			FROM MSRLIST_TB A, (
				SELECT
					  A.SITE_ID AS FACT_CODE
					, MAX(A.MSR_ID) AS MSR_ID
					, B.ITEM_CODE
				FROM MSRLIST_TB A LEFT OUTER JOIN T_ITEM_MATCH B
					ON A.MSR_ID = B.MSR_ID(+)
				WHERE A.MSR_ID IN (SELECT MSR_ID FROM T_ITEM_MATCH)
					AND A.USE_YN = 'Y'
				GROUP BY A.SITE_ID, B.ITEM_CODE
			) B
			WHERE A.SITE_ID = B.FACT_CODE
				AND A.MSR_ID = B.MSR_ID
				AND B.FACT_CODE = #from_fact_code#
	</insert>
	
	<!-- 측정소 기준치 수정 (IP-USN) -->
	<statement id="updateDetailViewLIMIT" parameterClass="limitDataVO">
		MERGE INTO T_ITEM_INFO_FACT
			USING DUAL
			  ON (
			    FACT_CODE = #to_fact_code#
			    AND BRANCH_NO = #to_branch_no#
			    AND ITEM_CODE = #item_code#
			  )
			WHEN MATCHED THEN
			  UPDATE SET
			      ITEM_VALUE_HI = #item_value_hi#
			    , ITEM_VALUE_LO = #item_value_lo#
			WHEN NOT MATCHED THEN
			  INSERT (
			      FACT_CODE
			    , BRANCH_NO
			    , ITEM_CODE
			    , ITEM_VALUE_HI
			    , ITEM_VALUE_LO
			    , USE_FLAG
			  )
			  VALUES (
			      #to_fact_code#
			    , #to_branch_no#
			    , #item_code#
			    , #item_value_hi#
			    , #item_value_lo#
			    , 'Y'
			  )
	</statement>
	
	
	<sql id="getSelectDataList_SQL">
		WITH FACT_LIMIT AS (
		  SELECT
		      FACT_CODE
		    , BRANCH_NO
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_HI)) AS TUR_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_LO)) AS TUR_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_HI)) AS DOW_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_LO)) AS DOW_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_HI)) AS TMP_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_LO)) AS TMP_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_HI)) AS PHY_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_LO)) AS PHY_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_HI)) AS CON_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_LO)) AS CON_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_HI)) AS TOF_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_LO)) AS TOF_VALUE_LO
		  FROM T_ITEM_INFO_FACT
		  WHERE FACT_CODE = #fact_code#
		    AND BRANCH_NO = #branch_no#
		  GROUP BY FACT_CODE, BRANCH_NO
		)
		SELECT A.*, B.TUR_SEL, B.DOW_SEL, B.TMP_SEL, B.PHY_SEL, B.CON_SEL, B.TOF_SEL
		         , B.TUR_STATUS, B.DOW_STATUS, B.TMP_STATUS, B.PHY_STATUS, B.CON_STATUS, B.TOF_STATUS FROM (
			SELECT
			    QQ.FACT_CODE FACT_CODE
			  , QQ.BRANCH_NO BRANCH_NO
			  , QQ.BRANCH_NAME BRANCH_NAME
			  , QQ.MIN_TIME MIN_TIME
			  , QQ.STR_DATE
			  , QQ.STR_TIME
			  , TUR
			  , TUR_OR
			  , TUR_ST
			  , DOW
			  , DOW_OR
			  , DOW_ST
			  , TMP
			  , TMP_OR
			  , TMP_ST
			  , PHY
			  , PHY_OR
			  , PHY_ST
			  , CON
			  , CON_OR
			  , CON_ST
			  , TOF
			  , TOF_OR
			  , TOF_ST
			  <![CDATA[
			  , CASE WHEN (
	    			(((SELECT TUR_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (TUR > (SELECT TUR_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT TUR_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (TUR < (SELECT TUR_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS TUR_OVER
			  , CASE WHEN (
	    			(((SELECT DOW_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (DOW > (SELECT DOW_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT DOW_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (DOW < (SELECT DOW_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS DOW_OVER
			  , CASE WHEN (
	    			(((SELECT TMP_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (TMP > (SELECT TMP_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT TMP_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (TMP < (SELECT TMP_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS TMP_OVER
			  , CASE WHEN (
	    			(((SELECT PHY_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (PHY > (SELECT PHY_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT PHY_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (PHY < (SELECT PHY_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS PHY_OVER
			  , CASE WHEN (
	    			(((SELECT CON_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (CON > (SELECT CON_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT CON_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (CON < (SELECT CON_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS CON_OVER
			  , CASE WHEN (
	    			(((SELECT TOF_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (TOF > (SELECT TOF_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT TOF_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (TOF < (SELECT TOF_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS TOF_OVER
			  ]]>
			  , AA.MIN_DUMP
			  , QQ.RIVER_NAME
			  , QQ.SYS_KIND_NAME
			  , QQ.SYS_KIND
			  , QQ.RIVER_DIV
			FROM (
			 SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , MIN_DUMP
			    , SUM(TUR) AS TUR
			    , SUM(TUR_OR) AS TUR_OR
			    , SUM(TUR_ST) AS TUR_ST
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW
			    , SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) AS DOW_OR
			    , SUM(DECODE(DOW2, NULL, DOW_ST, DOW2_ST)) AS DOW_ST
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP
			    , SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) AS TMP_OR
			    , SUM(DECODE(TMP2, NULL, TMP_ST, TMP2_ST)) AS TMP_ST
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY
			    , SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) AS PHY_OR
			    , SUM(DECODE(PHY2, NULL, PHY_ST, PHY2_ST)) AS PHY_ST
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON
			    , SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) AS CON_OR
			    , SUM(DECODE(CON2, NULL, CON_ST, CON2_ST)) AS CON_ST
			    , SUM(TOF) AS TOF
			    , SUM(TOF_OR) AS TOF_OR
			    , SUM(TOF_ST) AS TOF_ST
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			  FROM (
			    SELECT
			        DISTINCT A.ITEM_CODE AS ITEM_CODE
			      , B.ITEM_NAME AS ITEM_NAME
			      , A.FACT_CODE AS FACT_CODE
			      , A.BRANCH_NO AS BRANCH_NO
			      , D.BRANCH_NAME||'-'||A.BRANCH_NO AS BRANCH_NAME
			      , A.MIN_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , A.MIN_RTIME AS MIN_RTIME
			      , A.MIN_DUMP AS MIN_DUMP
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_VL) AS TUR
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_OR) AS TUR_OR
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_ST) AS TUR_ST
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_VL) AS DOW
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_OR) AS DOW_OR
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_ST) AS DOW_ST
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_VL) AS DOW2
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_OR) AS DOW2_OR
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_ST) AS DOW2_ST
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) AS TMP
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_OR) AS TMP_OR
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_ST) AS TMP_ST
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) AS TMP2
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_OR) AS TMP2_OR
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_ST) AS TMP2_ST
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_VL) AS PHY
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_OR) AS PHY_OR
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_ST) AS PHY_ST
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_VL) AS PHY2
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_OR) AS PHY2_OR
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_ST) AS PHY2_ST
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_VL) AS CON
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_OR) AS CON_OR
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_ST) AS CON_ST
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_VL) AS CON2
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_OR) AS CON2_OR
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_ST) AS CON2_ST
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) AS TOF
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_OR) AS TOF_OR
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_ST) AS TOF_ST
			      , C.RIVER_DIV
			      , DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , C.SYS_KIND
			      , ( SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = C.SYS_KIND) AS SYS_KIND_NAME
			    FROM
					(
                         SELECT /*+INDEX(T_MIN_DATA IX_MIN_DATA_04)*/ 
                                FACT_CODE,
                                BRANCH_NO,
                                MIN_TIME,
                                ITEM_CODE,
                                MIN_VL,
                                MIN_OR,
                                MIN_ST,
                                MIN_DUMP,
                                MIN_RTIME,
                                MIN_DCD
                           FROM T_MIN_DATA,
	                           (
	                           	SELECT MIN(min_time) startTime, 
                                       MAX(min_time) endTime 
                                  FROM 
                                       (SELECT ROWNUM rn, 
                                              TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#select_startday#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME 
                                         FROM 
                                              (SELECT TO_DATE(#searchYear#||#searchMonth#||#select_lastday#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#select_startday#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT 
                                                FROM DUAL
                                              <![CDATA[
                                              ) CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT 
                                              ]]> 
                                       ) 
                                 WHERE 1=1 
               					<![CDATA[
                                   AND rn > #firstIndex# 
                                   AND rn <= #firstIndex# + #recordCountPerPage# 
                                ]]>
                                ) B 
                          WHERE 1=1
                                AND FACT_CODE = #fact_code#
                                AND BRANCH_NO = #branch_no#
                                AND ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00')
                                AND MIN_TIME BETWEEN B.startTime AND B.endTime
                  ) A
			      , T_WEATHER_AREA AREA
			      , T_ITEM_INFO B
			      , T_FACT_INFO C
			      , T_FACT_BRANCH_INFO D
			    WHERE A.FACT_CODE = AREA.FACT_CODE(+)
			      AND A.BRANCH_NO = AREA.BRANCH_NO(+)
			      AND A.ITEM_CODE = B.ITEM_CODE			    
			      AND A.FACT_CODE = C.FACT_CODE
			      AND C.FACT_CODE = D.FACT_CODE
			      AND A.BRANCH_NO = D.BRANCH_NO
			      AND D.BRANCH_USE_FLAG = 'Y'
			      AND C.FACT_USE_FLAG = 'Y'
			      AND C.RIVER_DIV = #river_div#
			      AND C.SYS_KIND = 'U'
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
			    , MIN_DUMP
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			) AA,
			 (SELECT Q.MIN_TIME ,
	                TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE ,
	                TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME ,
	                A.FACT_CODE ,
	                A.BRANCH_NO ,
	                A.FACT_NAME ,
	                A.BRANCH_NAME ,
	                A.SYS_KIND ,
	                A.RIVER_NAME ,
	                A.SYS_KIND_NAME ,
	                A.RIVER_DIV
	           FROM
	                (SELECT TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#select_startday#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
	                  FROM
	                       (SELECT TO_DATE(#searchYear#||#searchMonth#||#select_lastday#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#select_startday#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
	                         FROM DUAL
	                       <![CDATA[
	                       ) CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT
	                       ]]>
	                ) Q,
	                (SELECT B.FACT_CODE ,
	                       B.BRANCH_NO ,
	                       AREA.REG_NAME AS FACT_NAME ,
	                       B.BRANCH_NAME||'-'||B.BRANCH_NO AS BRANCH_NAME ,
	                       F.RIVER_DIV ,
	                       DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME ,
	                       F.SYS_KIND ,
	                       (SELECT SYS_KIND_NAME
	                         FROM T_SYS_KIND
	                        WHERE SYS_KIND = F.SYS_KIND
	                       ) AS SYS_KIND_NAME
	                  FROM T_FACT_INFO F ,
	                       T_FACT_BRANCH_INFO B ,
	                       T_WEATHER_AREA AREA
	                 WHERE F.FACT_CODE = B.FACT_CODE
	                       AND B.BRANCH_USE_FLAG = 'Y'
	                       AND AREA.FACT_CODE(+) = B.FACT_CODE
	                       AND F.RIVER_DIV = #river_div#
	                       AND AREA.BRANCH_NO(+) = B.BRANCH_NO
	                       AND F.FACT_CODE = #fact_code#
	                       AND B.BRANCH_NO = #branch_no#
	                       AND F.SYS_KIND = 'U'
	                ) A
	         <![CDATA[
	          WHERE TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE
	          ]]>
	         ) QQ
			 WHERE AA.MIN_TIME(+)  = QQ.MIN_TIME
               AND AA.FACT_CODE(+) = QQ.FACT_CODE
               AND AA.BRANCH_NO(+) = QQ.BRANCH_NO
		) A LEFT OUTER JOIN (
		    SELECT
		        MAX(DECODE(BB.ITEM_CODE, 'TUR00', AA.SEL_SEQ)) AS TUR_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'DOW00', AA.SEL_SEQ)) AS DOW_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'TMP00', AA.SEL_SEQ)) AS TMP_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'PHY00', AA.SEL_SEQ)) AS PHY_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'CON00', AA.SEL_SEQ)) AS CON_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'TOF00', AA.SEL_SEQ)) AS TOF_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'TUR00', CC.COMMON_CODE))       AS TUR_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'DOW00', CC.COMMON_CODE))       AS DOW_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'TMP00', CC.COMMON_CODE))       AS TMP_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'PHY00', CC.COMMON_CODE))       AS PHY_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'CON00', CC.COMMON_CODE))       AS CON_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'TOF00', CC.COMMON_CODE))       AS TOF_STATUS
		      , BB.FACT_CODE
		      , BB.BRANCH_NO
		      , BB.MIN_TIME
		    FROM T_SELECT AA, T_SELECT_ITEM BB, T_DEFINITE_MAPPING_CODE CC
		    WHERE AA.SEL_SEQ = BB.SEL_SEQ
		      AND AA.USE_FLAG = 'Y'
		      AND BB.FACT_CODE = #fact_code#
			  AND BB.BRANCH_NO = #branch_no#
		      AND SUBSTR(BB.MIN_TIME, 0, 8) BETWEEN #searchYear#||#searchMonth#||#select_startday# AND #searchYear#||#searchMonth#||#select_lastday#
		      AND AA.SEL_STATUS = CC.STATUS_CODE(+)
		    GROUP BY BB.FACT_CODE, BB.BRANCH_NO, BB.MIN_TIME
		    ORDER BY MIN_TIME
		) B
		ON (
			A.FACT_CODE = B.FACT_CODE
			AND A.BRANCH_NO = B.BRANCH_NO
			AND A.MIN_TIME = B.MIN_TIME
		)
		WHERE 1=1
		AND A.MIN_TIME NOT IN (
			SELECT MIN_TIME
			FROM T_MIN_DATA_DEFINITE
			WHERE FACT_CODE = #fact_code#
				AND BRANCH_NO = #branch_no#
				AND SUBSTR(MIN_TIME, 0, 8) BETWEEN #searchYear#||#searchMonth#||#select_startday# AND #searchYear#||#searchMonth#||#select_lastday#
		)
		<isNotEqual property="strange" compareValue="all">
			AND (TUR_OVER > 0 OR DOW_OVER > 0 OR TMP_OVER > 0 OR PHY_OVER > 0 OR CON_OVER > 0 OR TOF_OVER > 0)
		</isNotEqual>
	</sql>
	
	<!-- 20161101 add by Naturetech 최회섭 -->
	<sql id="getSelectDataListAll_SQL">
		WITH FACT_LIMIT AS (
		  SELECT
		      FACT_CODE
		    , BRANCH_NO
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_HI)) AS TUR_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_LO)) AS TUR_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_HI)) AS DOW_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_LO)) AS DOW_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_HI)) AS TMP_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_LO)) AS TMP_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_HI)) AS PHY_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_LO)) AS PHY_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_HI)) AS CON_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_LO)) AS CON_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_HI)) AS TOF_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_LO)) AS TOF_VALUE_LO
		  FROM T_ITEM_INFO_FACT
		  WHERE FACT_CODE = #fact_code#
		    AND BRANCH_NO = #branch_no#
		  GROUP BY FACT_CODE, BRANCH_NO
		)
		SELECT A.*, B.TUR_SEL, B.DOW_SEL, B.TMP_SEL, B.PHY_SEL, B.CON_SEL, B.TOF_SEL
		         , B.TUR_STATUS, B.DOW_STATUS, B.TMP_STATUS, B.PHY_STATUS, B.CON_STATUS, B.TOF_STATUS FROM (
			SELECT
			    QQ.FACT_CODE FACT_CODE
			  , QQ.BRANCH_NO BRANCH_NO
			  , QQ.BRANCH_NAME BRANCH_NAME
			  , QQ.MIN_TIME MIN_TIME
			  , QQ.STR_DATE
			  , QQ.STR_TIME
			  , TUR
			  , TUR_OR
			  , TUR_ST
			  , DOW
			  , DOW_OR
			  , DOW_ST
			  , TMP
			  , TMP_OR
			  , TMP_ST
			  , PHY
			  , PHY_OR
			  , PHY_ST
			  , CON
			  , CON_OR
			  , CON_ST
			  , TOF
			  , TOF_OR
			  , TOF_ST
			  <![CDATA[
			  , CASE WHEN (
	    			(((SELECT TUR_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (TUR > (SELECT TUR_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT TUR_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (TUR < (SELECT TUR_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS TUR_OVER
			  , CASE WHEN (
	    			(((SELECT DOW_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (DOW > (SELECT DOW_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT DOW_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (DOW < (SELECT DOW_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS DOW_OVER
			  , CASE WHEN (
	    			(((SELECT TMP_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (TMP > (SELECT TMP_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT TMP_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (TMP < (SELECT TMP_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS TMP_OVER
			  , CASE WHEN (
	    			(((SELECT PHY_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (PHY > (SELECT PHY_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT PHY_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (PHY < (SELECT PHY_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS PHY_OVER
			  , CASE WHEN (
	    			(((SELECT CON_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (CON > (SELECT CON_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT CON_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (CON < (SELECT CON_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS CON_OVER
			  , CASE WHEN (
	    			(((SELECT TOF_VALUE_HI FROM FACT_LIMIT) IS NOT NULL) AND (TOF > (SELECT TOF_VALUE_HI FROM FACT_LIMIT))) OR
	    			(((SELECT TOF_VALUE_LO FROM FACT_LIMIT) IS NOT NULL) AND (TOF < (SELECT TOF_VALUE_LO FROM FACT_LIMIT)))
	    		) THEN 1 ELSE 0 END AS TOF_OVER
			  ]]>
			  , AA.MIN_DUMP
			  , QQ.RIVER_NAME
			  , QQ.SYS_KIND_NAME
			  , QQ.SYS_KIND
			  , QQ.RIVER_DIV
			FROM (
			 SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , MIN_DUMP
			    , SUM(TUR) AS TUR
			    , SUM(TUR_OR) AS TUR_OR
			    , SUM(TUR_ST) AS TUR_ST
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW
			    , SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) AS DOW_OR
			    , SUM(DECODE(DOW2, NULL, DOW_ST, DOW2_ST)) AS DOW_ST
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP
			    , SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) AS TMP_OR
			    , SUM(DECODE(TMP2, NULL, TMP_ST, TMP2_ST)) AS TMP_ST
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY
			    , SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) AS PHY_OR
			    , SUM(DECODE(PHY2, NULL, PHY_ST, PHY2_ST)) AS PHY_ST
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON
			    , SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) AS CON_OR
			    , SUM(DECODE(CON2, NULL, CON_ST, CON2_ST)) AS CON_ST
			    , SUM(TOF) AS TOF
			    , SUM(TOF_OR) AS TOF_OR
			    , SUM(TOF_ST) AS TOF_ST
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			  FROM (
			    SELECT
			        DISTINCT A.ITEM_CODE AS ITEM_CODE
			      , B.ITEM_NAME AS ITEM_NAME
			      , A.FACT_CODE AS FACT_CODE
			      , A.BRANCH_NO AS BRANCH_NO
			      , D.BRANCH_NAME||'-'||A.BRANCH_NO AS BRANCH_NAME
			      , A.MIN_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , A.MIN_RTIME AS MIN_RTIME
			      , A.MIN_DUMP AS MIN_DUMP
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_VL) AS TUR
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_OR) AS TUR_OR
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_ST) AS TUR_ST
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_VL) AS DOW
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_OR) AS DOW_OR
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_ST) AS DOW_ST
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_VL) AS DOW2
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_OR) AS DOW2_OR
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_ST) AS DOW2_ST
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) AS TMP
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_OR) AS TMP_OR
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_ST) AS TMP_ST
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) AS TMP2
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_OR) AS TMP2_OR
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_ST) AS TMP2_ST
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_VL) AS PHY
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_OR) AS PHY_OR
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_ST) AS PHY_ST
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_VL) AS PHY2
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_OR) AS PHY2_OR
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_ST) AS PHY2_ST
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_VL) AS CON
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_OR) AS CON_OR
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_ST) AS CON_ST
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_VL) AS CON2
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_OR) AS CON2_OR
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_ST) AS CON2_ST
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) AS TOF
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_OR) AS TOF_OR
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_ST) AS TOF_ST
			      , C.RIVER_DIV
			      , DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , C.SYS_KIND
			      , ( SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = C.SYS_KIND) AS SYS_KIND_NAME
			    FROM
					(
                         SELECT /*+INDEX(T_MIN_DATA IX_MIN_DATA_04)*/ 
                                FACT_CODE,
                                BRANCH_NO,
                                MIN_TIME,
                                ITEM_CODE,
                                MIN_VL,
                                MIN_OR,
                                MIN_ST,
                                MIN_DUMP,
                                MIN_RTIME,
                                MIN_DCD
                           FROM T_MIN_DATA,
	                           (
	                           	SELECT MIN(min_time) startTime, 
                                       MAX(min_time) endTime 
                                  FROM 
                                       (SELECT ROWNUM rn, 
                                              TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#select_startday#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME 
                                         FROM 
                                              (SELECT TO_DATE(#searchYear#||#searchMonth#||#select_lastday#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#select_startday#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT 
                                                FROM DUAL
                                              <![CDATA[
                                              ) CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT 
                                              ]]> 
                                       ) 
                                 WHERE 1=1 
                                ) B 
                          WHERE 1=1
                                AND FACT_CODE = #fact_code#
                                AND BRANCH_NO = #branch_no#
                                AND ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00')
                                AND MIN_TIME BETWEEN B.startTime AND B.endTime
                  ) A
			      , T_WEATHER_AREA AREA
			      , T_ITEM_INFO B
			      , T_FACT_INFO C
			      , T_FACT_BRANCH_INFO D
			    WHERE A.FACT_CODE = AREA.FACT_CODE(+)
			      AND A.BRANCH_NO = AREA.BRANCH_NO(+)
			      AND A.ITEM_CODE = B.ITEM_CODE			    
			      AND A.FACT_CODE = C.FACT_CODE
			      AND C.FACT_CODE = D.FACT_CODE
			      AND A.BRANCH_NO = D.BRANCH_NO
			      AND D.BRANCH_USE_FLAG = 'Y'
			      AND C.FACT_USE_FLAG = 'Y'
			      AND C.RIVER_DIV = #river_div#
			      AND C.SYS_KIND = 'U'
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
			    , MIN_DUMP
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			) AA,
			 (SELECT Q.MIN_TIME ,
	                TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE ,
	                TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME ,
	                A.FACT_CODE ,
	                A.BRANCH_NO ,
	                A.FACT_NAME ,
	                A.BRANCH_NAME ,
	                A.SYS_KIND ,
	                A.RIVER_NAME ,
	                A.SYS_KIND_NAME ,
	                A.RIVER_DIV
	           FROM
	                (SELECT TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#select_startday#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
	                  FROM
	                       (SELECT TO_DATE(#searchYear#||#searchMonth#||#select_lastday#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#select_startday#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
	                         FROM DUAL
	                       <![CDATA[
	                       ) CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT
	                       ]]>
	                ) Q,
	                (SELECT B.FACT_CODE ,
	                       B.BRANCH_NO ,
	                       AREA.REG_NAME AS FACT_NAME ,
	                       B.BRANCH_NAME||'-'||B.BRANCH_NO AS BRANCH_NAME ,
	                       F.RIVER_DIV ,
	                       DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME ,
	                       F.SYS_KIND ,
	                       (SELECT SYS_KIND_NAME
	                         FROM T_SYS_KIND
	                        WHERE SYS_KIND = F.SYS_KIND
	                       ) AS SYS_KIND_NAME
	                  FROM T_FACT_INFO F ,
	                       T_FACT_BRANCH_INFO B ,
	                       T_WEATHER_AREA AREA
	                 WHERE F.FACT_CODE = B.FACT_CODE
	                       AND B.BRANCH_USE_FLAG = 'Y'
	                       AND AREA.FACT_CODE(+) = B.FACT_CODE
	                       AND F.RIVER_DIV = #river_div#
	                       AND AREA.BRANCH_NO(+) = B.BRANCH_NO
	                       AND F.FACT_CODE = #fact_code#
	                       AND B.BRANCH_NO = #branch_no#
	                       AND F.SYS_KIND = 'U'
	                ) A
	         <![CDATA[
	          WHERE TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE
	          ]]>
	         ) QQ
			 WHERE AA.MIN_TIME(+)  = QQ.MIN_TIME
               AND AA.FACT_CODE(+) = QQ.FACT_CODE
               AND AA.BRANCH_NO(+) = QQ.BRANCH_NO
		) A LEFT OUTER JOIN (
		    SELECT
		        MAX(DECODE(BB.ITEM_CODE, 'TUR00', AA.SEL_SEQ)) AS TUR_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'DOW00', AA.SEL_SEQ)) AS DOW_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'TMP00', AA.SEL_SEQ)) AS TMP_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'PHY00', AA.SEL_SEQ)) AS PHY_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'CON00', AA.SEL_SEQ)) AS CON_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'TOF00', AA.SEL_SEQ)) AS TOF_SEL
		      , MAX(DECODE(BB.ITEM_CODE, 'TUR00', CC.COMMON_CODE))       AS TUR_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'DOW00', CC.COMMON_CODE))       AS DOW_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'TMP00', CC.COMMON_CODE))       AS TMP_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'PHY00', CC.COMMON_CODE))       AS PHY_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'CON00', CC.COMMON_CODE))       AS CON_STATUS
		      , MAX(DECODE(BB.ITEM_CODE, 'TOF00', CC.COMMON_CODE))       AS TOF_STATUS
		      , BB.FACT_CODE
		      , BB.BRANCH_NO
		      , BB.MIN_TIME
		    FROM T_SELECT AA, T_SELECT_ITEM BB, T_DEFINITE_MAPPING_CODE CC
		    WHERE AA.SEL_SEQ = BB.SEL_SEQ
		      AND AA.USE_FLAG = 'Y'
		      AND BB.FACT_CODE = #fact_code#
			  AND BB.BRANCH_NO = #branch_no#
		      AND SUBSTR(BB.MIN_TIME, 0, 8) BETWEEN #searchYear#||#searchMonth#||#select_startday# AND #searchYear#||#searchMonth#||#select_lastday#
		      AND AA.SEL_STATUS = CC.STATUS_CODE(+)
		    GROUP BY BB.FACT_CODE, BB.BRANCH_NO, BB.MIN_TIME
		    ORDER BY MIN_TIME
		) B
		ON (
			A.FACT_CODE = B.FACT_CODE
			AND A.BRANCH_NO = B.BRANCH_NO
			AND A.MIN_TIME = B.MIN_TIME
		)
		WHERE 1=1
		AND A.MIN_TIME NOT IN (
			SELECT MIN_TIME
			FROM T_MIN_DATA_DEFINITE
			WHERE FACT_CODE = #fact_code#
				AND BRANCH_NO = #branch_no#
				AND SUBSTR(MIN_TIME, 0, 8) BETWEEN #searchYear#||#searchMonth#||#select_startday# AND #searchYear#||#searchMonth#||#select_lastday#
		)
		<isNotEqual property="strange" compareValue="all">
			AND (TUR_OVER > 0 OR DOW_OVER > 0 OR TMP_OVER > 0 OR PHY_OVER > 0 OR CON_OVER > 0 OR TOF_OVER > 0)
		</isNotEqual>
	</sql>
	
	
	<!-- 측정소 데이터 선별 조회 -->
	<statement id="getSelectDataList_old" parameterClass="selectDataVO" resultClass="limitViewVO" remapResults="true">
		SELECT * FROM ( 
			SELECT ROWNUM RNUM, T.* FROM (
						SELECT 
							  FACT_CODE
							, BRANCH_NO
							, BRANCH_NAME
							, MIN_TIME
							, STR_DATE
							, STR_TIME
							, TO_CHAR(TUR, 'FM999,990.00') AS TUR
							, TUR_OR
							, TUR_ST
							, TO_CHAR(DOW, 'FM999,990.00') AS DOW
							, DOW_OR
							, DOW_ST
							, TO_CHAR(TMP, 'FM999,990.00') AS TMP
							, TMP_OR
							, TMP_ST
							, TO_CHAR(PHY, 'FM999,990.00') AS PHY
							, PHY_OR
							, PHY_ST
							, TO_CHAR(CON, 'FM999,990.00') AS CON
							, CON_OR
							, CON_ST
							, TO_CHAR(TOF, 'FM999,990.00') AS TOF
							, TOF_OR
							, TOF_ST
							, TUR_OVER
							, DOW_OVER
							, TMP_OVER
							, PHY_OVER
							, CON_OVER
							, TOF_OVER
							, MIN_DUMP
							, RIVER_NAME
							, SYS_KIND_NAME
							, SYS_KIND
							, RIVER_DIV
							, TUR_SEL
							, DOW_SEL
							, TMP_SEL
							, PHY_SEL
							, CON_SEL
							, TOF_SEL
						FROM (
						    <include refid="getSelectDataList_SQL"/>
					    )
					   ORDER BY
							  MIN_TIME ASC
					) T
		)
		WHERE
		<![CDATA[
			RNUM  > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<statement id="getSelectDataList" parameterClass="selectDataVO" resultClass="limitViewVO" remapResults="true">
		SELECT * FROM ( 
			SELECT ROWNUM RNUM, T.* FROM (
						SELECT 
							  FACT_CODE
							, BRANCH_NO
							, BRANCH_NAME
							, MIN_TIME
							, STR_DATE
							, STR_TIME
							, TO_CHAR(TRUNC(TUR, 2), 'FM999,990.00') AS TUR
							, TUR_OR
							, DECODE(TUR_STATUS, NULL, TUR_ST, TUR_STATUS) TUR_ST
							, TO_CHAR(TRUNC(DOW, 2), 'FM999,990.00') AS DOW
							, DOW_OR
							, DECODE(DOW_STATUS, NULL, DOW_ST, DOW_STATUS) DOW_ST
							, TO_CHAR(TRUNC(TMP, 2), 'FM999,990.00') AS TMP
							, TMP_OR
							, DECODE(TMP_STATUS, NULL, TMP_ST, TMP_STATUS) TMP_ST
							, TO_CHAR(TRUNC(PHY, 2), 'FM999,990.00') AS PHY
							, PHY_OR
							, DECODE(PHY_STATUS, NULL, PHY_ST, PHY_STATUS) PHY_ST
							, TO_CHAR(TRUNC(CON, 3), 'FM999,990.000') AS CON
							, CON_OR
							, DECODE(CON_STATUS, NULL, CON_ST, CON_STATUS) CON_ST
							, TO_CHAR(TRUNC(TOF, 2), 'FM999,990.00') AS TOF
							, TOF_OR
							, DECODE(TOF_STATUS, NULL, TOF_ST, TOF_STATUS) TOF_ST
							, TUR_OVER
							, DOW_OVER
							, TMP_OVER
							, PHY_OVER
							, CON_OVER
							, TOF_OVER
							, MIN_DUMP
							, RIVER_NAME
							, SYS_KIND_NAME
							, SYS_KIND
							, RIVER_DIV
							, TUR_SEL
							, DOW_SEL
							, TMP_SEL
							, PHY_SEL
							, CON_SEL
							, TOF_SEL
						FROM (
						    <include refid="getSelectDataList_SQL"/>
					    )
					   ORDER BY
							  MIN_TIME ASC
					) T
		)
		WHERE
		<![CDATA[
			RNUM  > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<!-- 측정소 데이터 선별 조회 전체 -->
	<statement id="getSelectDataListAll" parameterClass="selectDataVO" resultClass="limitViewVO" remapResults="true">
			SELECT 
				  FACT_CODE
				, BRANCH_NO
				, BRANCH_NAME
				, MIN_TIME
				, STR_DATE
				, STR_TIME
				, TO_CHAR(TRUNC(TUR, 2), 'FM999,990.00') AS TUR
				, TUR_OR
				, TUR_ST
				, TO_CHAR(TRUNC(DOW, 2), 'FM999,990.00') AS DOW
				, DOW_OR
				, DOW_ST
				, TO_CHAR(TRUNC(TMP, 2), 'FM999,990.00') AS TMP
				, TMP_OR
				, TMP_ST
				, TO_CHAR(TRUNC(PHY, 2), 'FM999,990.00') AS PHY
				, PHY_OR
				, PHY_ST
				, TO_CHAR(TRUNC(CON, 2), 'FM999,990.00') AS CON
				, CON_OR
				, CON_ST
				, TO_CHAR(TRUNC(TOF, 2), 'FM999,990.00') AS TOF
				, TOF_OR
				, TOF_ST
				, TUR_OVER
				, DOW_OVER
				, TMP_OVER
				, PHY_OVER
				, CON_OVER
				, TOF_OVER
				, MIN_DUMP
				, RIVER_NAME
				, SYS_KIND_NAME
				, SYS_KIND
				, RIVER_DIV
				, TUR_SEL
				, DOW_SEL
				, TMP_SEL
				, PHY_SEL
				, CON_SEL
				, TOF_SEL
			FROM (
			    <include refid="getSelectDataListAll_SQL"/>
		    )
		   ORDER BY
				  MIN_TIME ASC
	</statement>
	
	<select id="getSelectDataCnt" parameterClass="selectDataVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*)
		FROM
		    (SELECT TO_DATE(#searchYear#||#searchMonth#||#select_lastday#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#select_startday#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
		      FROM DUAL
		    <![CDATA[
		    ) CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT
		    ]]>
	</select>
	
	<select id="getStandardInfoCnt" parameterClass="selectDataVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT	COUNT(*)
		  FROM	T_ITEM_INFO_FACT
		 WHERE	FACT_CODE = #fact_code#
		   AND	BRANCH_NO = #branch_no#
	</select>
	
	<select id="getSelectDataMaxDate" parameterClass="selectDataVO" resultClass="String" remapResults="true">
		SELECT MAX(AA.MIN_TIME)
		FROM (
			SELECT
				  B.FACT_CODE
				, B.BRANCH_NO
				, B.ITEM_CODE
				, B.MIN_TIME
			FROM T_SELECT A, T_SELECT_ITEM B
			WHERE A.SEL_SEQ = B.SEL_SEQ
				AND A.USE_FLAG = 'Y'
				AND B.FACT_CODE = #fact_code#
				AND B.BRANCH_NO = #branch_no#
				AND SUBSTR(B.MIN_TIME, 0, 6) = #searchYear#||#searchMonth#
			) AA LEFT OUTER JOIN T_MIN_DATA_DEFINITE BB
			ON (
				AA.FACT_CODE = BB.FACT_CODE
				AND AA.BRANCH_NO = BB.BRANCH_NO
				AND AA.ITEM_CODE = BB.ITEM_CODE
				AND AA.MIN_TIME = BB.MIN_TIME
			)
		WHERE BB.MIN_TIME IS NULL
	</select>
	
	
	
	<!-- 데이터 선별 SEQ 조회 -->
	<select id="selectSelSeq" parameterClass="selectDataVO" resultClass="java.lang.Integer">
		SELECT SEQ_SEL.NEXTVAL FROM DUAL
	</select>
	
	<!-- 데이터 선별 등록 -->
	<insert id="saveSelectData" parameterClass="selectDataVO">
		INSERT INTO T_SELECT(SEL_SEQ, DEL_YN, SEL_ITEM, LIMIT_YN, STR_TIME, END_TIME, SEL_STATUS, SEL_REASON, ATCH_FILE_ID, REG_ID, REG_DATE, USE_FLAG)
 		VALUES(#sel_seq#, #del_yn#, #sel_item#, #limit_yn#, #str_time#, #end_time#, #sel_status_detail#, #sel_reason#, #atch_file_id#, #reg_id#, TO_CHAR(SYSDATE, 'YYYYMMDDHH24MI'), 'Y')
	</insert>
	
	
	<!-- 데이터 선별 (항목별) SELECT SQL -->
	<sql id="saveSelectDataItem_SELECT_SQL">
		SELECT 
            #sel_seq# AS SEL_SEQ
          , FACT_CODE
          , BRANCH_NO
          , ITEM_CODE
          , MIN_TIME
        FROM (
          SELECT
              A.FACT_CODE
            , A.BRANCH_NO
            , A.ITEM_CODE
            , A.MIN_TIME
            , A.MIN_VL
			<![CDATA[
            , CASE
                WHEN
                    A.ITEM_CODE = 'TUR00'
                  AND (B.TUR_VALUE_HI IS NOT NULL)
                  AND (A.MIN_VL > B.TUR_VALUE_HI OR A.MIN_VL < B.TUR_VALUE_LO)
                THEN 1
                WHEN
                    A.ITEM_CODE = 'DOW00'
                  AND (B.DOW_VALUE_HI IS NOT NULL)
                  AND (A.MIN_VL > B.DOW_VALUE_HI OR A.MIN_VL < B.DOW_VALUE_LO)
                THEN 1
                WHEN
                    A.ITEM_CODE = 'TMP00'
                  AND (B.TMP_VALUE_HI IS NOT NULL)
                  AND (A.MIN_VL > B.TMP_VALUE_HI OR A.MIN_VL < B.TMP_VALUE_LO)
                THEN 1
                WHEN
                    A.ITEM_CODE = 'PHY00'
                  AND (B.PHY_VALUE_HI IS NOT NULL)
                  AND (A.MIN_VL > B.PHY_VALUE_HI OR A.MIN_VL < B.PHY_VALUE_LO)
                THEN 1
                WHEN
                    A.ITEM_CODE = 'CON00'
                  AND (B.CON_VALUE_HI IS NOT NULL)
                  AND (A.MIN_VL > B.CON_VALUE_HI OR A.MIN_VL < B.CON_VALUE_LO)
                THEN 1
                WHEN
                    A.ITEM_CODE = 'TOF00'
                  AND (B.TOF_VALUE_HI IS NOT NULL)
                  AND (A.MIN_VL > B.TOF_VALUE_HI OR A.MIN_VL < B.TOF_VALUE_LO)
                THEN 1
                ELSE 0
                END AS VL_OVER
                ]]>
          FROM 
          (
          		SELECT QQ.MIN_TIME,
                       QQ.ITEM_CODE,
                       QQ.FACT_CODE,
                       QQ.BRANCH_NO,
                       QQ.MIN_VL
                FROM
                (          
                	SELECT Q.MIN_TIME, 
                           Q.ITEM_CODE,
                           Q.FACT_CODE, 
                           Q.BRANCH_NO,
                           A.MIN_VL
                     FROM 
                          (
	                          SELECT FACT_CODE,
	                                  BRANCH_NO,
	                                  MIN_VL,
	                                  ITEM_CODE,
	                                  MIN_TIME
	                            FROM T_MIN_DATA
	                           WHERE FACT_CODE = #fact_code#
	                             AND BRANCH_NO = #branch_no# 
	                             AND MIN_TIME BETWEEN #str_time# AND #end_time#  
                          ) A,
            <![CDATA[
                          (SELECT  T.FACT_CODE,
                                   T.BRANCH_NO,
                                   U.MIN_TIME,
                                   T.ITEM_CODE
                             FROM  
                            (SELECT TO_CHAR(TO_DATE(#str_time# , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME             
                               FROM 
                                    (SELECT TO_DATE(#end_time# , 'YYYYMMDDHH24MI') - TO_DATE(#str_time# , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT 
                                      FROM DUAL 
                                    ) CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT 
                                              
                             ) U,
                            (
                             SELECT FACT_CODE,
                                    BRANCH_NO,
                                    ITEM_CODE
                             FROM   T_FACT_MEASU_ITEM
                             WHERE 1=1 
                             AND FACT_CODE = #fact_code#
                             AND BRANCH_NO = #branch_no#
                             AND ITEM_USE_FLAG = 'Y'
                             ) T
                          ) Q
                    WHERE A.MIN_TIME(+)  = Q.MIN_TIME
                      AND A.FACT_CODE(+) = Q.FACT_CODE
                      AND A.BRANCH_NO(+) = Q.BRANCH_NO
                      AND A.ITEM_CODE(+) = Q.ITEM_CODE
                 ORDER BY MIN_TIME
                 ) QQ
               ]]>
               WHERE 1=1
               <isNotEqual property="sel_item" compareValue="all">
				 AND QQ.ITEM_CODE = #sel_item#
				</isNotEqual>
            ) A,     
           (
	            SELECT FACT_CODE ,
		               BRANCH_NO ,
		               MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_HI)) AS TUR_VALUE_HI ,
		               MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_LO)) AS TUR_VALUE_LO ,
		               MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_HI)) AS DOW_VALUE_HI ,
		               MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_LO)) AS DOW_VALUE_LO ,
		               MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_HI)) AS TMP_VALUE_HI ,
		               MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_LO)) AS TMP_VALUE_LO ,
		               MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_HI)) AS PHY_VALUE_HI ,
		               MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_LO)) AS PHY_VALUE_LO ,
		               MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_HI)) AS CON_VALUE_HI ,
		               MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_LO)) AS CON_VALUE_LO ,
		               MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_HI)) AS TOF_VALUE_HI ,
		               MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_LO)) AS TOF_VALUE_LO
	              FROM T_ITEM_INFO_FACT
	             WHERE FACT_CODE   = #fact_code#
	               AND BRANCH_NO   = #branch_no#
	          GROUP BY FACT_CODE,
	              	   BRANCH_NO
            ) B
		)
		<isEqual property="limit_yn" compareValue="Y">
			WHERE VL_OVER > 0
		</isEqual>
	</sql>
	
	<!-- 데이터 선별 등록 (항목별) -->
	<insert id="saveSelectDataItem" parameterClass="selectDataVO">
		INSERT INTO
			T_SELECT_ITEM(
				  SEL_SEQ
				, FACT_CODE
				, BRANCH_NO
				, ITEM_CODE
				, MIN_TIME
			)
			(
				<include refid="saveSelectDataItem_SELECT_SQL"/>
			)
	</insert>
	
	<!-- 데이터 선별 상세 조회 -->
	<select id="getDetailSelectData" parameterClass="selectDataVO" resultClass="selectDataVO">
		SELECT 
			  SEL_SEQ
			, DEL_YN
			, SEL_ITEM
			, LIMIT_YN
			, STR_TIME
			, END_TIME
			, SEL_REASON
			, ATCH_FILE_ID
			, BB.STATUS STATUS_CODE
  			, BB.STATUS_CODE STATUS_CODE_DETAIL
		FROM T_SELECT AA, T_DEFINITE_MAPPING_CODE BB
		WHERE SEL_SEQ = #sel_seq#
		  AND AA.USE_FLAG  = 'Y' 
		  AND AA.SEL_STATUS = BB.STATUS_CODE(+)
	</select>
	
	<!--  데이터 선별 상세 삭제 -->
	<update id="deleteSelectData" parameterClass="selectDataVO">
		UPDATE T_SELECT
		SET USE_FLAG = 'N', DEL_ID = #reg_id#, DEL_DATE = TO_CHAR(SYSDATE, 'YYYYMMDDHH24MI')
		WHERE SEL_SEQ = #sel_seq#
	</update>
	
	<!--  데이터 선별 상세 초기화 -->
	<update id="deleteSelectDataAll" parameterClass="selectDataVO">
		UPDATE T_SELECT
		SET USE_FLAG = 'N', DEL_ID = #reg_id#, DEL_DATE = TO_CHAR(SYSDATE, 'YYYYMMDDHH24MI')
		WHERE SEL_SEQ IN (
		  SELECT A.SEL_SEQ FROM T_SELECT A, T_SELECT_ITEM B
		  WHERE A.SEL_SEQ = B.SEL_SEQ
		  	AND A.USE_FLAG = 'Y'
		  	AND B.FACT_CODE = #fact_code#
    		AND B.BRANCH_NO = #branch_no#
		    AND B.MIN_TIME BETWEEN #str_time# AND #end_time#
		  GROUP BY A.SEL_SEQ
		)
	</update>
	
	<!-- 데이터 선별 갯수 체크 -->
	<select id="getChkSelectData" parameterClass="selectDataVO" resultClass="java.lang.Integer">
		SELECT COUNT(*) FROM T_SELECT A, T_SELECT_ITEM B
		WHERE A.SEL_SEQ = B.SEL_SEQ
			AND A.USE_FLAG = 'Y'
			AND B.FACT_CODE = #fact_code#
			AND B.BRANCH_NO = #branch_no#
			<isNotEqual property="sel_item" compareValue="all">
				AND ITEM_CODE = #sel_item#
			</isNotEqual>
			AND A.SEL_SEQ != #sel_seq#
			AND B.MIN_TIME BETWEEN #str_time# AND #end_time#
	</select>
	
	<!-- 데이터 선별 존재 체크 -->
	<select id="getCntSelectData" parameterClass="selectDataVO" resultClass="java.lang.Integer">
		SELECT COUNT(*) FROM (
			<include refid="saveSelectDataItem_SELECT_SQL"/>
		)
	</select>
	
	<!-- 확정 히스토리 입력 -->
	<insert id="insertDefiniteHis" parameterClass="selectDataVO">
		INSERT INTO T_DEFINITE(FACT_CODE, BRANCH_NO, STR_TIME, END_TIME, DEFINITE_TYPE, REG_ID, REG_DATE)
 		VALUES(#fact_code#, #branch_no#, #str_time#, #end_time#, #definite_type#, #reg_id#, TO_CHAR(SYSDATE, 'YYYYMMDDHH24MI'))
	</insert>
	
	<!-- 확정 데이터 입력 -->
	<insert id="insertDefiniteData" parameterClass="selectDataVO">
		MERGE INTO T_MIN_DATA_DEFINITE DT
			USING (
				SELECT
					  A.FACT_CODE
					, A.ITEM_CODE
					, A.MIN_TIME
					, A.BRANCH_NO
					, A.MIN_RTIME
					, A.MIN_DUMP
					, CASE WHEN B.MIN_TIME IS NOT NULL AND B.FACT_CODE IS NOT NULL AND B.BRANCH_NO IS NOT NULL THEN 999999 ELSE A.MIN_VL END AS MIN_VL
					, A.MIN_OR
					, DECODE(B.COMMON_CODE, NULL, A.MIN_ST, B.COMMON_CODE) MIN_ST
					, A.MIN_DCD
				FROM T_MIN_DATA A LEFT OUTER JOIN (
					SELECT BB.MIN_TIME, BB.FACT_CODE, BB.BRANCH_NO, BB.ITEM_CODE, CC.COMMON_CODE FROM T_SELECT AA, T_SELECT_ITEM BB, T_DEFINITE_MAPPING_CODE CC
					WHERE AA.SEL_SEQ = BB.SEL_SEQ
						AND AA.USE_FLAG = 'Y'
						AND AA.DEL_YN = 'Y'
						AND BB.FACT_CODE = #fact_code#
						AND BB.BRANCH_NO = #branch_no#
						AND BB.MIN_TIME BETWEEN #str_time# AND #end_time#
						AND AA.SEL_STATUS = CC.STATUS_CODE(+)
				) B
				ON (A.MIN_TIME = B.MIN_TIME AND A.FACT_CODE = B.FACT_CODE AND A.BRANCH_NO = B.BRANCH_NO AND A.ITEM_CODE = B.ITEM_CODE)
				WHERE A.FACT_CODE = #fact_code#
					AND A.BRANCH_NO = #branch_no#
					AND A.MIN_TIME BETWEEN #str_time# AND #end_time#
			) DF
			ON (DT.FACT_CODE = DF.FACT_CODE AND DT.BRANCH_NO = DF.BRANCH_NO AND DT.MIN_TIME = DF.MIN_TIME AND DT.ITEM_CODE = DF.ITEM_CODE)
		WHEN MATCHED THEN
			UPDATE SET
				  DT.MIN_RTIME = DF.MIN_RTIME
		    , DT.MIN_DUMP = DF.MIN_DUMP
		    , DT.MIN_VL = DF.MIN_VL
		    , DT.MIN_OR = DF.MIN_OR
		    , DT.MIN_ST = DF.MIN_ST
		    , DT.MIN_DCD = DF.MIN_DCD
		WHEN NOT MATCHED THEN
			INSERT (DT.FACT_CODE, DT.ITEM_CODE, DT.MIN_TIME, DT.BRANCH_NO, DT.MIN_RTIME, DT.MIN_DUMP, DT.MIN_VL, DT.MIN_OR, DT.MIN_ST, DT.MIN_DCD)
			VALUES (DF.FACT_CODE, DF.ITEM_CODE, DF.MIN_TIME, DF.BRANCH_NO, DF.MIN_RTIME, DF.MIN_DUMP, DF.MIN_VL, DF.MIN_OR, DF.MIN_ST, DF.MIN_DCD)
	</insert>
	
	<!-- 확정 데이터 입력 -->
	<insert id="insertDefiniteDataHour" parameterClass="selectDataVO">
		MERGE INTO T_HOUR_DATA_DEFINITE A
			USING (
				SELECT * FROM (
					SELECT
						  FACT_CODE 
						, BRANCH_NO
						, ITEM_CODE
						, SUBSTR(MIN_TIME, 0, 10) HOUR_TIME
						, AVG(MIN_VL) HOUR_VL
						, COUNT(MIN_VL) CNT_VL
						, '0' HOUR_DUMP
						, TO_CHAR(SYSDATE,'YYYYMMDDHH24') HOUR_RTIME
						, '0' HOUR_OR
						, '00' HOUR_ST
						, '1' HOUR_DCD
					FROM T_MIN_DATA_DEFINITE
					WHERE FACT_CODE IN ('99U1001','99U2001','99U3001','99U4001') 
						AND MIN_TIME BETWEEN #str_time# AND #end_time#
						<![CDATA[
							AND MIN_VL <>'999999'
						]]>
					GROUP BY
						  FACT_CODE
						, BRANCH_NO
						, ITEM_CODE
						, SUBSTR(MIN_TIME, 0, 10)
				)
				WHERE CNT_VL >= 4
			) B ON (
				A.FACT_CODE = B.FACT_CODE 
				AND A.BRANCH_NO = B.BRANCH_NO 
				AND A.ITEM_CODE = B.ITEM_CODE 
				AND A.HOUR_TIME = B.HOUR_TIME
			) 
			WHEN MATCHED THEN 
				UPDATE 
					SET A.HOUR_VL = B.HOUR_VL 
			WHEN NOT MATCHED THEN 
				INSERT (
					A.ITEM_CODE,
					A.BRANCH_NO,
					A.FACT_CODE,
					A.HOUR_TIME,
					A.HOUR_RTIME,
					A.HOUR_DUMP,
					A.HOUR_VL,
					A.HOUR_OR,
					A.HOUR_ST,
					A.HOUR_DCD
				) VALUES ( 
					B.ITEM_CODE,
					B.BRANCH_NO,
					B.FACT_CODE,
					B.HOUR_TIME,
					B.HOUR_RTIME,
					B.HOUR_DUMP,
					B.HOUR_VL,
					B.HOUR_OR,
					B.HOUR_ST,
					B.HOUR_DCD 
				)
	</insert>
	
	
	<!-- 데이터 선별 이력 SELECT SQL -->
	<sql id="getSelectHisList_SQL">
		SELECT
			  A.SEL_SEQ
			, A.FACT_CODE
			, A.BRANCH_NO
			, D.BRANCH_NAME||'-'||A.BRANCH_NO AS BRANCH_NAME
			, CASE
				WHEN A.SEL_ITEM = 'all' THEN '전체'
				WHEN A.SEL_ITEM != 'all' THEN (SELECT ITEM_NAME FROM T_ITEM_INFO WHERE ITEM_CODE = A.SEL_ITEM)
				END AS SEL_ITEM
			, CASE
				WHEN A.LIMIT_YN = 'N' THEN '전체'
				WHEN A.LIMIT_YN = 'Y' THEN '이상데이터'
				END AS LIMIT_YN
			, A.STR_TIME
			, A.END_TIME
			, CASE
				WHEN A.DEL_YN = 'Y' THEN '삭제'
				WHEN A.DEL_YN = 'N' THEN '적용'
				END AS DEL_YN
			, A.SEL_REASON
			, A.ATCH_FILE_ID
			, A.REG_ID
			, (SELECT MEMBER_NAME FROM T_MEMBER WHERE MEMBER_ID = A.REG_ID) AS REG_NAME
			, A.REG_DATE
			, C.RIVER_DIV
			, DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			, A.DEL_ID
			, (SELECT MEMBER_NAME FROM T_MEMBER WHERE MEMBER_ID = A.DEL_ID) AS DEL_NAME
			, A.DEL_DATE
			, CASE
				WHEN A.USE_FLAG = 'Y' THEN '선별'
				WHEN A.USE_FLAG = 'N' THEN '선별취소'
				END AS USE_FLAG
		FROM (
			SELECT
				  SEL_SEQ
				, FACT_CODE
				, BRANCH_NO
				, SEL_ITEM
				, LIMIT_YN
				, STR_TIME
				, END_TIME
				, DEL_YN
				, SEL_REASON
				, ATCH_FILE_ID
				, REG_ID
				, REG_DATE
				, DEL_ID
				, DEL_DATE
				, USE_FLAG
			FROM (
				SELECT
					  A.SEL_SEQ
					, B.FACT_CODE
					, B.BRANCH_NO
					, A.SEL_ITEM
					, A.LIMIT_YN
					, A.STR_TIME
					, A.END_TIME
					, A.DEL_YN
					, A.SEL_REASON
					, A.ATCH_FILE_ID
					, A.REG_ID
					, A.REG_DATE
					, A.DEL_ID
					, A.DEL_DATE
					, A.USE_FLAG
				FROM T_SELECT A, T_SELECT_ITEM B
				WHERE A.SEL_SEQ = B.SEL_SEQ
					AND A.REG_DATE BETWEEN #str_time# AND #end_time#
					AND B.FACT_CODE = #fact_code#
					<isNotEqual property="branch_no" compareValue="all">
						AND B.BRANCH_NO = #branch_no#
					</isNotEqual>
					<isNotEqual property="sel_item" compareValue="all">
						AND B.ITEM_CODE = #sel_item#
					</isNotEqual>
					<isNotEqual property="del_yn" compareValue="all">
						AND A.DEL_YN = #del_yn#
					</isNotEqual>
					<isNotEqual property="use_flag" compareValue="all">
						AND A.USE_FLAG = #use_flag#
					</isNotEqual>
			)
			GROUP BY SEL_SEQ, FACT_CODE, BRANCH_NO, SEL_ITEM, LIMIT_YN, STR_TIME, END_TIME, DEL_YN, SEL_REASON, ATCH_FILE_ID, REG_ID, REG_DATE, DEL_ID, DEL_DATE, USE_FLAG
		) A, T_FACT_INFO C, T_FACT_BRANCH_INFO D
		WHERE A.FACT_CODE = C.FACT_CODE
			AND A.FACT_CODE = D.FACT_CODE
			AND A.BRANCH_NO = D.BRANCH_NO
			AND C.FACT_USE_FLAG = 'Y'
			AND D.BRANCH_USE_FLAG = 'Y'
		ORDER BY A.REG_DATE DESC
	</sql>
	
	<select id="getSelectHisList" parameterClass="selectDataVO" resultClass="selectDataVO">
		<include refid="getSelectHisList_SQL"/>
	</select>
	
	<!-- 데이터 선별 보고서 SELECT SQL -->
	<sql id="getSelectDataReportList_SQL">
		SELECT
			  A.SEL_SEQ
			, A.FACT_CODE
			, A.BRANCH_NO
			, D.BRANCH_NAME||'-'||A.BRANCH_NO AS BRANCH_NAME
			, CASE
				WHEN A.SEL_ITEM = 'all' THEN '전체'
				WHEN A.SEL_ITEM != 'all' THEN (SELECT ITEM_NAME FROM T_ITEM_INFO WHERE ITEM_CODE = A.SEL_ITEM)
				END AS SEL_ITEM
			, CASE
				WHEN A.LIMIT_YN = 'N' THEN '전체'
				WHEN A.LIMIT_YN = 'Y' THEN '이상데이터'
				END AS LIMIT_YN
			, SUBSTR(A.STR_TIME,0,8)||' '||SUBSTR(A.STR_TIME,9,2)||':'||SUBSTR(A.STR_TIME,11,2) STR_TIME
 	 		, SUBSTR(A.END_TIME,0,8)||' '||SUBSTR(A.END_TIME,9,2)||':'||SUBSTR(A.END_TIME,11,2) END_TIME
			, CASE
				WHEN A.DEL_YN = 'Y' THEN '삭제'
				WHEN A.DEL_YN = 'N' THEN '적용'
				END AS DEL_YN
			, A.SEL_REASON
			, A.ATCH_FILE_ID
			, (SELECT COUNT(*) FROM T_FILEDETAIL WHERE ATCH_FILE_ID = A.ATCH_FILE_ID) FILE_CNT
			, A.REG_ID
			, (SELECT MEMBER_NAME FROM T_MEMBER WHERE MEMBER_ID = A.REG_ID) AS REG_NAME
			, A.REG_DATE
			, C.RIVER_DIV
			, DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			, A.DEL_ID
			, (SELECT MEMBER_NAME FROM T_MEMBER WHERE MEMBER_ID = A.DEL_ID) AS DEL_NAME
			, A.DEL_DATE
			, CASE
				WHEN A.USE_FLAG = 'Y' THEN '선별'
				WHEN A.USE_FLAG = 'N' THEN '선별취소'
				END AS USE_FLAG
			, STATUS_CONTENT
		FROM (
			SELECT
				  SEL_SEQ
				, FACT_CODE
				, BRANCH_NO
				, SEL_ITEM
				, LIMIT_YN
				, STR_TIME
				, END_TIME
				, DEL_YN
				, SEL_REASON
				, ATCH_FILE_ID
				, REG_ID
				, REG_DATE
				, DEL_ID
				, DEL_DATE
				, USE_FLAG
				, STATUS_CONTENT
			FROM (
				SELECT
					  A.SEL_SEQ
					, B.FACT_CODE
					, B.BRANCH_NO
					, A.SEL_ITEM
					, A.LIMIT_YN
					, A.STR_TIME
					, A.END_TIME
					, A.DEL_YN
					, A.SEL_REASON
					, A.ATCH_FILE_ID
					, A.REG_ID
					, A.REG_DATE
					, A.DEL_ID
					, A.DEL_DATE
					, A.USE_FLAG
					, C.STATUS_DESC||DECODE(C.STATUS_DETAIL,NULL,'','_')||C.STATUS_DETAIL STATUS_CONTENT
				FROM T_SELECT A, T_SELECT_ITEM B, T_DEFINITE_MAPPING_CODE C
				WHERE A.SEL_SEQ = B.SEL_SEQ
					AND A.STR_TIME BETWEEN #searchYear#||#searchMonth#||'010000' AND #searchYear#||#searchMonth#||#lastDay#||'2359'
					AND B.FACT_CODE = #fact_code#
					AND B.BRANCH_NO = #branch_no#
					AND A.USE_FLAG = 'Y'
					AND A.SEL_STATUS = C.STATUS_CODE(+)
			)
			GROUP BY SEL_SEQ, FACT_CODE, BRANCH_NO, SEL_ITEM, LIMIT_YN, STR_TIME, END_TIME, DEL_YN, SEL_REASON, ATCH_FILE_ID, REG_ID, REG_DATE, DEL_ID, DEL_DATE, USE_FLAG, STATUS_CONTENT
		) A, T_FACT_INFO C, T_FACT_BRANCH_INFO D
		WHERE A.FACT_CODE = C.FACT_CODE
			AND A.FACT_CODE = D.FACT_CODE
			AND A.BRANCH_NO = D.BRANCH_NO
			AND C.FACT_USE_FLAG = 'Y'
			AND D.BRANCH_USE_FLAG = 'Y'
		ORDER BY A.REG_DATE DESC
	</sql>
	
	
	<select id="getSelectDataReportList" parameterClass="selectDataVO" resultClass="selectDataVO">
		<include refid="getSelectDataReportList_SQL"/>
	</select>
	
	<select id="getSelectHisCnt" parameterClass="selectDataVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*) FROM (
			<include refid="getSelectHisList_SQL"/>
		)
	</select>
	
	
	<!-- 데이터 확정 이력 SELECT SQL -->
	<sql id="getDefiniteHisList_SQL">
		SELECT
			  A.FACT_CODE
			, A.BRANCH_NO
			, D.BRANCH_NAME||'-'||A.BRANCH_NO AS BRANCH_NAME
			, A.STR_TIME
			, A.END_TIME
			, CASE
				WHEN A.DEFINITE_TYPE = 'SET' THEN '확정'
				WHEN A.DEFINITE_TYPE = 'DEL' THEN '확정취소'
				END AS DEFINITE_TYPE
			, A.REG_ID
			, (SELECT MEMBER_NAME FROM T_MEMBER WHERE MEMBER_ID = A.REG_ID) AS REG_NAME
			, A.REG_DATE
			, C.RIVER_DIV
			, DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
		FROM T_DEFINITE A, T_FACT_INFO C, T_FACT_BRANCH_INFO D
		WHERE A.FACT_CODE = C.FACT_CODE
			AND A.FACT_CODE = D.FACT_CODE
			AND A.BRANCH_NO = D.BRANCH_NO
			AND C.FACT_USE_FLAG = 'Y'
			AND D.BRANCH_USE_FLAG = 'Y'
			AND A.REG_DATE BETWEEN #str_time# AND #end_time#
			AND A.FACT_CODE = #fact_code#
			<isNotEqual property="branch_no" compareValue="all">
				AND A.BRANCH_NO = #branch_no#
			</isNotEqual>
			<isNotEqual property="definite_type" compareValue="all">
				AND A.DEFINITE_TYPE = #definite_type#
			</isNotEqual>
		ORDER BY A.REG_DATE DESC
	</sql>
	
	<select id="getDefiniteHisList" parameterClass="selectDataVO" resultClass="selectDataVO">
		<include refid="getDefiniteHisList_SQL"/>
	</select>
	
	<select id="getDefiniteHisCnt" parameterClass="selectDataVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*) FROM (
			<include refid="getDefiniteHisList_SQL"/>
		)
	</select>
	
	
	<select id="getCntDefiniteData" parameterClass="selectDataVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*) FROM T_MIN_DATA_DEFINITE
		WHERE FACT_CODE = #fact_code#
			AND BRANCH_NO = #branch_no#
			AND MIN_TIME BETWEEN #str_time# AND #end_time#
	</select>
	
	<update id="deleteDefiniteData" parameterClass="selectDataVO">
		DELETE FROM T_MIN_DATA_DEFINITE
		WHERE FACT_CODE = #fact_code#
			AND BRANCH_NO = #branch_no#
			AND MIN_TIME BETWEEN #str_time# AND #end_time#
	</update>

	<update id="deleteDefiniteDataHour" parameterClass="selectDataVO">
		DELETE FROM T_HOUR_DATA_DEFINITE
		WHERE FACT_CODE = #fact_code#
			AND BRANCH_NO = #branch_no#
			AND HOUR_TIME BETWEEN SUBSTR(#str_time#, 0, 10) AND SUBSTR(#end_time#, 0, 10)
	</update>
	
	
	
	<!-- 측정소 데이터 확정 조회 (Min) SQL -->
	<sql id="getDefiniteMinDataList_SQL">
		WITH FACT_LIMIT AS (
		  SELECT
		      FACT_CODE
		    , BRANCH_NO
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_HI)) AS TUR_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_LO)) AS TUR_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_HI)) AS DOW_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_LO)) AS DOW_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_HI)) AS TMP_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_LO)) AS TMP_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_HI)) AS PHY_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_LO)) AS PHY_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_HI)) AS CON_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_LO)) AS CON_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_HI)) AS TOF_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_LO)) AS TOF_VALUE_LO
		  FROM T_ITEM_INFO_FACT
		  WHERE FACT_CODE = #fact_code#
		  	<isNotEqual property="branch_no" compareValue="all">
				AND BRANCH_NO = #branch_no#
		    </isNotEqual>
		  GROUP BY FACT_CODE, BRANCH_NO
		)
		SELECT A.*, B.TUR2, B.TUR_ST2, B.DOW2, B.DOW_ST2, B.TMP2, B.TMP_ST2, B.PHY2, B.PHY_ST2, B.CON2, B.CON_ST2, B.TOF2, B.TOF_ST2 FROM (
			SELECT
			    QQ.FACT_CODE FACT_CODE
			  , QQ.BRANCH_NO BRANCH_NO
			  , QQ.BRANCH_NAME BRANCH_NAME
			  , QQ.MIN_TIME MIN_TIME
			  , QQ.STR_DATE
			  , QQ.STR_TIME
			  , TUR
			  , TUR_OR
			  , TUR_ST
			  , DOW
			  , DOW_OR
			  , DOW_ST
			  , TMP
			  , TMP_OR
			  , TMP_ST
			  , PHY
			  , PHY_OR
			  , PHY_ST
			  , CON
			  , CON_OR
			  , CON_ST
			  , TOF
			  , TOF_OR
			  , TOF_ST
			  <![CDATA[
			  , CASE WHEN (
	    			(((SELECT TUR_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TUR > (SELECT TUR_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TUR_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TUR < (SELECT TUR_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TUR_OVER
			  , CASE WHEN (
	    			(((SELECT DOW_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (DOW > (SELECT DOW_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT DOW_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (DOW < (SELECT DOW_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS DOW_OVER
			  , CASE WHEN (
	    			(((SELECT TMP_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TMP > (SELECT TMP_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TMP_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TMP < (SELECT TMP_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TMP_OVER
			  , CASE WHEN (
	    			(((SELECT PHY_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (PHY > (SELECT PHY_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT PHY_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (PHY < (SELECT PHY_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS PHY_OVER
			  , CASE WHEN (
	    			(((SELECT CON_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (CON > (SELECT CON_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT CON_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (CON < (SELECT CON_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS CON_OVER
			  , CASE WHEN (
	    			(((SELECT TOF_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TOF > (SELECT TOF_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TOF_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TOF < (SELECT TOF_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TOF_OVER
			  ]]>
			  , AA.MIN_DUMP
			  , QQ.RIVER_NAME
			  , QQ.SYS_KIND_NAME
			  , QQ.SYS_KIND
			  , QQ.RIVER_DIV
			FROM (
			  SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , MIN_DUMP
			    , SUM(TUR) AS TUR
			    , SUM(TUR_OR) AS TUR_OR
			    , SUM(TUR_ST) AS TUR_ST
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW
			    , SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) AS DOW_OR
			    , SUM(DECODE(DOW2, NULL, DOW_ST, DOW2_ST)) AS DOW_ST
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP
			    , SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) AS TMP_OR
			    , SUM(DECODE(TMP2, NULL, TMP_ST, TMP2_ST)) AS TMP_ST
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY
			    , SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) AS PHY_OR
			    , SUM(DECODE(PHY2, NULL, PHY_ST, PHY2_ST)) AS PHY_ST
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON
			    , SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) AS CON_OR
			    , SUM(DECODE(CON2, NULL, CON_ST, CON2_ST)) AS CON_ST
			    , SUM(TOF) AS TOF
			    , SUM(TOF_OR) AS TOF_OR
			    , SUM(TOF_ST) AS TOF_ST
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			  FROM (
			    SELECT
			        DISTINCT A.ITEM_CODE AS ITEM_CODE
			      , B.ITEM_NAME AS ITEM_NAME
			      , A.FACT_CODE AS FACT_CODE
			      , A.BRANCH_NO AS BRANCH_NO
			      , D.BRANCH_NAME||'-'||A.BRANCH_NO AS BRANCH_NAME
			      , A.MIN_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , A.MIN_RTIME AS MIN_RTIME
			      , A.MIN_DUMP AS MIN_DUMP
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_VL) AS TUR
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_OR) AS TUR_OR
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_ST) AS TUR_ST
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_VL) AS DOW
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_OR) AS DOW_OR
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_ST) AS DOW_ST
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_VL) AS DOW2
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_OR) AS DOW2_OR
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_ST) AS DOW2_ST
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) AS TMP
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_OR) AS TMP_OR
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_ST) AS TMP_ST
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) AS TMP2
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_OR) AS TMP2_OR
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_ST) AS TMP2_ST
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_VL) AS PHY
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_OR) AS PHY_OR
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_ST) AS PHY_ST
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_VL) AS PHY2
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_OR) AS PHY2_OR
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_ST) AS PHY2_ST
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_VL) AS CON
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_OR) AS CON_OR
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_ST) AS CON_ST
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_VL) AS CON2
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_OR) AS CON2_OR
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_ST) AS CON2_ST
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) AS TOF
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_OR) AS TOF_OR
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_ST) AS TOF_ST
			      , C.RIVER_DIV
			      , DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , C.SYS_KIND
			      , ( SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = C.SYS_KIND) AS SYS_KIND_NAME
			    FROM
                    (SELECT 
                           /*+INDEX(T_MIN_DATA IX_MIN_DATA_04)*/ 
                           FACT_CODE, 
                           BRANCH_NO, 
                           MIN_TIME, 
                           ITEM_CODE, 
                           MIN_VL, 
                           MIN_OR, 
                           MIN_ST, 
                           MIN_DUMP, 
                           MIN_RTIME, 
                           MIN_DCD 
                      FROM T_MIN_DATA, 
                           (SELECT MIN(min_time) startTime, 
                                   MAX(min_time) endTime 
                             FROM 
                                  (SELECT ROWNUM rn, 
                                              TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME 
                                         FROM 
                                              (SELECT TO_DATE(#searchYear#||#searchMonth#||#searchDay2#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT 
                                                FROM DUAL
                                              <![CDATA[
                                              ) CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT 
                                              ]]> 
                                       ) 
                            WHERE 1=1
                            <isNotEqual property="countYn" compareValue="Y">
	                   		<![CDATA[
                              AND rn > #firstIndex# 
                              AND rn <= #firstIndex# + #recordCountPerPage#
                            ]]> 
                   			</isNotEqual>	  
                           ) B 
                     WHERE 1=1 
                           AND FACT_CODE = #fact_code# 
                           AND BRANCH_NO = #branch_no# 
                           /* AND ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00') */
                           <iterate prepend=" AND ITEM_CODE IN " property="item_list" open="(" close=")" conjunction=",">
							#item_list[]#
			      		   </iterate>
                           AND MIN_TIME BETWEEN B.startTime AND B.endTime 
                           
                    ) A
			      , T_WEATHER_AREA AREA
			      , T_ITEM_INFO B
			      , T_FACT_INFO C
			      , T_FACT_BRANCH_INFO D
			      , T_FACT_MEASU_ITEM I
			      , T_WQA_ITEM M
			    WHERE A.FACT_CODE = AREA.FACT_CODE(+)
			      AND A.BRANCH_NO = AREA.BRANCH_NO(+)
			      AND A.ITEM_CODE = B.ITEM_CODE
			      AND I.ITEM_CODE = A.ITEM_CODE
			      AND I.FACT_CODE = A.FACT_CODE
			      AND I.BRANCH_NO = A.BRANCH_NO
			      AND I.ITEM_USE_FLAG = 'Y'
			      AND A.FACT_CODE = C.FACT_CODE
			      AND C.FACT_CODE = D.FACT_CODE
			      AND A.BRANCH_NO = D.BRANCH_NO
			      AND D.BRANCH_USE_FLAG = 'Y'
			      AND C.FACT_USE_FLAG = 'Y'
			      AND C.RIVER_DIV = #river_div#
			      AND C.SYS_KIND = 'U'
			      AND M.ITEM_CODE = A.ITEM_CODE
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
			    , MIN_DUMP
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			) AA, (
			  SELECT
			      Q.MIN_TIME
			    , TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			    , TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI')    AS STR_TIME
			    , A.FACT_CODE
			    , A.BRANCH_NO
			    , A.FACT_NAME
			    , A.BRANCH_NAME
			    , A.SYS_KIND
			    , A.RIVER_NAME
			    , A.SYS_KIND_NAME
			    , A.RIVER_DIV
			  FROM (
			    SELECT TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
			    FROM (
			      SELECT TO_DATE(#searchYear#||#searchMonth#||#searchDay2#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
			      FROM DUAL
			    )
			    <![CDATA[
			    CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT
			    ]]>
			  ) Q, (
			    SELECT
			        B.FACT_CODE
			      , B.BRANCH_NO
			      , AREA.REG_NAME AS FACT_NAME
			      , B.BRANCH_NAME||'-'||B.BRANCH_NO AS BRANCH_NAME
			      , F.RIVER_DIV
			      , DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , F.SYS_KIND
			      , (SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = F.SYS_KIND) AS SYS_KIND_NAME
			    FROM
			        T_FACT_INFO F
			      , T_FACT_BRANCH_INFO B
			      , T_WEATHER_AREA AREA
			    WHERE F.FACT_CODE = B.FACT_CODE
			      AND B.BRANCH_USE_FLAG = 'Y'
			      AND AREA.FACT_CODE(+) = B.FACT_CODE
			      AND F.RIVER_DIV = #river_div#
			      AND AREA.BRANCH_NO(+) = B.BRANCH_NO
			      AND F.FACT_CODE = #fact_code#
			      <isNotEqual property="branch_no" compareValue="all">
					  AND B.BRANCH_NO = #branch_no#
				  </isNotEqual>
			      AND F.SYS_KIND = 'U'
			  ) A
			  <![CDATA[
			  WHERE TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE
			  ]]>
			) QQ
			WHERE AA.MIN_TIME(+) = QQ.MIN_TIME
			  AND AA.FACT_CODE(+) = QQ.FACT_CODE
			  AND AA.BRANCH_NO(+) = QQ.BRANCH_NO
		) A  LEFT OUTER JOIN (
		    SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , SUM(TUR) AS TUR2
			    , SUM(TUR_ST)                        AS TUR_ST2
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW2
			    , SUM(DOW_ST)                        AS DOW_ST2
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP2
			    , SUM(TMP_ST)                        AS TMP_ST2
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY2
			    , SUM(PHY_ST) AS PHY_ST2
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON2
			    , SUM(CON_ST) AS CON_ST2
			    , SUM(TOF) AS TOF2
			    , SUM(TOF_ST)                        AS TOF_ST2
			  FROM (
			    SELECT
			        DISTINCT ITEM_CODE AS ITEM_CODE
			      , FACT_CODE AS FACT_CODE
			      , BRANCH_NO AS BRANCH_NO
			      , MIN_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , DECODE(ITEM_CODE, 'TUR00', MIN_VL) AS TUR
			      , DECODE(ITEM_CODE, 'TUR00', MIN_ST)                       AS TUR_ST
			      , DECODE(ITEM_CODE, 'DOW00', MIN_VL) AS DOW
			      , DECODE(ITEM_CODE, 'DOW01', MIN_VL) AS DOW2
			      , DECODE(ITEM_CODE, 'DOW00', MIN_ST)                       AS DOW_ST
			      , DECODE(ITEM_CODE, 'TMP00', MIN_VL) AS TMP
			      , DECODE(ITEM_CODE, 'TMP01', MIN_VL) AS TMP2
			      , DECODE(ITEM_CODE, 'TMP00', MIN_ST)                       AS TMP_ST
			      , DECODE(ITEM_CODE, 'PHY00', MIN_VL) AS PHY
			      , DECODE(ITEM_CODE, 'PHY01', MIN_VL) AS PHY2
			      , DECODE(ITEM_CODE, 'PHY00', MIN_ST)                       AS PHY_ST
			      , DECODE(ITEM_CODE, 'CON00', MIN_VL) AS CON
			      , DECODE(ITEM_CODE, 'CON01', MIN_VL) AS CON2
			      , DECODE(ITEM_CODE, 'CON00', MIN_ST)                       AS CON_ST
			      , DECODE(ITEM_CODE, 'TOF00', MIN_VL) AS TOF
			      , DECODE(ITEM_CODE, 'TOF00', MIN_ST)                       AS TOF_ST
			    FROM
			        T_MIN_DATA_DEFINITE
			    WHERE FACT_CODE = #fact_code#
				    <isNotEqual property="branch_no" compareValue="all">
						AND BRANCH_NO = #branch_no#
				    </isNotEqual>
				    <![CDATA[
					AND SUBSTR(MIN_TIME, 0, 8) >= #searchYear#||#searchMonth#||#searchDay1#
					AND SUBSTR(MIN_TIME, 0, 8) <= #searchYear#||#searchMonth#||#searchDay2#
					]]>
<!-- 					AND ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00') -->
					<iterate prepend=" AND ITEM_CODE IN " property="item_list" open="(" close=")" conjunction=",">
						#item_list[]#
			      	</iterate>
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
		) B
		ON (
			A.FACT_CODE = B.FACT_CODE
			AND A.BRANCH_NO = B.BRANCH_NO
			AND A.MIN_TIME = B.MIN_TIME
		)
		WHERE 1=1
		<isNotEqual property="strange" compareValue="all">
			AND (TUR_OVER > 0 OR DOW_OVER > 0 OR TMP_OVER > 0 OR PHY_OVER > 0 OR CON_OVER > 0 OR TOF_OVER > 0)
		</isNotEqual>
	</sql>
	
	<!-- 측정소 데이터 확정 조회 (Min) SQL -->
	<sql id="getDefiniteMinDataListSum_SQL">
		WITH FACT_LIMIT AS (
		  SELECT
		      FACT_CODE
		    , BRANCH_NO
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_HI)) AS TUR_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_LO)) AS TUR_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_HI)) AS DOW_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_LO)) AS DOW_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_HI)) AS TMP_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_LO)) AS TMP_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_HI)) AS PHY_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_LO)) AS PHY_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_HI)) AS CON_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_LO)) AS CON_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_HI)) AS TOF_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_LO)) AS TOF_VALUE_LO
		  FROM T_ITEM_INFO_FACT
		  WHERE FACT_CODE = #fact_code#
		  	<isNotEqual property="branch_no" compareValue="all">
				AND BRANCH_NO = #branch_no#
		    </isNotEqual>
		  GROUP BY FACT_CODE, BRANCH_NO
		)
		SELECT A.*, B.TUR2, B.TUR_ST2, B.DOW2, B.DOW_ST2, B.TMP2, B.TMP_ST2, B.PHY2, B.PHY_ST2, B.CON2, B.CON_ST2, B.TOF2, B.TOF_ST2 FROM (
			SELECT
			    QQ.FACT_CODE FACT_CODE
			  , QQ.BRANCH_NO BRANCH_NO
			  , QQ.BRANCH_NAME BRANCH_NAME
			  , QQ.MIN_TIME MIN_TIME
			  , QQ.STR_DATE
			  , QQ.STR_TIME
			  , TUR
			  , TUR_OR
			  , TUR_ST
			  , DOW
			  , DOW_OR
			  , DOW_ST
			  , TMP
			  , TMP_OR
			  , TMP_ST
			  , PHY
			  , PHY_OR
			  , PHY_ST
			  , CON
			  , CON_OR
			  , CON_ST
			  , TOF
			  , TOF_OR
			  , TOF_ST
			  <![CDATA[
			  , CASE WHEN (
	    			(((SELECT TUR_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TUR > (SELECT TUR_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TUR_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TUR < (SELECT TUR_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TUR_OVER
			  , CASE WHEN (
	    			(((SELECT DOW_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (DOW > (SELECT DOW_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT DOW_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (DOW < (SELECT DOW_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS DOW_OVER
			  , CASE WHEN (
	    			(((SELECT TMP_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TMP > (SELECT TMP_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TMP_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TMP < (SELECT TMP_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TMP_OVER
			  , CASE WHEN (
	    			(((SELECT PHY_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (PHY > (SELECT PHY_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT PHY_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (PHY < (SELECT PHY_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS PHY_OVER
			  , CASE WHEN (
	    			(((SELECT CON_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (CON > (SELECT CON_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT CON_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (CON < (SELECT CON_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS CON_OVER
			  , CASE WHEN (
	    			(((SELECT TOF_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TOF > (SELECT TOF_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TOF_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TOF < (SELECT TOF_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TOF_OVER
			  ]]>
			  , AA.MIN_DUMP
			  , QQ.RIVER_NAME
			  , QQ.SYS_KIND_NAME
			  , QQ.SYS_KIND
			  , QQ.RIVER_DIV
			FROM (
			  SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , MIN_DUMP
			    , SUM(TUR) AS TUR
			    , SUM(TUR_OR) AS TUR_OR
			    , SUM(TUR_ST) AS TUR_ST
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW
			    , SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) AS DOW_OR
			    , SUM(DECODE(DOW2, NULL, DOW_ST, DOW2_ST)) AS DOW_ST
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP
			    , SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) AS TMP_OR
			    , SUM(DECODE(TMP2, NULL, TMP_ST, TMP2_ST)) AS TMP_ST
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY
			    , SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) AS PHY_OR
			    , SUM(DECODE(PHY2, NULL, PHY_ST, PHY2_ST)) AS PHY_ST
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON
			    , SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) AS CON_OR
			    , SUM(DECODE(CON2, NULL, CON_ST, CON2_ST)) AS CON_ST
			    , SUM(TOF) AS TOF
			    , SUM(TOF_OR) AS TOF_OR
			    , SUM(TOF_ST) AS TOF_ST
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			  FROM (
			    SELECT
			        DISTINCT A.ITEM_CODE AS ITEM_CODE
			      , B.ITEM_NAME AS ITEM_NAME
			      , A.FACT_CODE AS FACT_CODE
			      , A.BRANCH_NO AS BRANCH_NO
			      , D.BRANCH_NAME||'-'||A.BRANCH_NO AS BRANCH_NAME
			      , A.MIN_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(A.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , A.MIN_RTIME AS MIN_RTIME
			      , A.MIN_DUMP AS MIN_DUMP
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_VL) AS TUR
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_OR) AS TUR_OR
			      , DECODE(A.ITEM_CODE, 'TUR00', MIN_ST) AS TUR_ST
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_VL) AS DOW
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_OR) AS DOW_OR
			      , DECODE(A.ITEM_CODE, 'DOW00', MIN_ST) AS DOW_ST
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_VL) AS DOW2
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_OR) AS DOW2_OR
			      , DECODE(A.ITEM_CODE, 'DOW01', MIN_ST) AS DOW2_ST
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_VL) AS TMP
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_OR) AS TMP_OR
			      , DECODE(A.ITEM_CODE, 'TMP00', MIN_ST) AS TMP_ST
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_VL) AS TMP2
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_OR) AS TMP2_OR
			      , DECODE(A.ITEM_CODE, 'TMP01', MIN_ST) AS TMP2_ST
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_VL) AS PHY
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_OR) AS PHY_OR
			      , DECODE(A.ITEM_CODE, 'PHY00', MIN_ST) AS PHY_ST
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_VL) AS PHY2
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_OR) AS PHY2_OR
			      , DECODE(A.ITEM_CODE, 'PHY01', MIN_ST) AS PHY2_ST
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_VL) AS CON
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_OR) AS CON_OR
			      , DECODE(A.ITEM_CODE, 'CON00', MIN_ST) AS CON_ST
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_VL) AS CON2
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_OR) AS CON2_OR
			      , DECODE(A.ITEM_CODE, 'CON01', MIN_ST) AS CON2_ST
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_VL) AS TOF
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_OR) AS TOF_OR
			      , DECODE(A.ITEM_CODE, 'TOF00', MIN_ST) AS TOF_ST
			      , C.RIVER_DIV
			      , DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , C.SYS_KIND
			      , ( SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = C.SYS_KIND) AS SYS_KIND_NAME
			    FROM
                    (SELECT 
                           /*+INDEX(T_MIN_DATA IX_MIN_DATA_04)*/ 
                           FACT_CODE, 
                           BRANCH_NO, 
                           MIN_TIME, 
                           ITEM_CODE, 
                           MIN_VL, 
                           MIN_OR, 
                           MIN_ST, 
                           MIN_DUMP, 
                           MIN_RTIME, 
                           MIN_DCD 
                      FROM T_MIN_DATA, 
                           (SELECT MIN(min_time) startTime, 
                                   MAX(min_time) endTime 
                             FROM 
                                  (SELECT ROWNUM rn, 
                                         TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME 
                                    FROM 
                                         (SELECT TO_DATE(#searchYear#||#searchMonth#||#searchDay2#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT 
                                           FROM DUAL 
                                         <![CDATA[
                                         ) CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT 
                                         ]]>
                                  ) 
                            WHERE 1=1
                            <isNotEqual property="countYn" compareValue="Y">
	                   		<![CDATA[
                              AND rn > #firstIndex# 
                              AND rn <= #firstIndex# + #recordCountPerPage#
                            ]]> 
                   			</isNotEqual>	  
                           ) B 
                     WHERE 1=1 
                           AND FACT_CODE = #fact_code# 
                           AND BRANCH_NO = #branch_no# 
                           /* AND ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00') */
                           <iterate prepend=" AND ITEM_CODE IN " property="item_list" open="(" close=")" conjunction=",">
							#item_list[]#
			      		   </iterate>
                           AND MIN_TIME BETWEEN B.startTime AND B.endTime 
                           
                    ) A
			      , T_WEATHER_AREA AREA
			      , T_ITEM_INFO B
			      , T_FACT_INFO C
			      , T_FACT_BRANCH_INFO D
			      , T_FACT_MEASU_ITEM I
			      , T_WQA_ITEM M
			    WHERE A.FACT_CODE = AREA.FACT_CODE(+)
			      AND A.BRANCH_NO = AREA.BRANCH_NO(+)
			      AND A.ITEM_CODE = B.ITEM_CODE
			      AND I.ITEM_CODE = A.ITEM_CODE
			      AND I.FACT_CODE = A.FACT_CODE
			      AND I.BRANCH_NO = A.BRANCH_NO
			      AND I.ITEM_USE_FLAG = 'Y'
			      AND A.FACT_CODE = C.FACT_CODE
			      AND C.FACT_CODE = D.FACT_CODE
			      AND A.BRANCH_NO = D.BRANCH_NO
			      AND D.BRANCH_USE_FLAG = 'Y'
			      AND C.FACT_USE_FLAG = 'Y'
			      AND C.RIVER_DIV = #river_div#
			      AND C.SYS_KIND = 'U'
			      AND M.ITEM_CODE = A.ITEM_CODE
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
			    , MIN_DUMP
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			) AA, (
			  SELECT
			      Q.MIN_TIME
			    , TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			    , TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI')    AS STR_TIME
			    , A.FACT_CODE
			    , A.BRANCH_NO
			    , A.FACT_NAME
			    , A.BRANCH_NAME
			    , A.SYS_KIND
			    , A.RIVER_NAME
			    , A.SYS_KIND_NAME
			    , A.RIVER_DIV
			  FROM (
			    SELECT TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
			    FROM (
			      SELECT TO_DATE(#searchYear#||#searchMonth#||#searchDay2#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
			      FROM DUAL
			    )
			    <![CDATA[
			    CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT
			    ]]>
			  ) Q, (
			    SELECT
			        B.FACT_CODE
			      , B.BRANCH_NO
			      , AREA.REG_NAME AS FACT_NAME
			      , B.BRANCH_NAME||'-'||B.BRANCH_NO AS BRANCH_NAME
			      , F.RIVER_DIV
			      , DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , F.SYS_KIND
			      , (SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = F.SYS_KIND) AS SYS_KIND_NAME
			    FROM
			        T_FACT_INFO F
			      , T_FACT_BRANCH_INFO B
			      , T_WEATHER_AREA AREA
			    WHERE F.FACT_CODE = B.FACT_CODE
			      AND B.BRANCH_USE_FLAG = 'Y'
			      AND AREA.FACT_CODE(+) = B.FACT_CODE
			      AND F.RIVER_DIV = #river_div#
			      AND AREA.BRANCH_NO(+) = B.BRANCH_NO
			      AND F.FACT_CODE = #fact_code#
			      <isNotEqual property="branch_no" compareValue="all">
					  AND B.BRANCH_NO = #branch_no#
				  </isNotEqual>
			      AND F.SYS_KIND = 'U'
			  ) A
			  <![CDATA[
			  WHERE TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE
			  ]]>
			) QQ
			WHERE AA.MIN_TIME(+) = QQ.MIN_TIME
			  AND AA.FACT_CODE(+) = QQ.FACT_CODE
			  AND AA.BRANCH_NO(+) = QQ.BRANCH_NO
		) A  LEFT OUTER JOIN (
		    SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , SUM(TUR) AS TUR2
			    , SUM(TUR_ST)                        AS TUR_ST2
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW2
			    , SUM(DOW_ST)                        AS DOW_ST2
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP2
			    , SUM(TMP_ST)                        AS TMP_ST2
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY2
			    , SUM(PHY_ST) AS PHY_ST2
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON2
			    , SUM(CON_ST) AS CON_ST2
			    , SUM(TOF) AS TOF2
			    , SUM(TOF_ST)                        AS TOF_ST2
			  FROM (
			    SELECT
			        DISTINCT ITEM_CODE AS ITEM_CODE
			      , FACT_CODE AS FACT_CODE
			      , BRANCH_NO AS BRANCH_NO
			      , MIN_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , DECODE(ITEM_CODE, 'TUR00', MIN_VL) AS TUR
			      , DECODE(ITEM_CODE, 'TUR00', MIN_ST)                       AS TUR_ST
			      , DECODE(ITEM_CODE, 'DOW00', MIN_VL) AS DOW
			      , DECODE(ITEM_CODE, 'DOW01', MIN_VL) AS DOW2
			      , DECODE(ITEM_CODE, 'DOW00', MIN_ST)                       AS DOW_ST
			      , DECODE(ITEM_CODE, 'TMP00', MIN_VL) AS TMP
			      , DECODE(ITEM_CODE, 'TMP01', MIN_VL) AS TMP2
			      , DECODE(ITEM_CODE, 'TMP00', MIN_ST)                       AS TMP_ST
			      , DECODE(ITEM_CODE, 'PHY00', MIN_VL) AS PHY
			      , DECODE(ITEM_CODE, 'PHY01', MIN_VL) AS PHY2
			      , DECODE(ITEM_CODE, 'PHY00', MIN_ST)                       AS PHY_ST
			      , DECODE(ITEM_CODE, 'CON00', MIN_VL) AS CON
			      , DECODE(ITEM_CODE, 'CON01', MIN_VL) AS CON2
			      , DECODE(ITEM_CODE, 'CON00', MIN_ST)                       AS CON_ST
			      , DECODE(ITEM_CODE, 'TOF00', MIN_VL) AS TOF
			      , DECODE(ITEM_CODE, 'TOF00', MIN_ST)                       AS TOF_ST
			    FROM
			        T_MIN_DATA_DEFINITE
			    WHERE FACT_CODE = #fact_code#
				    <isNotEqual property="branch_no" compareValue="all">
						AND BRANCH_NO = #branch_no#
				    </isNotEqual>
				    <![CDATA[
					AND SUBSTR(MIN_TIME, 0, 8) >= #searchYear#||#searchMonth#||#searchDay1#
					AND SUBSTR(MIN_TIME, 0, 8) <= #searchYear#||#searchMonth#||#searchDay2#
					]]>
<!-- 					AND ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00') -->
					<iterate prepend=" AND ITEM_CODE IN " property="item_list" open="(" close=")" conjunction=",">
						#item_list[]#
			      	</iterate>
			      	AND MIN_VL != 999999
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
		) B
		ON (
			A.FACT_CODE = B.FACT_CODE
			AND A.BRANCH_NO = B.BRANCH_NO
			AND A.MIN_TIME = B.MIN_TIME
		)
		WHERE 1=1
		<isNotEqual property="strange" compareValue="all">
			AND (TUR_OVER > 0 OR DOW_OVER > 0 OR TMP_OVER > 0 OR PHY_OVER > 0 OR CON_OVER > 0 OR TOF_OVER > 0)
		</isNotEqual>
	</sql>
	
	<!-- 측정소 데이터 확정 조회 (Hour) SQL -->
	<sql id="getDefiniteHourDataList_SQL">
		WITH FACT_LIMIT AS (
		  SELECT
		      FACT_CODE
		    , BRANCH_NO
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_HI)) AS TUR_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_LO)) AS TUR_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_HI)) AS DOW_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_LO)) AS DOW_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_HI)) AS TMP_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_LO)) AS TMP_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_HI)) AS PHY_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_LO)) AS PHY_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_HI)) AS CON_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_LO)) AS CON_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_HI)) AS TOF_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_LO)) AS TOF_VALUE_LO
		  FROM T_ITEM_INFO_FACT
		  WHERE FACT_CODE = #fact_code#
		  	<isNotEqual property="branch_no" compareValue="all">
				AND BRANCH_NO = #branch_no#
		    </isNotEqual>
		  GROUP BY FACT_CODE, BRANCH_NO
		)
		SELECT A.*, B.TUR2, B.TUR_ST2, B.DOW2, B.DOW_ST2, B.TMP2, B.TMP_ST2, B.PHY2, B.PHY_ST2, B.CON2, B.CON_ST2, B.TOF2, B.TOF_ST2 FROM (
			SELECT
			    QQ.FACT_CODE FACT_CODE
			  , QQ.BRANCH_NO BRANCH_NO
			  , QQ.BRANCH_NAME BRANCH_NAME
			  , QQ.MIN_TIME MIN_TIME
			  , QQ.STR_DATE
			  , QQ.STR_TIME
			  , TUR
			  , TUR_OR
			  , TUR_ST
			  , DOW
			  , DOW_OR
			  , DOW_ST
			  , TMP
			  , TMP_OR
			  , TMP_ST
			  , PHY
			  , PHY_OR
			  , PHY_ST
			  , CON
			  , CON_OR
			  , CON_ST
			  , TOF
			  , TOF_OR
			  , TOF_ST
			  <![CDATA[
			  , CASE WHEN (
	    			(((SELECT TUR_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TUR > (SELECT TUR_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TUR_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TUR < (SELECT TUR_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TUR_OVER
			  , CASE WHEN (
	    			(((SELECT DOW_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (DOW > (SELECT DOW_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT DOW_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (DOW < (SELECT DOW_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS DOW_OVER
			  , CASE WHEN (
	    			(((SELECT TMP_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TMP > (SELECT TMP_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TMP_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TMP < (SELECT TMP_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TMP_OVER
			  , CASE WHEN (
	    			(((SELECT PHY_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (PHY > (SELECT PHY_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT PHY_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (PHY < (SELECT PHY_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS PHY_OVER
			  , CASE WHEN (
	    			(((SELECT CON_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (CON > (SELECT CON_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT CON_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (CON < (SELECT CON_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS CON_OVER
			  , CASE WHEN (
	    			(((SELECT TOF_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TOF > (SELECT TOF_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TOF_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TOF < (SELECT TOF_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TOF_OVER
			  ]]>
			  , AA.MIN_DUMP
			  , QQ.RIVER_NAME
			  , QQ.SYS_KIND_NAME
			  , QQ.SYS_KIND
			  , QQ.RIVER_DIV
			FROM (
			  SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , MIN_DUMP
			    , SUM(TUR) AS TUR
			    , SUM(TUR_OR) AS TUR_OR
			    , SUM(TUR_ST) AS TUR_ST
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW
			    , SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) AS DOW_OR
			    , SUM(DECODE(DOW2, NULL, DOW_ST, DOW2_ST)) AS DOW_ST
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP
			    , SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) AS TMP_OR
			    , SUM(DECODE(TMP2, NULL, TMP_ST, TMP2_ST)) AS TMP_ST
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY
			    , SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) AS PHY_OR
			    , SUM(DECODE(PHY2, NULL, PHY_ST, PHY2_ST)) AS PHY_ST
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON
			    , SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) AS CON_OR
			    , SUM(DECODE(CON2, NULL, CON_ST, CON2_ST)) AS CON_ST
			    , SUM(TOF) AS TOF
			    , SUM(TOF_OR) AS TOF_OR
			    , SUM(TOF_ST) AS TOF_ST
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			  FROM (
			    SELECT
			        DISTINCT A.ITEM_CODE AS ITEM_CODE
			      , B.ITEM_NAME AS ITEM_NAME
			      , A.FACT_CODE AS FACT_CODE
			      , A.BRANCH_NO AS BRANCH_NO
			      , D.BRANCH_NAME||'-'||A.BRANCH_NO AS BRANCH_NAME
			      , A.HOUR_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , A.HOUR_RTIME AS MIN_RTIME
			      , A.HOUR_DUMP AS MIN_DUMP
			      , DECODE(A.ITEM_CODE, 'TUR00', HOUR_VL) AS TUR
			      , DECODE(A.ITEM_CODE, 'TUR00', HOUR_OR) AS TUR_OR
			      , DECODE(A.ITEM_CODE, 'TUR00', HOUR_ST) AS TUR_ST
			      , DECODE(A.ITEM_CODE, 'DOW00', HOUR_VL) AS DOW
			      , DECODE(A.ITEM_CODE, 'DOW00', HOUR_OR) AS DOW_OR
			      , DECODE(A.ITEM_CODE, 'DOW00', HOUR_ST) AS DOW_ST
			      , DECODE(A.ITEM_CODE, 'DOW01', HOUR_VL) AS DOW2
			      , DECODE(A.ITEM_CODE, 'DOW01', HOUR_OR) AS DOW2_OR
			      , DECODE(A.ITEM_CODE, 'DOW01', HOUR_ST) AS DOW2_ST
			      , DECODE(A.ITEM_CODE, 'TMP00', HOUR_VL) AS TMP
			      , DECODE(A.ITEM_CODE, 'TMP00', HOUR_OR) AS TMP_OR
			      , DECODE(A.ITEM_CODE, 'TMP00', HOUR_ST) AS TMP_ST
			      , DECODE(A.ITEM_CODE, 'TMP01', HOUR_VL) AS TMP2
			      , DECODE(A.ITEM_CODE, 'TMP01', HOUR_OR) AS TMP2_OR
			      , DECODE(A.ITEM_CODE, 'TMP01', HOUR_ST) AS TMP2_ST
			      , DECODE(A.ITEM_CODE, 'PHY00', HOUR_VL) AS PHY
			      , DECODE(A.ITEM_CODE, 'PHY00', HOUR_OR) AS PHY_OR
			      , DECODE(A.ITEM_CODE, 'PHY00', HOUR_ST) AS PHY_ST
			      , DECODE(A.ITEM_CODE, 'PHY01', HOUR_VL) AS PHY2
			      , DECODE(A.ITEM_CODE, 'PHY01', HOUR_OR) AS PHY2_OR
			      , DECODE(A.ITEM_CODE, 'PHY01', HOUR_ST) AS PHY2_ST
			      , DECODE(A.ITEM_CODE, 'CON00', HOUR_VL) AS CON
			      , DECODE(A.ITEM_CODE, 'CON00', HOUR_OR) AS CON_OR
			      , DECODE(A.ITEM_CODE, 'CON00', HOUR_ST) AS CON_ST
			      , DECODE(A.ITEM_CODE, 'CON01', HOUR_VL) AS CON2
			      , DECODE(A.ITEM_CODE, 'CON01', HOUR_OR) AS CON2_OR
			      , DECODE(A.ITEM_CODE, 'CON01', HOUR_ST) AS CON2_ST
			      , DECODE(A.ITEM_CODE, 'TOF00', HOUR_VL) AS TOF
			      , DECODE(A.ITEM_CODE, 'TOF00', HOUR_OR) AS TOF_OR
			      , DECODE(A.ITEM_CODE, 'TOF00', HOUR_ST) AS TOF_ST
			      , C.RIVER_DIV
			      , DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , C.SYS_KIND
			      , ( SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = C.SYS_KIND) AS SYS_KIND_NAME
			    FROM
			        T_HOUR_DATA A
			      , T_WEATHER_AREA AREA
			      , T_ITEM_INFO B
			      , T_FACT_INFO C
			      , T_FACT_BRANCH_INFO D
			      , T_FACT_MEASU_ITEM I
			      , T_WQA_ITEM M
			    WHERE A.FACT_CODE = AREA.FACT_CODE(+)
			      AND A.BRANCH_NO = AREA.BRANCH_NO(+)
			      AND A.ITEM_CODE = B.ITEM_CODE
			      AND I.ITEM_CODE = A.ITEM_CODE
			      AND I.FACT_CODE = A.FACT_CODE
			      AND I.BRANCH_NO = A.BRANCH_NO
			      AND I.ITEM_USE_FLAG = 'Y'
			      AND A.FACT_CODE = C.FACT_CODE
			      AND C.FACT_CODE = D.FACT_CODE
			      AND A.BRANCH_NO = D.BRANCH_NO
			      AND D.BRANCH_USE_FLAG = 'Y'
			      AND C.FACT_USE_FLAG = 'Y'
			      AND C.RIVER_DIV = #river_div#
			      AND A.FACT_CODE = #fact_code#
			      <isNotEqual property="branch_no" compareValue="all">
					  AND A.BRANCH_NO = #branch_no#
				  </isNotEqual>
			      AND C.SYS_KIND = 'U'
			      AND M.ITEM_CODE = A.ITEM_CODE
			      <!-- AND A.HOUR_TIME BETWEEN SUBSTR(#str_time#, 0, 10) AND SUBSTR(#end_time#, 0, 10) -->
			      <![CDATA[
			      AND SUBSTR(HOUR_TIME, 0, 8) >= #searchYear#||#searchMonth#||#searchDay1#
			      AND SUBSTR(HOUR_TIME, 0, 8) <= #searchYear#||#searchMonth#||#searchDay2#
			      ]]>
<!-- 			      AND A.ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00') -->
			      <iterate prepend=" AND A.ITEM_CODE IN " property="item_list" open="(" close=")" conjunction=",">
						#item_list[]#
			      </iterate>
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
			    , MIN_DUMP
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			) AA, (
			  SELECT
			      SUBSTR(Q.MIN_TIME, 0, 10) MIN_TIME
			    , TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			    , TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI')    AS STR_TIME
			    , A.FACT_CODE
			    , A.BRANCH_NO
			    , A.FACT_NAME
			    , A.BRANCH_NAME
			    , A.SYS_KIND
			    , A.RIVER_NAME
			    , A.SYS_KIND_NAME
			    , A.RIVER_DIV
			  FROM (
			    SELECT TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*60/24/60)-(60/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
			    FROM (
			      SELECT TO_DATE(#searchYear#||#searchMonth#||#searchDay2#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (120/24/60) AS DAYCNT
			      FROM DUAL
			    )
			    <![CDATA[
			    CONNECT BY (LEVEL*60/24/60+(60/24/60)) <= DAYCNT
			    ]]>
			  ) Q, (
			    SELECT
			        B.FACT_CODE
			      , B.BRANCH_NO
			      , AREA.REG_NAME AS FACT_NAME
			      , B.BRANCH_NAME||'-'||B.BRANCH_NO AS BRANCH_NAME
			      , F.RIVER_DIV
			      , DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , F.SYS_KIND
			      , (SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = F.SYS_KIND) AS SYS_KIND_NAME
			    FROM
			        T_FACT_INFO F
			      , T_FACT_BRANCH_INFO B
			      , T_WEATHER_AREA AREA
			    WHERE F.FACT_CODE = B.FACT_CODE
			      AND B.BRANCH_USE_FLAG = 'Y'
			      AND AREA.FACT_CODE(+) = B.FACT_CODE
			      AND F.RIVER_DIV = #river_div#
			      AND AREA.BRANCH_NO(+) = B.BRANCH_NO
			      AND F.FACT_CODE = #fact_code#
			      <isNotEqual property="branch_no" compareValue="all">
					  AND B.BRANCH_NO = #branch_no#
				  </isNotEqual>
			      AND F.SYS_KIND = 'U'
			  ) A
			  <![CDATA[
			  WHERE TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE
			  ]]>
			) QQ
			WHERE AA.MIN_TIME(+) = QQ.MIN_TIME
			  AND AA.FACT_CODE(+) = QQ.FACT_CODE
			  AND AA.BRANCH_NO(+) = QQ.BRANCH_NO
		) A  LEFT OUTER JOIN (
		    SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , SUM(TUR) AS TUR2
			    , SUM(TUR_ST)                        AS TUR_ST2
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW2
			    , SUM(DOW_ST)                        AS DOW_ST2
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP2
			    , SUM(TMP_ST)                        AS TMP_ST2
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY2
			    , SUM(PHY_ST) AS PHY_ST2
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON2
			    , SUM(CON_ST) AS CON_ST2
			    , SUM(TOF) AS TOF2
			    , SUM(TOF_ST)                        AS TOF_ST2
			  FROM (
			    SELECT
			        DISTINCT ITEM_CODE AS ITEM_CODE
			      , FACT_CODE AS FACT_CODE
			      , BRANCH_NO AS BRANCH_NO
			      , HOUR_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , DECODE(ITEM_CODE, 'TUR00', HOUR_VL) AS TUR
			      , DECODE(ITEM_CODE, 'TUR00', HOUR_ST)                       AS TUR_ST
			      , DECODE(ITEM_CODE, 'DOW00', HOUR_VL) AS DOW
			      , DECODE(ITEM_CODE, 'DOW01', HOUR_VL) AS DOW2
			      , DECODE(ITEM_CODE, 'DOW00', HOUR_ST)                       AS DOW_ST
			      , DECODE(ITEM_CODE, 'TMP00', HOUR_VL) AS TMP
			      , DECODE(ITEM_CODE, 'TMP01', HOUR_VL) AS TMP2
			      , DECODE(ITEM_CODE, 'TMP00', HOUR_ST)                       AS TMP_ST
			      , DECODE(ITEM_CODE, 'PHY00', HOUR_VL) AS PHY
			      , DECODE(ITEM_CODE, 'PHY01', HOUR_VL) AS PHY2
			      , DECODE(ITEM_CODE, 'PHY00', HOUR_ST)                       AS PHY_ST
			      , DECODE(ITEM_CODE, 'CON00', HOUR_VL) AS CON
			      , DECODE(ITEM_CODE, 'CON01', HOUR_VL) AS CON2
			      , DECODE(ITEM_CODE, 'CON00', HOUR_ST)                       AS CON_ST
			      , DECODE(ITEM_CODE, 'TOF00', HOUR_VL) AS TOF
			      , DECODE(ITEM_CODE, 'TOF00', HOUR_ST)                       AS TOF_ST
			    FROM
			        T_HOUR_DATA_DEFINITE
			    WHERE FACT_CODE = #fact_code#
				    <isNotEqual property="branch_no" compareValue="all">
						AND BRANCH_NO = #branch_no#
				    </isNotEqual>
					<!-- AND HOUR_TIME BETWEEN SUBSTR(#str_time#, 0, 10) AND SUBSTR(#end_time#, 0, 10) -->
					<![CDATA[
					AND SUBSTR(HOUR_TIME, 0, 8) = #searchYear#||#searchMonth#||#searchDay1#
					AND SUBSTR(HOUR_TIME, 0, 8) = #searchYear#||#searchMonth#||#searchDay2#
					]]>
<!-- 					AND ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00') -->
					<iterate prepend=" AND ITEM_CODE IN " property="item_list" open="(" close=")" conjunction=",">
						#item_list[]#
			      	</iterate>
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
		) B
		ON (
			A.FACT_CODE = B.FACT_CODE
			AND A.BRANCH_NO = B.BRANCH_NO
			AND A.MIN_TIME = B.MIN_TIME
		)
		WHERE 1=1
		<isNotEqual property="strange" compareValue="all">
			AND (TUR_OVER > 0 OR DOW_OVER > 0 OR TMP_OVER > 0 OR PHY_OVER > 0 OR CON_OVER > 0 OR TOF_OVER > 0)
		</isNotEqual>
	</sql>
	
	<!-- 측정소 데이터 확정 조회 (Hour) SQL -->
	<sql id="getDefiniteHourDataListSum_SQL">
		WITH FACT_LIMIT AS (
		  SELECT
		      FACT_CODE
		    , BRANCH_NO
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_HI)) AS TUR_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TUR00', ITEM_VALUE_LO)) AS TUR_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_HI)) AS DOW_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'DOW00', ITEM_VALUE_LO)) AS DOW_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_HI)) AS TMP_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TMP00', ITEM_VALUE_LO)) AS TMP_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_HI)) AS PHY_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'PHY00', ITEM_VALUE_LO)) AS PHY_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_HI)) AS CON_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'CON00', ITEM_VALUE_LO)) AS CON_VALUE_LO
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_HI)) AS TOF_VALUE_HI
		    , MAX(DECODE(ITEM_CODE, 'TOF00', ITEM_VALUE_LO)) AS TOF_VALUE_LO
		  FROM T_ITEM_INFO_FACT
		  WHERE FACT_CODE = #fact_code#
		  	<isNotEqual property="branch_no" compareValue="all">
				AND BRANCH_NO = #branch_no#
		    </isNotEqual>
		  GROUP BY FACT_CODE, BRANCH_NO
		)
		SELECT A.*, B.TUR2, B.TUR_ST2, B.DOW2, B.DOW_ST2, B.TMP2, B.TMP_ST2, B.PHY2, B.PHY_ST2, B.CON2, B.CON_ST2, B.TOF2, B.TOF_ST2 FROM (
			SELECT
			    QQ.FACT_CODE FACT_CODE
			  , QQ.BRANCH_NO BRANCH_NO
			  , QQ.BRANCH_NAME BRANCH_NAME
			  , QQ.MIN_TIME MIN_TIME
			  , QQ.STR_DATE
			  , QQ.STR_TIME
			  , TUR
			  , TUR_OR
			  , TUR_ST
			  , DOW
			  , DOW_OR
			  , DOW_ST
			  , TMP
			  , TMP_OR
			  , TMP_ST
			  , PHY
			  , PHY_OR
			  , PHY_ST
			  , CON
			  , CON_OR
			  , CON_ST
			  , TOF
			  , TOF_OR
			  , TOF_ST
			  <![CDATA[
			  , CASE WHEN (
	    			(((SELECT TUR_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TUR > (SELECT TUR_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TUR_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TUR < (SELECT TUR_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TUR_OVER
			  , CASE WHEN (
	    			(((SELECT DOW_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (DOW > (SELECT DOW_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT DOW_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (DOW < (SELECT DOW_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS DOW_OVER
			  , CASE WHEN (
	    			(((SELECT TMP_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TMP > (SELECT TMP_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TMP_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TMP < (SELECT TMP_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TMP_OVER
			  , CASE WHEN (
	    			(((SELECT PHY_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (PHY > (SELECT PHY_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT PHY_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (PHY < (SELECT PHY_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS PHY_OVER
			  , CASE WHEN (
	    			(((SELECT CON_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (CON > (SELECT CON_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT CON_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (CON < (SELECT CON_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS CON_OVER
			  , CASE WHEN (
	    			(((SELECT TOF_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TOF > (SELECT TOF_VALUE_HI FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO))) OR
	    			(((SELECT TOF_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO) IS NOT NULL) AND (TOF < (SELECT TOF_VALUE_LO FROM FACT_LIMIT WHERE FACT_CODE = QQ.FACT_CODE AND BRANCH_NO = QQ.BRANCH_NO)))
	    		) THEN 1 ELSE 0 END AS TOF_OVER
			  ]]>
			  , AA.MIN_DUMP
			  , QQ.RIVER_NAME
			  , QQ.SYS_KIND_NAME
			  , QQ.SYS_KIND
			  , QQ.RIVER_DIV
			FROM (
			  SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , MIN_DUMP
			    , SUM(TUR) AS TUR
			    , SUM(TUR_OR) AS TUR_OR
			    , SUM(TUR_ST) AS TUR_ST
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW
			    , SUM(DECODE(DOW2, NULL, DOW_OR, DOW2_OR)) AS DOW_OR
			    , SUM(DECODE(DOW2, NULL, DOW_ST, DOW2_ST)) AS DOW_ST
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP
			    , SUM(DECODE(TMP2, NULL, TMP_OR, TMP2_OR)) AS TMP_OR
			    , SUM(DECODE(TMP2, NULL, TMP_ST, TMP2_ST)) AS TMP_ST
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY
			    , SUM(DECODE(PHY2, NULL, PHY_OR, PHY2_OR)) AS PHY_OR
			    , SUM(DECODE(PHY2, NULL, PHY_ST, PHY2_ST)) AS PHY_ST
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON
			    , SUM(DECODE(CON2, NULL, CON_OR, CON2_OR)) AS CON_OR
			    , SUM(DECODE(CON2, NULL, CON_ST, CON2_ST)) AS CON_ST
			    , SUM(TOF) AS TOF
			    , SUM(TOF_OR) AS TOF_OR
			    , SUM(TOF_ST) AS TOF_ST
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			  FROM (
			    SELECT
			        DISTINCT A.ITEM_CODE AS ITEM_CODE
			      , B.ITEM_NAME AS ITEM_NAME
			      , A.FACT_CODE AS FACT_CODE
			      , A.BRANCH_NO AS BRANCH_NO
			      , D.BRANCH_NAME||'-'||A.BRANCH_NO AS BRANCH_NAME
			      , A.HOUR_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(A.HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , A.HOUR_RTIME AS MIN_RTIME
			      , A.HOUR_DUMP AS MIN_DUMP
			      , DECODE(A.ITEM_CODE, 'TUR00', HOUR_VL) AS TUR
			      , DECODE(A.ITEM_CODE, 'TUR00', HOUR_OR) AS TUR_OR
			      , DECODE(A.ITEM_CODE, 'TUR00', HOUR_ST) AS TUR_ST
			      , DECODE(A.ITEM_CODE, 'DOW00', HOUR_VL) AS DOW
			      , DECODE(A.ITEM_CODE, 'DOW00', HOUR_OR) AS DOW_OR
			      , DECODE(A.ITEM_CODE, 'DOW00', HOUR_ST) AS DOW_ST
			      , DECODE(A.ITEM_CODE, 'DOW01', HOUR_VL) AS DOW2
			      , DECODE(A.ITEM_CODE, 'DOW01', HOUR_OR) AS DOW2_OR
			      , DECODE(A.ITEM_CODE, 'DOW01', HOUR_ST) AS DOW2_ST
			      , DECODE(A.ITEM_CODE, 'TMP00', HOUR_VL) AS TMP
			      , DECODE(A.ITEM_CODE, 'TMP00', HOUR_OR) AS TMP_OR
			      , DECODE(A.ITEM_CODE, 'TMP00', HOUR_ST) AS TMP_ST
			      , DECODE(A.ITEM_CODE, 'TMP01', HOUR_VL) AS TMP2
			      , DECODE(A.ITEM_CODE, 'TMP01', HOUR_OR) AS TMP2_OR
			      , DECODE(A.ITEM_CODE, 'TMP01', HOUR_ST) AS TMP2_ST
			      , DECODE(A.ITEM_CODE, 'PHY00', HOUR_VL) AS PHY
			      , DECODE(A.ITEM_CODE, 'PHY00', HOUR_OR) AS PHY_OR
			      , DECODE(A.ITEM_CODE, 'PHY00', HOUR_ST) AS PHY_ST
			      , DECODE(A.ITEM_CODE, 'PHY01', HOUR_VL) AS PHY2
			      , DECODE(A.ITEM_CODE, 'PHY01', HOUR_OR) AS PHY2_OR
			      , DECODE(A.ITEM_CODE, 'PHY01', HOUR_ST) AS PHY2_ST
			      , DECODE(A.ITEM_CODE, 'CON00', HOUR_VL) AS CON
			      , DECODE(A.ITEM_CODE, 'CON00', HOUR_OR) AS CON_OR
			      , DECODE(A.ITEM_CODE, 'CON00', HOUR_ST) AS CON_ST
			      , DECODE(A.ITEM_CODE, 'CON01', HOUR_VL) AS CON2
			      , DECODE(A.ITEM_CODE, 'CON01', HOUR_OR) AS CON2_OR
			      , DECODE(A.ITEM_CODE, 'CON01', HOUR_ST) AS CON2_ST
			      , DECODE(A.ITEM_CODE, 'TOF00', HOUR_VL) AS TOF
			      , DECODE(A.ITEM_CODE, 'TOF00', HOUR_OR) AS TOF_OR
			      , DECODE(A.ITEM_CODE, 'TOF00', HOUR_ST) AS TOF_ST
			      , C.RIVER_DIV
			      , DECODE(C.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , C.SYS_KIND
			      , ( SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = C.SYS_KIND) AS SYS_KIND_NAME
			    FROM
			        T_HOUR_DATA A
			      , T_WEATHER_AREA AREA
			      , T_ITEM_INFO B
			      , T_FACT_INFO C
			      , T_FACT_BRANCH_INFO D
			      , T_FACT_MEASU_ITEM I
			      , T_WQA_ITEM M
			    WHERE A.FACT_CODE = AREA.FACT_CODE(+)
			      AND A.BRANCH_NO = AREA.BRANCH_NO(+)
			      AND A.ITEM_CODE = B.ITEM_CODE
			      AND I.ITEM_CODE = A.ITEM_CODE
			      AND I.FACT_CODE = A.FACT_CODE
			      AND I.BRANCH_NO = A.BRANCH_NO
			      AND I.ITEM_USE_FLAG = 'Y'
			      AND A.FACT_CODE = C.FACT_CODE
			      AND C.FACT_CODE = D.FACT_CODE
			      AND A.BRANCH_NO = D.BRANCH_NO
			      AND D.BRANCH_USE_FLAG = 'Y'
			      AND C.FACT_USE_FLAG = 'Y'
			      AND C.RIVER_DIV = #river_div#
			      AND A.FACT_CODE = #fact_code#
			      <isNotEqual property="branch_no" compareValue="all">
					  AND A.BRANCH_NO = #branch_no#
				  </isNotEqual>
			      AND C.SYS_KIND = 'U'
			      AND M.ITEM_CODE = A.ITEM_CODE
			      <!-- AND A.HOUR_TIME BETWEEN SUBSTR(#str_time#, 0, 10) AND SUBSTR(#end_time#, 0, 10) -->
			      <![CDATA[
			      AND SUBSTR(HOUR_TIME, 0, 8) >= #searchYear#||#searchMonth#||#searchDay1#
			      AND SUBSTR(HOUR_TIME, 0, 8) <= #searchYear#||#searchMonth#||#searchDay2#
			      ]]>
<!-- 			      AND A.ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00') -->
			      <iterate prepend=" AND A.ITEM_CODE IN " property="item_list" open="(" close=")" conjunction=",">
						#item_list[]#
			      </iterate>
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , BRANCH_NAME
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
			    , MIN_DUMP
			    , RIVER_DIV
			    , RIVER_NAME
			    , SYS_KIND
			    , SYS_KIND_NAME
			) AA, (
			  SELECT
			      SUBSTR(Q.MIN_TIME, 0, 10) MIN_TIME
			    , TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			    , TO_CHAR(TO_DATE(Q.MIN_TIME,'YYYYMMDDHH24MI'),'HH24:MI')    AS STR_TIME
			    , A.FACT_CODE
			    , A.BRANCH_NO
			    , A.FACT_NAME
			    , A.BRANCH_NAME
			    , A.SYS_KIND
			    , A.RIVER_NAME
			    , A.SYS_KIND_NAME
			    , A.RIVER_DIV
			  FROM (
			    SELECT TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*60/24/60)-(60/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
			    FROM (
			      SELECT TO_DATE(#searchYear#||#searchMonth#||#searchDay2#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (120/24/60) AS DAYCNT
			      FROM DUAL
			    )
			    <![CDATA[
			    CONNECT BY (LEVEL*60/24/60+(60/24/60)) <= DAYCNT
			    ]]>
			  ) Q, (
			    SELECT
			        B.FACT_CODE
			      , B.BRANCH_NO
			      , AREA.REG_NAME AS FACT_NAME
			      , B.BRANCH_NAME||'-'||B.BRANCH_NO AS BRANCH_NAME
			      , F.RIVER_DIV
			      , DECODE(F.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , F.SYS_KIND
			      , (SELECT SYS_KIND_NAME FROM T_SYS_KIND WHERE SYS_KIND = F.SYS_KIND) AS SYS_KIND_NAME
			    FROM
			        T_FACT_INFO F
			      , T_FACT_BRANCH_INFO B
			      , T_WEATHER_AREA AREA
			    WHERE F.FACT_CODE = B.FACT_CODE
			      AND B.BRANCH_USE_FLAG = 'Y'
			      AND AREA.FACT_CODE(+) = B.FACT_CODE
			      AND F.RIVER_DIV = #river_div#
			      AND AREA.BRANCH_NO(+) = B.BRANCH_NO
			      AND F.FACT_CODE = #fact_code#
			      <isNotEqual property="branch_no" compareValue="all">
					  AND B.BRANCH_NO = #branch_no#
				  </isNotEqual>
			      AND F.SYS_KIND = 'U'
			  ) A
			  <![CDATA[
			  WHERE TO_DATE(Q.MIN_TIME, 'YYYYMMDDHH24MI') <= SYSDATE
			  ]]>
			) QQ
			WHERE AA.MIN_TIME(+) = QQ.MIN_TIME
			  AND AA.FACT_CODE(+) = QQ.FACT_CODE
			  AND AA.BRANCH_NO(+) = QQ.BRANCH_NO
		) A  LEFT OUTER JOIN (
		    SELECT
			      FACT_CODE
			    , BRANCH_NO
			    , MIN_TIME
			    , STR_DATE
			    , STR_TIME
			    , SUM(TUR) AS TUR2
			    , SUM(TUR_ST)                        AS TUR_ST2
			    , SUM(DECODE(DOW2, NULL, DOW, DOW2)) AS DOW2
			    , SUM(DOW_ST)                        AS DOW_ST2
			    , SUM(DECODE(TMP2, NULL, TMP, TMP2)) AS TMP2
			    , SUM(TMP_ST)                        AS TMP_ST2
			    , SUM(DECODE(PHY2, NULL, PHY, PHY2)) AS PHY2
			    , SUM(PHY_ST) AS PHY_ST2
			    , SUM(DECODE(CON2, NULL, CON, CON2)) AS CON2
			    , SUM(CON_ST) AS CON_ST2
			    , SUM(TOF) AS TOF2
			    , SUM(TOF_ST)                        AS TOF_ST2
			  FROM (
			    SELECT
			        DISTINCT ITEM_CODE AS ITEM_CODE
			      , FACT_CODE AS FACT_CODE
			      , BRANCH_NO AS BRANCH_NO
			      , HOUR_TIME AS MIN_TIME
			      , TO_CHAR(TO_DATE(HOUR_TIME,'YYYYMMDDHH24MI'),'YYYY/MM/DD') AS STR_DATE
			      , TO_CHAR(TO_DATE(HOUR_TIME,'YYYYMMDDHH24MI'),'HH24:MI') AS STR_TIME
			      , DECODE(ITEM_CODE, 'TUR00', HOUR_VL) AS TUR
			      , DECODE(ITEM_CODE, 'TUR00', HOUR_ST)                       AS TUR_ST
			      , DECODE(ITEM_CODE, 'DOW00', HOUR_VL) AS DOW
			      , DECODE(ITEM_CODE, 'DOW01', HOUR_VL) AS DOW2
			      , DECODE(ITEM_CODE, 'DOW00', HOUR_ST)                       AS DOW_ST
			      , DECODE(ITEM_CODE, 'TMP00', HOUR_VL) AS TMP
			      , DECODE(ITEM_CODE, 'TMP01', HOUR_VL) AS TMP2
			      , DECODE(ITEM_CODE, 'TMP00', HOUR_ST)                       AS TMP_ST
			      , DECODE(ITEM_CODE, 'PHY00', HOUR_VL) AS PHY
			      , DECODE(ITEM_CODE, 'PHY01', HOUR_VL) AS PHY2
			      , DECODE(ITEM_CODE, 'PHY00', HOUR_ST)                       AS PHY_ST
			      , DECODE(ITEM_CODE, 'CON00', HOUR_VL) AS CON
			      , DECODE(ITEM_CODE, 'CON01', HOUR_VL) AS CON2
			      , DECODE(ITEM_CODE, 'CON00', HOUR_ST)                       AS CON_ST
			      , DECODE(ITEM_CODE, 'TOF00', HOUR_VL) AS TOF
			      , DECODE(ITEM_CODE, 'TOF00', HOUR_ST)                       AS TOF_ST
			    FROM
			        T_HOUR_DATA_DEFINITE
			    WHERE FACT_CODE = #fact_code#
				    <isNotEqual property="branch_no" compareValue="all">
						AND BRANCH_NO = #branch_no#
				    </isNotEqual>
					<!-- AND HOUR_TIME BETWEEN SUBSTR(#str_time#, 0, 10) AND SUBSTR(#end_time#, 0, 10) -->
					<![CDATA[
					AND SUBSTR(HOUR_TIME, 0, 8) >= #searchYear#||#searchMonth#||#searchDay1#
					AND SUBSTR(HOUR_TIME, 0, 8) <= #searchYear#||#searchMonth#||#searchDay2#
					]]>
<!-- 					AND ITEM_CODE IN ('TUR00', 'DOW00', 'DOW01', 'TMP00', 'TMP01', 'PHY00', 'PHY01', 'CON00', 'CON01', 'TOF00') -->
					<iterate prepend=" AND ITEM_CODE IN " property="item_list" open="(" close=")" conjunction=",">
						#item_list[]#
			      	</iterate>
			      	AND MIN_VL != 999999
			  )
			  GROUP BY
			      FACT_CODE
			    , BRANCH_NO
			    , STR_DATE
			    , STR_TIME
			    , MIN_TIME
		) B
		ON (
			A.FACT_CODE = B.FACT_CODE
			AND A.BRANCH_NO = B.BRANCH_NO
			AND A.MIN_TIME = B.MIN_TIME
		)
		WHERE 1=1
		<isNotEqual property="strange" compareValue="all">
			AND (TUR_OVER > 0 OR DOW_OVER > 0 OR TMP_OVER > 0 OR PHY_OVER > 0 OR CON_OVER > 0 OR TOF_OVER > 0)
		</isNotEqual>
	</sql>
	
	<!-- 측정소 데이터 확정 조회 -->
	<statement id="getDefiniteDataList_old" parameterClass="selectDataVO" resultClass="limitViewVO" remapResults="true">
		SELECT * FROM ( 
			SELECT ROWNUM RNUM, T.* FROM (
				SELECT 
					  FACT_CODE
					, BRANCH_NO
					, BRANCH_NAME
					, MIN_TIME
					, STR_DATE
					, STR_TIME
					, TO_CHAR(TUR, 'FM999,990.00') AS TUR
					, TUR_OR
					, TUR_ST
					, TO_CHAR(DOW, 'FM999,990.00') AS DOW
					, DOW_OR
					, DOW_ST
					, TO_CHAR(TMP, 'FM999,990.00') AS TMP
					, TMP_OR
					, TMP_ST
					, TO_CHAR(PHY, 'FM999,990.00') AS PHY
					, PHY_OR
					, PHY_ST
					, TO_CHAR(CON, 'FM999,990.00') AS CON
					, CON_OR
					, CON_ST
					, TO_CHAR(TOF, 'FM999,990.00') AS TOF
					, TOF_OR
					, TOF_ST
					, TUR_OVER
					, DOW_OVER
					, TMP_OVER
					, PHY_OVER
					, CON_OVER
					, TOF_OVER
					, MIN_DUMP
					, RIVER_NAME
					, SYS_KIND_NAME
					, SYS_KIND
					, RIVER_DIV
					, TO_CHAR(TUR2, 'FM999,990.00') AS TUR2
					, TO_CHAR(DOW2, 'FM999,990.00') AS DOW2
					, TO_CHAR(TMP2, 'FM999,990.00') AS TMP2
					, TO_CHAR(PHY2, 'FM999,990.00') AS PHY2
					, TO_CHAR(CON2, 'FM999,990.00') AS CON2
					, TO_CHAR(TOF2, 'FM999,990.00') AS TOF2
				FROM (
				    <isEqual property="data_type" compareValue="1">
						<include refid="getDefiniteHourDataList_SQL"/>
				    </isEqual>
				    <isNotEqual property="data_type" compareValue="1">
						<include refid="getDefiniteMinDataList_SQL"/>
				    </isNotEqual>
			    )
			   ORDER BY
					  MIN_TIME ASC
					, FACT_CODE ASC
					, BRANCH_NO ASC
			) T
		)
		WHERE
		<![CDATA[
			RNUM  > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<statement id="getDefiniteDataList" parameterClass="selectDataVO" resultClass="limitViewVO" remapResults="true">
		SELECT * FROM ( 
			SELECT ROWNUM RNUM, T.* FROM (
				SELECT 
					  FACT_CODE
					, BRANCH_NO
					, BRANCH_NAME
					, MIN_TIME
					, STR_DATE
					, STR_TIME
					, TO_CHAR(TRUNC(TUR,2), 'FM999,990.00') AS TUR
					, TUR_OR
					, TUR_ST
					, TO_CHAR(TRUNC(DOW,2), 'FM999,990.00') AS DOW
					, DOW_OR
					, DOW_ST
					, TO_CHAR(TRUNC(TMP,2), 'FM999,990.00') AS TMP
					, TMP_OR
					, TMP_ST
					, TO_CHAR(TRUNC(PHY,2), 'FM999,990.00') AS PHY
					, PHY_OR
					, PHY_ST
					, TO_CHAR(TRUNC(CON,3), 'FM999,990.000') AS CON
					, CON_OR
					, CON_ST
					, TO_CHAR(TRUNC(TOF,2), 'FM999,990.00') AS TOF
					, TOF_OR
					, TOF_ST
					, TUR_OVER
					, DOW_OVER
					, TMP_OVER
					, PHY_OVER
					, CON_OVER
					, TOF_OVER
					, MIN_DUMP
					, RIVER_NAME
					, SYS_KIND_NAME
					, SYS_KIND
					, RIVER_DIV
					, TO_CHAR(TRUNC(TUR2,2), 'FM999,990.00') AS TUR2
			        , TUR_ST2
				    , TO_CHAR(TRUNC(DOW2,2), 'FM999,990.00') AS DOW2
				    , DOW_ST2
				    , TO_CHAR(TRUNC(TMP2,2), 'FM999,990.00') AS TMP2
				    , TMP_ST2
				    , TO_CHAR(TRUNC(PHY2,2), 'FM999,990.00') AS PHY2
				    , PHY_ST2
				    , TO_CHAR(TRUNC(CON2,2), 'FM999,990.000') AS CON2
				    , CON_ST2
				    , TO_CHAR(TRUNC(TOF2,2), 'FM999,990.00') AS TOF2
				    , TOF_ST2
				FROM (
				    <isEqual property="data_type" compareValue="1">
						<include refid="getDefiniteHourDataList_SQL"/>
				    </isEqual>
				    <isNotEqual property="data_type" compareValue="1">
						<include refid="getDefiniteMinDataList_SQL"/>
				    </isNotEqual>
			    )
			   ORDER BY
					  MIN_TIME ASC
					, FACT_CODE ASC
					, BRANCH_NO ASC
			) T
		)
		WHERE
		<![CDATA[
			RNUM  > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</statement>
	
	<select id="getDefiniteDataCnt" parameterClass="selectDataVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*)  
		FROM
		(
		<isEqual property="data_type" compareValue="1">
			<include refid="getDefiniteHourDataList_SQL"/>
	    </isEqual>
	    <isNotEqual property="data_type" compareValue="1">    
			SELECT TO_CHAR(TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (LEVEL*10/24/60)-(10/24/60), 'YYYYMMDDHH24MI') AS MIN_TIME
			FROM
			(
			  SELECT TO_DATE(#searchYear#||#searchMonth#||#searchDay2#||'2359', 'YYYYMMDDHH24MI') - TO_DATE(#searchYear#||#searchMonth#||#searchDay1#||'0000' , 'YYYYMMDDHH24MI') + (20/24/60) AS DAYCNT
			  FROM DUAL
			)
			<![CDATA[CONNECT BY (LEVEL*10/24/60+(10/24/60)) <= DAYCNT]]>
	    </isNotEqual>
		) 
	</select>
	
	<!-- 측정소 데이터 확정 조회 전체 -->
	<statement id="getDefiniteDataListAll_old" parameterClass="selectDataVO" resultClass="limitViewVO" remapResults="true">
				SELECT 
					  FACT_CODE
					, BRANCH_NO
					, BRANCH_NAME
					, MIN_TIME
					, STR_DATE
					, STR_TIME
					, TO_CHAR(TRUNC(TUR,2), 'FM999,990.00') AS TUR
					, TUR_OR
					, TUR_ST
					, TO_CHAR(TRUNC(DOW,2), 'FM999,990.00') AS DOW
					, DOW_OR
					, DOW_ST
					, TO_CHAR(TRUNC(TMP,2), 'FM999,990.00') AS TMP
					, TMP_OR
					, TMP_ST
					, TO_CHAR(TRUNC(PHY,2), 'FM999,990.00') AS PHY
					, PHY_OR
					, PHY_ST
					, TO_CHAR(TRUNC(CON,2), 'FM999,990.00') AS CON
					, CON_OR
					, CON_ST
					, TO_CHAR(TRUNC(TOF,2), 'FM999,990.00') AS TOF
					, TOF_OR
					, TOF_ST
					, TUR_OVER
					, DOW_OVER
					, TMP_OVER
					, PHY_OVER
					, CON_OVER
					, TOF_OVER
					, MIN_DUMP
					, RIVER_NAME
					, SYS_KIND_NAME
					, SYS_KIND
					, RIVER_DIV
					, TO_CHAR(TRUNC(TUR2,2), 'FM999,990.00') AS TUR2
					, TO_CHAR(TRUNC(DOW2,2), 'FM999,990.00') AS DOW2
					, TO_CHAR(TRUNC(TMP2,2), 'FM999,990.00') AS TMP2
					, TO_CHAR(TRUNC(PHY2,2), 'FM999,990.00') AS PHY2
					, TO_CHAR(TRUNC(CON2,2), 'FM999,990.00') AS CON2
					, TO_CHAR(TRUNC(TOF2,2), 'FM999,990.00') AS TOF2
				FROM (
				    <isEqual property="data_type" compareValue="1">
						<include refid="getDefiniteHourDataList_SQL"/>
				    </isEqual>
				    <isNotEqual property="data_type" compareValue="1">
						<include refid="getDefiniteMinDataList_SQL"/>
				    </isNotEqual>
			    )
			   ORDER BY
					  MIN_TIME ASC
					, FACT_CODE ASC
					, BRANCH_NO ASC
	</statement>
	
	<!-- 측정소 데이터 확정 조회 전체 -->
	<statement id="getDefiniteDataListAll" parameterClass="selectDataVO" resultClass="limitViewVO" remapResults="true">
				SELECT 
					  FACT_CODE
					, BRANCH_NO
					, BRANCH_NAME
					, MIN_TIME
					, STR_DATE
					, STR_TIME
					, TO_CHAR(TRUNC(TUR,2), 'FM999,990.00') AS TUR
					, TUR_OR
					, TUR_ST
					, TO_CHAR(TRUNC(DOW,2), 'FM999,990.00') AS DOW
					, DOW_OR
					, DOW_ST
					, TO_CHAR(TRUNC(TMP,2), 'FM999,990.00') AS TMP
					, TMP_OR
					, TMP_ST
					, TO_CHAR(TRUNC(PHY,2), 'FM999,990.00') AS PHY
					, PHY_OR
					, PHY_ST
					, TO_CHAR(TRUNC(CON,3), 'FM999,990.000') AS CON
					, CON_OR
					, CON_ST
					, TO_CHAR(TRUNC(TOF,2), 'FM999,990.00') AS TOF
					, TOF_OR
					, TOF_ST
					, TUR_OVER
					, DOW_OVER
					, TMP_OVER
					, PHY_OVER
					, CON_OVER
					, TOF_OVER
					, MIN_DUMP
					, RIVER_NAME
					, SYS_KIND_NAME
					, SYS_KIND
					, RIVER_DIV
					, TO_CHAR(TRUNC(TUR2,2), 'FM999,990.00') AS TUR2
			        , TUR_ST2
				    , TO_CHAR(TRUNC(DOW2,2), 'FM999,990.00') AS DOW2
				    , DOW_ST2
				    , TO_CHAR(TRUNC(TMP2,2), 'FM999,990.00') AS TMP2
				    , TMP_ST2
				    , TO_CHAR(TRUNC(PHY2,2), 'FM999,990.00') AS PHY2
				    , PHY_ST2
				    , TO_CHAR(TRUNC(CON2,2), 'FM999,990.000') AS CON2
				    , CON_ST2
				    , TO_CHAR(TRUNC(TOF2,2), 'FM999,990.00') AS TOF2
				    , TOF_ST2
				FROM (
				    <isEqual property="data_type" compareValue="1">
						<include refid="getDefiniteHourDataList_SQL"/>
				    </isEqual>
				    <isNotEqual property="data_type" compareValue="1">
						<include refid="getDefiniteMinDataList_SQL"/>
				    </isNotEqual>
			    )
			   ORDER BY
					  MIN_TIME ASC
					, FACT_CODE ASC
					, BRANCH_NO ASC
	</statement>
	
	<!-- 측정소 데이터 확정 차트 조회 -->
	<statement id="getDefiniteDataChart" parameterClass="limitViewVO" resultClass="limitViewVO" remapResults="true">
	    <isEqual property="definiteflag" compareValue="Y">
	        SELECT A.FACT_CODE, 
			       A.ITEM_CODE, 
			       SUBSTR(A.MIN_TIME,9,2) || ':' || SUBSTR(A.MIN_TIME,11,2) MIN_TIME,
			       A.BRANCH_NO, 
			       A.MIN_RTIME, 
			       A.MIN_DUMP, 
			       A.MIN_VL, 
			       A.MIN_OR,   
			       A.MIN_ST, 
			       A.MIN_DCD 
			  FROM T_MIN_DATA_DEFINITE A 
			 WHERE A.MIN_TIME BETWEEN #min_time# || '0000' AND #min_time# || '9000'
			   AND A.MIN_VL != '999999'
<!-- 	        SELECT DECODE(B.FACT_CODE,NULL,A.FACT_CODE,B.FACT_CODE) FACT_CODE,  -->
<!-- 			       DECODE(B.ITEM_CODE,NULL,A.ITEM_CODE,B.ITEM_CODE) ITEM_CODE,  -->
<!-- 			       DECODE(B.MIN_TIME,NULL,A.MIN_TIME,B.MIN_TIME) MIN_TIME,  -->
<!-- 			       DECODE(B.BRANCH_NO,NULL,A.BRANCH_NO,B.BRANCH_NO) BRANCH_NO,  -->
<!-- 			       DECODE(B.MIN_RTIME,NULL,A.MIN_RTIME,B.MIN_RTIME) MIN_RTIME,  -->
<!-- 			       DECODE(B.MIN_DUMP,NULL,A.MIN_DUMP,B.MIN_DUMP) MIN_DUMP,  -->
<!-- 			       DECODE(B.MIN_VL,NULL,A.MIN_VL,B.MIN_VL) MIN_VL,  -->
<!-- 			       DECODE(B.MIN_OR,NULL,A.MIN_OR,B.MIN_OR) MIN_OR,  -->
<!-- 			       DECODE(B.MIN_ST,NULL,A.MIN_ST,B.MIN_ST) MIN_ST,  -->
<!-- 			       DECODE(B.MIN_DCD,NULL,A.MIN_DCD,B.MIN_DCD) MIN_DCD  -->
<!-- 			  FROM T_MIN_DATA A ,  -->
<!-- 			       T_MIN_DATA_DEFINITE B  -->
<!-- 			 WHERE A.FACT_CODE = B.FACT_CODE(+)  -->
<!-- 			       AND A.ITEM_CODE = B.ITEM_CODE(+)  -->
<!-- 			       AND A.MIN_TIME = B.MIN_TIME(+)  -->
<!-- 			       AND A.BRANCH_NO = B.BRANCH_NO(+)  -->
<!-- 			       AND A.MIN_TIME BETWEEN TO_CHAR(TO_DATE(#min_time#,'YYYYMM') - 365,'YYYYMM') || '000000' AND TO_CHAR(TO_DATE(#min_time#,'YYYYMM') - 365,'YYYYMM') || '999999' -->
		</isEqual>
	    <isNotEqual property="definiteflag" compareValue="Y">
	        SELECT A.FACT_CODE, 
			       A.ITEM_CODE, 
			       SUBSTR(A.MIN_TIME,9,2) || ':' || SUBSTR(A.MIN_TIME,11,2) MIN_TIME, 
			       A.BRANCH_NO, 
			       A.MIN_RTIME, 
			       A.MIN_DUMP, 
			       A.MIN_VL, 
			       A.MIN_OR,   
			       A.MIN_ST, 
			       A.MIN_DCD  
			  FROM T_MIN_DATA A 
			 WHERE A.MIN_TIME BETWEEN #min_time# || '0000' AND #min_time# || '9000'
	    </isNotEqual>
	    		   AND A.FACT_CODE = #fact_code# 
			       AND A.BRANCH_NO = #branch_no#
			       AND A.ITEM_CODE = #item_code#
			ORDER BY A.MIN_TIME ASC
	</statement>
	
	<select id="getDefiniteDataSum_old" parameterClass="selectDataVO" resultClass="sumViewVO" remapResults="true">
		SELECT
			  TO_CHAR(MIN(TRUNC(TUR,2)), 'FM999,990.00') AS TUR_MIN
			, TO_CHAR(MAX(TRUNC(TUR,2)), 'FM999,990.00') AS TUR_MAX
			, TO_CHAR(AVG(TRUNC(TUR,2)), 'FM999,990.00') AS TUR_AVG
			, TO_CHAR(MIN(TRUNC(DOW,2)), 'FM999,990.00') AS DOW_MIN
			, TO_CHAR(MAX(TRUNC(DOW,2)), 'FM999,990.00') AS DOW_MAX
			, TO_CHAR(AVG(TRUNC(DOW,2)), 'FM999,990.00') AS DOW_AVG
			, TO_CHAR(MIN(TRUNC(TMP,2)), 'FM999,990.00') AS TMP_MIN
			, TO_CHAR(MAX(TRUNC(TMP,2)), 'FM999,990.00') AS TMP_MAX
			, TO_CHAR(AVG(TRUNC(TMP,2)), 'FM999,990.00') AS TMP_AVG
			, TO_CHAR(MIN(TRUNC(PHY,2)), 'FM999,990.00') AS PHY_MIN
			, TO_CHAR(MAX(TRUNC(PHY,2)), 'FM999,990.00') AS PHY_MAX
			, TO_CHAR(AVG(TRUNC(PHY,2)), 'FM999,990.00') AS PHY_AVG
			, TO_CHAR(MIN(TRUNC(CON,3)), 'FM999,990.000') AS CON_MIN
			, TO_CHAR(MAX(TRUNC(CON,3)), 'FM999,990.000') AS CON_MAX
			, TO_CHAR(AVG(TRUNC(CON,3)), 'FM999,990.000') AS CON_AVG
			, TO_CHAR(MIN(TRUNC(TOF,2)), 'FM999,990.00') AS TOF_MIN
			, TO_CHAR(MAX(TRUNC(TOF,2)), 'FM999,990.00') AS TOF_MAX
			, TO_CHAR(AVG(TRUNC(TOF,2)), 'FM999,990.00') AS TOF_AVG
			, TO_CHAR(MIN(DECODE(TRUNC(TUR2,2), '999999', NULL, TUR2)), 'FM999,990.00') AS TUR2_MIN
			, TO_CHAR(MAX(DECODE(TRUNC(TUR2,2), '999999', NULL, TUR2)), 'FM999,990.00') AS TUR2_MAX
			, TO_CHAR(AVG(DECODE(TRUNC(TUR2,2), '999999', NULL, TUR2)), 'FM999,990.00') AS TUR2_AVG
			, TO_CHAR(MIN(DECODE(TRUNC(DOW2,2), '999999', NULL, DOW2)), 'FM999,990.00') AS DOW2_MIN
			, TO_CHAR(MAX(DECODE(TRUNC(DOW2,2), '999999', NULL, DOW2)), 'FM999,990.00') AS DOW2_MAX
			, TO_CHAR(AVG(DECODE(TRUNC(DOW2,2), '999999', NULL, DOW2)), 'FM999,990.00') AS DOW2_AVG
			, TO_CHAR(MIN(DECODE(TRUNC(TMP2,2), '999999', NULL, TMP2)), 'FM999,990.00') AS TMP2_MIN
			, TO_CHAR(MAX(DECODE(TRUNC(TMP2,2), '999999', NULL, TMP2)), 'FM999,990.00') AS TMP2_MAX
			, TO_CHAR(AVG(DECODE(TRUNC(TMP2,2), '999999', NULL, TMP2)), 'FM999,990.00') AS TMP2_AVG
			, TO_CHAR(MIN(DECODE(TRUNC(PHY2,2), '999999', NULL, PHY2)), 'FM999,990.00') AS PHY2_MIN
			, TO_CHAR(MAX(DECODE(TRUNC(PHY2,2), '999999', NULL, PHY2)), 'FM999,990.00') AS PHY2_MAX
			, TO_CHAR(AVG(DECODE(TRUNC(PHY2,2), '999999', NULL, PHY2)), 'FM999,990.00') AS PHY2_AVG
			, TO_CHAR(MIN(DECODE(TRUNC(CON2,3), '999999', NULL, CON2)), 'FM999,990.000') AS CON2_MIN
			, TO_CHAR(MAX(DECODE(TRUNC(CON2,3), '999999', NULL, CON2)), 'FM999,990.000') AS CON2_MAX
			, TO_CHAR(AVG(DECODE(TRUNC(CON2,3), '999999', NULL, CON2)), 'FM999,990.000') AS CON2_AVG
			, TO_CHAR(MIN(DECODE(TRUNC(TOF2,2), '999999', NULL, TOF2)), 'FM999,990.00') AS TOF2_MIN
			, TO_CHAR(MAX(DECODE(TRUNC(TOF2,2), '999999', NULL, TOF2)), 'FM999,990.00') AS TOF2_MAX
			, TO_CHAR(AVG(DECODE(TRUNC(TOF2,2), '999999', NULL, TOF2)), 'FM999,990.00') AS TOF2_AVG
		FROM (
			<isEqual property="data_type" compareValue="1">
				<include refid="getDefiniteHourDataList_SQL"/>
		    </isEqual>
		    <isNotEqual property="data_type" compareValue="1">
				<include refid="getDefiniteMinDataList_SQL"/>
		    </isNotEqual>
		)
	</select>
	
	<select id="getDefiniteDataSum" parameterClass="selectDataVO" resultClass="sumViewVO" remapResults="true">
		SELECT
			  TO_CHAR(MIN(TRUNC(TUR,2)), 'FM999,990.00') AS TUR_MIN
			, TO_CHAR(MAX(TRUNC(TUR,2)), 'FM999,990.00') AS TUR_MAX
			, TO_CHAR(AVG(TRUNC(TUR,2)), 'FM999,990.00') AS TUR_AVG
			, TO_CHAR(MIN(TRUNC(DOW,2)), 'FM999,990.00') AS DOW_MIN
			, TO_CHAR(MAX(TRUNC(DOW,2)), 'FM999,990.00') AS DOW_MAX
			, TO_CHAR(AVG(TRUNC(DOW,2)), 'FM999,990.00') AS DOW_AVG
			, TO_CHAR(MIN(TRUNC(TMP,2)), 'FM999,990.00') AS TMP_MIN
			, TO_CHAR(MAX(TRUNC(TMP,2)), 'FM999,990.00') AS TMP_MAX
			, TO_CHAR(AVG(TRUNC(TMP,2)), 'FM999,990.00') AS TMP_AVG
			, TO_CHAR(MIN(TRUNC(PHY,2)), 'FM999,990.00') AS PHY_MIN
			, TO_CHAR(MAX(TRUNC(PHY,2)), 'FM999,990.00') AS PHY_MAX
			, TO_CHAR(AVG(TRUNC(PHY,2)), 'FM999,990.00') AS PHY_AVG
			, TO_CHAR(MIN(TRUNC(CON,3)), 'FM999,990.000') AS CON_MIN
			, TO_CHAR(MAX(TRUNC(CON,3)), 'FM999,990.000') AS CON_MAX
			, TO_CHAR(AVG(TRUNC(CON,3)), 'FM999,990.000') AS CON_AVG
			, TO_CHAR(MIN(TRUNC(TOF,2)), 'FM999,990.00') AS TOF_MIN
			, TO_CHAR(MAX(TRUNC(TOF,2)), 'FM999,990.00') AS TOF_MAX
			, TO_CHAR(AVG(TRUNC(TOF,2)), 'FM999,990.00') AS TOF_AVG
			, TO_CHAR(MIN(TRUNC(TUR2,2)), 'FM999,990.00') AS TUR2_MIN
			, TO_CHAR(MAX(TRUNC(TUR2,2)), 'FM999,990.00') AS TUR2_MAX
			, TO_CHAR(AVG(TRUNC(TUR2,2)), 'FM999,990.00') AS TUR2_AVG
			, TO_CHAR(MIN(TRUNC(DOW2,2)), 'FM999,990.00') AS DOW2_MIN
			, TO_CHAR(MAX(TRUNC(DOW2,2)), 'FM999,990.00') AS DOW2_MAX
			, TO_CHAR(AVG(TRUNC(DOW2,2)), 'FM999,990.00') AS DOW2_AVG
			, TO_CHAR(MIN(TRUNC(TMP2,2)), 'FM999,990.00') AS TMP2_MIN
			, TO_CHAR(MAX(TRUNC(TMP2,2)), 'FM999,990.00') AS TMP2_MAX
			, TO_CHAR(AVG(TRUNC(TMP2,2)), 'FM999,990.00') AS TMP2_AVG
			, TO_CHAR(MIN(TRUNC(PHY2,2)), 'FM999,990.00') AS PHY2_MIN
			, TO_CHAR(MAX(TRUNC(PHY2,2)), 'FM999,990.00') AS PHY2_MAX
			, TO_CHAR(AVG(TRUNC(PHY2,2)), 'FM999,990.00') AS PHY2_AVG
			, TO_CHAR(MIN(TRUNC(CON2,3)), 'FM999,990.000') AS CON2_MIN
			, TO_CHAR(MAX(TRUNC(CON2,3)), 'FM999,990.000') AS CON2_MAX
			, TO_CHAR(AVG(TRUNC(CON2,3)), 'FM999,990.000') AS CON2_AVG
			, TO_CHAR(MIN(TRUNC(TOF2,2)), 'FM999,990.00') AS TOF2_MIN
			, TO_CHAR(MAX(TRUNC(TOF2,2)), 'FM999,990.00') AS TOF2_MAX
			, TO_CHAR(AVG(TRUNC(TOF2,2)), 'FM999,990.00') AS TOF2_AVG
		FROM (
			<isEqual property="data_type" compareValue="1">
				<include refid="getDefiniteHourDataListSum_SQL"/>
		    </isEqual>
		    <isNotEqual property="data_type" compareValue="1">
				<include refid="getDefiniteMinDataListSum_SQL"/>
		    </isNotEqual>
		)
	</select>
	
	<select id="getDataSelectCnt" parameterClass="String" resultClass="int">
		SELECT COUNT(*) CNT 
      	  FROM T_SELECT
      	WHERE USE_FLAG = #useFlag#
	</select>
	
	<!-- 선별보고서 측정기기 정보 -->
	<select id="getSelectDataInfo" parameterClass="selectDataVO" resultClass="selectDataVO">
		SELECT  DECODE(A.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			      , B.BRANCH_NAME||'-'||B.BRANCH_NO AS BRANCH_NAME
			      , A.RIVER_DIV
			      , A.FACT_CODE
			      , B.BRANCH_NO
			      , TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI') REG_DATE
			FROM T_FACT_INFO A
				  , T_FACT_BRANCH_INFO B
			WHERE A.FACT_CODE = B.FACT_CODE
				AND A.FACT_CODE = #fact_code#
				AND B.BRANCH_NO = #branch_no#
	</select>
	
	<!-- 데이터 선별 등록 -->
	<insert id="saveSelectDataInfo" parameterClass="selectDataVO">
		INSERT INTO T_SELECT_INFO(SEL_SEQ, RIVER_DIV, FACT_CODE, BRANCH_NO, SELECT_YEAR, SELECT_MONTH,  ETC_CONTENT, STATUS, REG_ID, REG_DATE, DEL_YN)
 		VALUES(#sel_seq#, #river_div#, #fact_code#, #branch_no#, #select_year#, #select_month#, #etc_content#, #status#, #reg_id#, TO_CHAR(SYSDATE, 'YYYYMMDDHH24MI'), 'N')
	</insert>
	
	<!-- 데이터 선별 정보 체크 -->
	<select id="getCntSelectDataInfo" parameterClass="selectDataVO" resultClass="java.lang.Integer">
		SELECT COUNT(*)
		  FROM T_SELECT_INFO
		WHERE RIVER_DIV = #river_div#
		    AND FACT_CODE = #fact_code#
		    AND BRANCH_NO = #branch_no#
		    AND SELECT_YEAR = #select_year#
		    AND SELECT_MONTH = #select_month#
		    AND DEL_YN = 'N'
	</select>
	
	<!-- 데이터 선별 정보 삭제 -->
	<delete id="deleteSelectDataInfo" parameterClass="selectDataVO">
		DELETE FROM T_SELECT_INFO
		WHERE RIVER_DIV = #river_div#
		    AND FACT_CODE = #fact_code#
		    AND BRANCH_NO = #branch_no#
		    AND SELECT_YEAR = #select_year#
		    AND SELECT_MONTH = #select_month#
		    AND DEL_YN = 'N'
	</delete>
	
	<!-- 데이터 선별 SEQ 조회 -->
	<select id="selectSelInfoSeq" parameterClass="selectDataVO" resultClass="java.lang.Integer">
		SELECT SEQ_SEL_INFO.NEXTVAL FROM DUAL
	</select>
	
	<!-- 데이터 선별 이력 SEQ 조회 -->
	<select id="selectSelInfoHisSeq" parameterClass="selectDataVO" resultClass="java.lang.Integer">
		SELECT SEQ_SEL_INFO_HIS.NEXTVAL FROM DUAL
	</select>
	
	<!-- 데이터 선별 이력 등록 -->
	<insert id="saveSelectDataInfoHis" parameterClass="selectDataVO">
		INSERT INTO T_SELECT_INFO_HIS(SEL_HIS_SEQ, SEL_SEQ, RIVER_DIV, FACT_CODE, BRANCH_NO, SELECT_YEAR, SELECT_MONTH, ETC_CONTENT, STATUS, REG_ID, REG_DATE)
 		VALUES(#sel_his_seq#, #sel_seq#, #river_div#, #fact_code#, #branch_no#, #select_year#, #select_month#, #etc_content#, #status#, #reg_id#, TO_CHAR(SYSDATE, 'YYYYMMDDHH24MI'))
	</insert>
	
	<!--데이터 확정 조회 -->
	<select id="getSelectConfirmList" parameterClass="selectDataVO" resultClass="selectDataVO">
		SELECT A.SEL_SEQ
			     , A.RIVER_DIV
			     , DECODE(A.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
			     , A.FACT_CODE
			     , A.BRANCH_NO
			     , D.BRANCH_NAME||'-'||D.BRANCH_NO BRANCH_NAME
			     , A.SELECT_YEAR
			     , A.SELECT_MONTH
			     , A.ETC_CONTENT
			     , A.STATUS
			     , DECODE(A.STATUS,'S','선별','E','확정') STATUS_NAME
			     , B.MEMBER_NAME REG_NAME
			     , A.REG_DATE
			FROM T_SELECT_INFO A, T_MEMBER B, T_FACT_INFO C, T_FACT_BRANCH_INFO D
			<isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
				,T_MEMBER_AUTHORINFO E
			</isNotEqual>
			WHERE A.REG_ID = B.MEMBER_ID(+)
			  AND A.FACT_CODE = C.FACT_CODE
			  AND C.FACT_CODE = D.FACT_CODE
			  AND A.BRANCH_NO = D.BRANCH_NO
			  AND D.BRANCH_USE_FLAG = 'Y'
			  <!-- 20160226 수정 -->
			  <isNotEqual property="river_div" compareValue="all">
			  AND A.RIVER_DIV = #river_div#
			  </isNotEqual>
			  <isNotEqual property="fact_code" compareValue="all">
			  AND A.FACT_CODE = #fact_code#
			  </isNotEqual>
			  <isNotEqual property="branch_no" compareValue="all">
			  AND A.BRANCH_NO = #branch_no#
			  </isNotEqual>
			  AND A.SELECT_YEAR = #select_year#
			  AND A.SELECT_MONTH = #select_month#
			  AND A.DEL_YN = 'N'
			  <isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
			    AND E.MEMBER_ID = #userId#
			    AND A.RIVER_DIV = E.RIVER_DIV
				AND A.FACT_CODE = E.FACT_CODE
				AND A.BRANCH_NO = E.BRANCH_NO
			  </isNotEqual>
			ORDER BY A.RIVER_DIV ASC, A.FACT_CODE ASC
	</select>
	
	<!--데이터 확정 조회 -->
	<select id="getSelectConfirmListCnt" parameterClass="selectDataVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT COUNT(*)
			FROM T_SELECT_INFO A, T_MEMBER B, T_FACT_INFO C, T_FACT_BRANCH_INFO D
			<isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
				,T_MEMBER_AUTHORINFO E
			</isNotEqual>
			WHERE A.REG_ID = B.MEMBER_ID(+)
			  AND A.FACT_CODE = C.FACT_CODE
			  AND C.FACT_CODE = D.FACT_CODE
			  AND A.BRANCH_NO = D.BRANCH_NO
			  AND D.BRANCH_USE_FLAG = 'Y'
			   <!-- 20160226 수정 -->
			  <isNotEqual property="river_div" compareValue="all">
			  AND A.RIVER_DIV = #river_div#
			  </isNotEqual>
			  <isNotEqual property="fact_code" compareValue="all">
			  AND A.FACT_CODE = #fact_code#
			  </isNotEqual>
			  <isNotEqual property="branch_no" compareValue="all">
			  AND A.BRANCH_NO = #branch_no#
			  </isNotEqual>
			  AND A.SELECT_YEAR = #select_year#
			  AND A.SELECT_MONTH = #select_month#
			  AND A.DEL_YN = 'N'
			  <isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
			  	AND E.MEMBER_ID = #userId#
			    AND A.RIVER_DIV = E.RIVER_DIV
				AND A.FACT_CODE = E.FACT_CODE
				AND A.BRANCH_NO = E.BRANCH_NO
			  </isNotEqual>
	</select>
	
	<!--  데이터 선별 취소-->
	<update id="cancelSelectDataInfo" parameterClass="selectDataVO">
		UPDATE T_SELECT_INFO
		SET DEL_YN = 'Y'
		WHERE SEL_SEQ = #sel_seq#
	</update>
	
	<!--  데이터 확정-->
	<update id="confirmSelectDataInfo" parameterClass="selectDataVO">
		UPDATE T_SELECT_INFO
		     SET STATUS = #status#
		         , CONFIRM_ID = #reg_id#
		         , CONFIRM_DATE = TO_CHAR(SYSDATE, 'YYYYMMDDHH24MI')
		 WHERE SEL_SEQ = #sel_seq#
	</update>
	
	<!-- 데이터 이력 -->
	<insert id="insertSelectDataInfoHis" parameterClass="selectDataVO">
		INSERT INTO T_SELECT_INFO_HIS(SEL_HIS_SEQ, SEL_SEQ, RIVER_DIV, FACT_CODE, BRANCH_NO, SELECT_YEAR, SELECT_MONTH, ETC_CONTENT, CANCEL_CONTENT, STATUS, REG_ID, REG_DATE)
		SELECT #sel_his_seq#
		     , SEL_SEQ
		     , RIVER_DIV
		     , FACT_CODE
		     , BRANCH_NO
		     , SELECT_YEAR
		     , SELECT_MONTH
		     , ETC_CONTENT
		     , #cancel_content#
		     , #status#
		     , #reg_id#
		     , TO_CHAR(SYSDATE, 'YYYYMMDDHH24MI')
		FROM T_SELECT_INFO
		WHERE SEL_SEQ  =#sel_seq#
	</insert>
	
	<!--데이터선별이력 조회 -->
	<select id="getSelectDataHisList" parameterClass="selectDataVO" resultClass="selectDataVO">
		SELECT * FROM ( 
		SELECT ROWNUM RNUM, T.* FROM (
			SELECT  B.SEL_HIS_SEQ
				      , A.SEL_SEQ 
				      , A.RIVER_DIV
				      , DECODE(A.RIVER_DIV,'R01','한강','R02','낙동강','R03','금강','R04','영산강') AS RIVER_NAME
				      , A.FACT_CODE
				      , A.BRANCH_NO
				      , F.BRANCH_NAME||'-'||F.BRANCH_NO BRANCH_NAME
				      , A.SELECT_YEAR
				      , A.SELECT_MONTH
				      , A.ETC_CONTENT
				      , B.STATUS
				      , DECODE(B.STATUS,'S','선별','C','선별취소','E','확정','D','확정취소') STATUS_NAME 
				      , A.REG_ID
				      , C.MEMBER_NAME REG_NAME
				      , SUBSTR(A.REG_DATE,0,4)||'/'||SUBSTR(A.REG_DATE,5,2)||'/'||SUBSTR(A.REG_DATE,7,2) REG_DATE
				      , A.CONFIRM_ID
				      , D.MEMBER_NAME CONFIRM_NAME
				      , A.CONFIRM_DATE
			FROM T_SELECT_INFO A, T_SELECT_INFO_HIS B, T_MEMBER C, T_MEMBER D, T_FACT_INFO E, T_FACT_BRANCH_INFO F
			<isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
			, T_MEMBER_AUTHORINFO G 
			</isNotEqual>
		  WHERE A.SEL_SEQ = B.SEL_SEQ
			  AND A.REG_ID     = C.MEMBER_ID(+)
			  AND A.CONFIRM_ID     = D.MEMBER_ID(+)
			  AND A.FACT_CODE    = E.FACT_CODE
			  AND E.FACT_CODE    = F.FACT_CODE
			  AND A.BRANCH_NO    = F.BRANCH_NO
			  AND F.BRANCH_USE_FLAG = 'Y'
			  <isNotEqual property="river_div" compareValue="all">
			   AND A.RIVER_DIV = #river_div#
			  </isNotEqual>
			  <isNotEqual property="fact_code" compareValue="all">
			  AND A.FACT_CODE = #fact_code#
			  </isNotEqual>
			  <isNotEqual property="branch_no" compareValue="all">
			  AND A.BRANCH_NO = #branch_no#
			  </isNotEqual>
			  <isNotEqual property="searchStatus" compareValue="all">
			  AND B.STATUS = #searchStatus#
			  </isNotEqual>
			  AND A.SELECT_YEAR = #select_year#
			  AND A.SELECT_MONTH = #select_month#
			  <isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
			  	AND G.MEMBER_ID = #userId#
				AND A.RIVER_DIV = G.RIVER_DIV
				AND A.FACT_CODE = G.FACT_CODE
				AND A.BRANCH_NO = G.BRANCH_NO
			  </isNotEqual>
			ORDER BY B.SEL_HIS_SEQ DESC
			) T
		)
		WHERE
		<![CDATA[
			RNUM  > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>
	</select>
	
	<!--데이터선별이력 조회 -->
	<select id="getSelectDataHisListCnt" parameterClass="selectDataVO" resultClass="java.lang.Integer" remapResults="true">
		SELECT  COUNT(*)
			FROM T_SELECT_INFO A, T_SELECT_INFO_HIS B, T_MEMBER C, T_MEMBER D, T_FACT_INFO E, T_FACT_BRANCH_INFO F
			<isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
			, T_MEMBER_AUTHORINFO G 
			</isNotEqual>
		  WHERE A.SEL_SEQ = B.SEL_SEQ
			  AND A.REG_ID     = C.MEMBER_ID(+)
			  AND A.CONFIRM_ID     = D.MEMBER_ID(+)
			  AND A.FACT_CODE    = E.FACT_CODE
			  AND E.FACT_CODE    = F.FACT_CODE
			  AND A.BRANCH_NO    = F.BRANCH_NO
			  AND F.BRANCH_USE_FLAG = 'Y'
			  <isNotEqual property="river_div" compareValue="all">
			  AND A.RIVER_DIV = #river_div#
			  </isNotEqual>
			  <isNotEqual property="fact_code" compareValue="all">
			  AND A.FACT_CODE = #fact_code#
			  </isNotEqual>
			  <isNotEqual property="branch_no" compareValue="all">
			  AND A.BRANCH_NO = #branch_no#
			  </isNotEqual>
			  <isNotEqual property="searchStatus" compareValue="all">
			  AND B.STATUS = #searchStatus#
			  </isNotEqual>
			  AND A.SELECT_YEAR = #select_year#
			  AND A.SELECT_MONTH = #select_month#
			  <isNotEqual property="roleCode" compareValue="ROLE_ADMIN">
			  	AND G.MEMBER_ID = #userId#
				AND A.RIVER_DIV = G.RIVER_DIV
				AND A.FACT_CODE = G.FACT_CODE
				AND A.BRANCH_NO = G.BRANCH_NO
			  </isNotEqual>
	</select>
	
	<!-- 취소사유 정보 조회 -->
	<select id="getCancelDataInfo" parameterClass="String" resultClass="selectDataVO" remapResults="true">
		SELECT CANCEL_CONTENT
		  FROM T_SELECT_INFO_HIS
		WHERE SEL_HIS_SEQ = #sel_his_seq#
	</select>
	
	<!-- 기타사항 정보 조회 -->
	<select id="getSelectDataEtcInfo" parameterClass="int" resultClass="selectDataVO" remapResults="true">
		SELECT ETC_CONTENT
		        ,  SUBSTR(REG_DATE,0,4)||'/'||SUBSTR(REG_DATE,5,2)||'/'||SUBSTR(REG_DATE,7,2)||' '||SUBSTR(REG_DATE,9,2)||':'||SUBSTR(REG_DATE,11,2)  REG_DATE
		        ,  REG_ID
		  FROM T_SELECT_INFO
		WHERE SEL_SEQ = #sel_seq#
	</select>
	
	<update id="updateAtchFileId" parameterClass="String">
		UPDATE T_SELECT
		SET ATCH_FILE_ID = ''
		WHERE ATCH_FILE_ID = #atchFileId#
	</update>
	
	<select id="getSelectDataFileList" parameterClass="selectDataVO" resultClass="selectDataVO">
		SELECT ATCH_FILE_ID
			     , FILE_SEQ
			     , SUBSTR(STR_TIME,0,8)||' '||SUBSTR(STR_TIME,9,2)||':'||SUBSTR(STR_TIME,11,2) STR_TIME
 				 , SUBSTR(END_TIME,0,8)||' '||SUBSTR(END_TIME,9,2)||':'||SUBSTR(END_TIME,11,2) END_TIME
  				 , CASE
						WHEN SEL_ITEM = 'all' THEN '전체'
						WHEN SEL_ITEM != 'all' THEN (SELECT ITEM_NAME FROM T_ITEM_INFO WHERE ITEM_CODE = SEL_ITEM)
				   END AS SEL_ITEM
				 , ORIGNL_FILE_NAME
				 , SAVE_PATH||SAVE_FILE_NAME IMG_URL
		FROM(
			SELECT  C.ATCH_FILE_ID 
	       			  , C.FILE_SEQ
	       			  , A.REG_DATE
	       			  , A.STR_TIME
				      , A.END_TIME
				      , A.SEL_ITEM
				      , C.ORIGNL_FILE_NAME
				      , C.SAVE_PATH
				      , C.SAVE_FILE_NAME
			FROM T_SELECT A, T_SELECT_ITEM B, T_FILEDETAIL C
			WHERE A.SEL_SEQ = B.SEL_SEQ
				AND A.STR_TIME BETWEEN #searchYear#||#searchMonth#||'010000' AND #searchYear#||#searchMonth#||#lastDay#||'2359'
				AND B.FACT_CODE = #fact_code#
				AND B.BRANCH_NO = #branch_no#
				AND A.USE_FLAG = 'Y'
				AND A.ATCH_FILE_ID IS NOT NULL
			    AND A.ATCH_FILE_ID = C.ATCH_FILE_ID
			GROUP BY C.ATCH_FILE_ID, C.FILE_SEQ, REG_DATE, A.STR_TIME, A.END_TIME, A.SEL_ITEM, C.ORIGNL_FILE_NAME, C.SAVE_PATH, C.SAVE_FILE_NAME
		)ORDER BY REG_DATE DESC
	</select>
	
	<!-- 데이터 선별 초기화 -->
	<delete id="initSelectData" parameterClass="selectDataVO">
		DELETE FROM T_SELECT
				WHERE SEL_SEQ IN (
					SELECT SEL_SEQ 
					FROM T_SELECT_ITEM
					WHERE FACT_CODE = #fact_code#
					AND BRANCH_NO = #branch_no#
					AND SUBSTR(MIN_TIME, 0, 6) = #select_year#||#select_month#
				)
	</delete>
	
	<!-- 데이터 선별 초기화 -->
	<delete id="initSelectDataItem" parameterClass="selectDataVO">
		DELETE FROM T_SELECT_ITEM
		WHERE FACT_CODE = #fact_code#
		AND BRANCH_NO = #branch_no#
		AND SUBSTR(MIN_TIME, 0, 6) = #select_year#||#select_month#
	</delete>
	
	<!-- 데이터 선별 선택 초기화 -->
	<delete id="initCheckSelectData" parameterClass="String">
		DELETE FROM T_SELECT
		WHERE SEL_SEQ = #sel_seq#
	</delete>
	
	<!-- 데이터 선별 선택 초기화 -->
	<delete id="initCheckSelectDataItem" parameterClass="String">
		DELETE FROM T_SELECT_ITEM
		WHERE SEL_SEQ = #sel_seq#
	</delete>
	
	<statement id="goStatusCode" parameterClass="HashMap" resultClass="HashMap">
		SELECT STATUS_CODE VALUE, STATUS_DESC||DECODE(STATUS_DETAIL,NULL,'','_')||STATUS_DETAIL CAPTION
		  FROM T_DEFINITE_MAPPING_CODE
		WHERE STATUS = #status#
		ORDER BY STATUS_CODE
	</statement>
	
	<!-- 데이터 선별 상세 조회 -->
	<select id="getSelectDataReason" parameterClass="selectDataVO" resultClass="selectDataVO">
		SELECT BB.STATUS_DESC||DECODE(BB.STATUS_DETAIL,NULL,'','_')||BB.STATUS_DETAIL STATUS_CONTENT, AA.SEL_REASON
	      FROM T_SELECT AA, T_DEFINITE_MAPPING_CODE BB
	      WHERE AA.SEL_STATUS = BB.STATUS_CODE(+)
	        AND SEL_SEQ = (
							      SELECT SEL_SEQ 
							        FROM T_SELECT_ITEM
							      WHERE FACT_CODE = #fact_code#
							          AND BRANCH_NO = #branch_no#
							          AND ITEM_CODE = #item_code#
							          AND MIN_TIME = #min_time#
							      )
	</select>
	
	<statement id="getGongkuListKumho" parameterClass="HashMap" resultClass="HashMap">
		SELECT    FACT_CODE AS VALUE
                  ,FACT_NAME AS CAPTION
          FROM    T_FACT_INFO
         WHERE    FACT_CODE
            IN    (
                   'S02010'
                   ,'S02004'
                   ,'47A0201'
                   ,'47A0211'
                   ,'47G0021'
                   ,'47C0011'
                   ,'27A0062'
                   ,'27A0071'
                   ,'27A0021'
                   ,'27A0031'
                   ,'27A0011'
                   ,'47A0571'
                  )
	</statement>
	
	<statement id="getKumhoRealData"  parameterClass="searchTaksuVO"  resultClass="detailViewVO" remapResults="true">
		SELECT 
			 * 
			 FROM ( 
				 SELECT 
					 ROWNUM RNUM, T.*
					FROM
					(	
						SELECT  FACTNAME
						        ,MINTIME
						        ,NVL(TO_CHAR(SUM(FLOW), 'FM999,999.00'),'-') FLW
						        ,NVL(TO_CHAR(SUM(TEMP), 'FM999,990.00'),'-') TMP
						        ,NVL(TO_CHAR(SUM(DOW), 'FM999,990.00'),'-') DOW
						        ,NVL(TO_CHAR(SUM(BOD), 'FM999,990.00'),'-') BOD
						        ,NVL(TO_CHAR(SUM(COD), 'FM999,990.00'),'-') COD
						        ,NVL(TO_CHAR(SUM(TN), 'FM999,990.00'),'-') TON
						        ,NVL(TO_CHAR(SUM(TP), 'FM999,990.00'),'-') TOP
						  FROM	(        
							        SELECT	(SELECT FACT_NAME FROM T_FACT_INFO WHERE FACT_CODE = A.FACT_CODE) FACTNAME
							                ,TO_CHAR(TO_DATE(hour_time, 'yyyymmddhh24'), 'yyyy-mm-dd hh24') MINTIME 
							                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_VL) FLOW 
							                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TMP', HOUR_VL) TEMP
							                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'DOW', HOUR_VL) DOW
							                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_VL) BOD
							                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_VL) COD
							                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', HOUR_VL) TN
							                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_VL) TP
							          FROM 	T_HOUR_DATA_GIS A
							         WHERE 	FACT_CODE = #gongku#
							           AND 	BRANCH_NO = 1
							           AND 	HOUR_TIME <![CDATA[>=]]> #frDate#||#frTime#
							           AND 	HOUR_TIME <![CDATA[<=]]> #toDate#||#toTime#
						        )
				         GROUP 	BY FACTNAME, MINTIME
				         ORDER 	BY MINTIME DESC
					) T
			)
			WHERE
			<![CDATA[
				RNUM  > #firstIndex#
				AND  RNUM <= #firstIndex# + #recordCountPerPage#
			]]>	
	</statement>
	
	<statement id="getKumhoRealData_cnt"  parameterClass="searchTaksuVO" resultClass="java.lang.Integer">
			SELECT	COUNT(*)
			  FROM
				(
					SELECT  FACTNAME
					        ,MINTIME
					        ,NVL(TO_CHAR(SUM(FLOW), 'FM999,999.00'),'-') FLW
					        ,NVL(TO_CHAR(SUM(TEMP), 'FM999,990.00'),'-') TMP
					        ,NVL(TO_CHAR(SUM(DOW), 'FM999,990.00'),'-') DOW
					        ,NVL(TO_CHAR(SUM(BOD), 'FM999,990.00'),'-') BOD
					        ,NVL(TO_CHAR(SUM(COD), 'FM999,990.00'),'-') COD
					        ,NVL(TO_CHAR(SUM(TN), 'FM999,990.00'),'-') TON
					        ,NVL(TO_CHAR(SUM(TP), 'FM999,990.00'),'-') TOP
					  FROM	(        
						        SELECT	(SELECT FACT_NAME FROM T_FACT_INFO WHERE FACT_CODE = A.FACT_CODE) FACTNAME
						                ,TO_CHAR(TO_DATE(hour_time, 'yyyymmddhh24'), 'yyyy-mm-dd hh24') MINTIME 
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_VL) FLOW 
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TMP', HOUR_VL) TEMP
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'DOW', HOUR_VL) DOW
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_VL) BOD
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_VL) COD
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', HOUR_VL) TN
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_VL) TP
						          FROM 	T_HOUR_DATA_GIS A
						         WHERE 	FACT_CODE = #gongku#
						           AND 	BRANCH_NO = 1
						           AND 	HOUR_TIME <![CDATA[>=]]> #frDate#||#frTime#
						           AND 	HOUR_TIME <![CDATA[<=]]> #toDate#||#toTime#
					        )
			         GROUP 	BY FACTNAME, MINTIME
			         ORDER 	BY MINTIME DESC
				)
	</statement>
	
	<statement id="getKumhoModelingData"  parameterClass="searchTaksuVO"  resultClass="detailViewVO" remapResults="true">
		SELECT 
		 * 
		 FROM ( 
			 SELECT 
				 ROWNUM RNUM, T.*
				FROM
				(	
					SELECT  FACTNAME
					        ,MINTIME
					        ,NVL(TO_CHAR(SUM(FLOW), 'FM999,999.00'),'-') FLW
					        ,NVL(TO_CHAR(SUM(TEMP), 'FM999,990.00'),'-') TMP
					        ,NVL(TO_CHAR(SUM(DOW), 'FM999,990.00'),'-') DOW
					        ,NVL(TO_CHAR(SUM(BOD), 'FM999,990.00'),'-') BOD
					        ,NVL(TO_CHAR(SUM(COD), 'FM999,990.00'),'-') COD
					        ,NVL(TO_CHAR(SUM(TN), 'FM999,990.00'),'-') TON
					        ,NVL(TO_CHAR(SUM(TP), 'FM999,990.00'),'-') TOP
					  FROM	(        
						        SELECT	(SELECT FACT_NAME FROM T_FACT_INFO WHERE FACT_CODE = A.FACT_CODE) FACTNAME
						                ,TO_CHAR(TO_DATE(hour_time, 'yyyymmdd'), 'yyyy-mm-dd') MINTIME 
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_VL) FLOW 
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TMP', HOUR_VL) TEMP
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'DOW', HOUR_VL) DOW
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_VL) BOD
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_VL) COD
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', HOUR_VL) TN
						                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_VL) TP
						          FROM 	T_HOUR_DATA_MODEL A
						         WHERE 	HOUR_TIME = #frDate#
					        )
			         GROUP 	BY FACTNAME, MINTIME
			         ORDER 	BY FACTNAME
				) T
		)
		WHERE
		<![CDATA[
			RNUM  > #firstIndex#
			AND  RNUM <= #firstIndex# + #recordCountPerPage#
		]]>	
	</statement>
	
	<statement id="getKumhoModelingData_cnt"  parameterClass="searchTaksuVO" resultClass="java.lang.Integer">
		SELECT	COUNT(*)
		  FROM
			(
				SELECT  FACTNAME
				        ,MINTIME
				        ,NVL(TO_CHAR(SUM(FLOW), 'FM999,999.00'),'-') FLW
				        ,NVL(TO_CHAR(SUM(TEMP), 'FM999,990.00'),'-') TMP
				        ,NVL(TO_CHAR(SUM(DOW), 'FM999,990.00'),'-') DOW
				        ,NVL(TO_CHAR(SUM(BOD), 'FM999,990.00'),'-') BOD
				        ,NVL(TO_CHAR(SUM(COD), 'FM999,990.00'),'-') COD
				        ,NVL(TO_CHAR(SUM(TN), 'FM999,990.00'),'-') TON
				        ,NVL(TO_CHAR(SUM(TP), 'FM999,990.00'),'-') TOP
				  FROM	(        
					        SELECT	(SELECT FACT_NAME FROM T_FACT_INFO WHERE FACT_CODE = A.FACT_CODE) FACTNAME
					                ,TO_CHAR(TO_DATE(hour_time, 'yyyymmdd'), 'yyyy-mm-dd') MINTIME 
					                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'FLW', HOUR_VL) FLOW 
					                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TMP', HOUR_VL) TEMP
					                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'DOW', HOUR_VL) DOW
					                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'BOD', HOUR_VL) BOD
					                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'COD', HOUR_VL) COD
					                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TON', HOUR_VL) TN
					                ,DECODE(SUBSTR(A.ITEM_CODE, 0, 3), 'TOP', HOUR_VL) TP
					          FROM 	T_HOUR_DATA_MODEL A
					         WHERE 	HOUR_TIME = #frDate#
				        )
		         GROUP 	BY FACTNAME, MINTIME
		         ORDER 	BY FACTNAME
			)
	</statement>
	
	<statement id="mergeHourDataModeling" parameterClass="excelModelVO" resultClass="int">
		MERGE INTO T_HOUR_DATA_MODEL
		USING DUAL
		ON ( FACT_CODE = #factCode# AND ITEM_CODE = #itemCode# AND HOUR_TIME = #hourTime# AND MESU_TYPE = #mesuType# )
		WHEN MATCHED THEN
			UPDATE SET HOUR_VL = #hourVl#
		WHEN NOT MATCHED THEN
			INSERT (
					   FACT_CODE 
					 , ITEM_CODE
					 , HOUR_TIME
					 , HOUR_VL
					 , MESU_TYPE
					)
			VALUES (
					   #factCode#
					 , #itemCode#
					 , #hourTime#
					 , #hourVl#
					 , #mesuType#
					)
	</statement>
</sqlMap>